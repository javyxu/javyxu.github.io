<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"javyxu.cn","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="C++风格规范（Google版）头文件Self-contained头文件所有头文件要能够自给自足。即：用户和重工具不需要为特别场合而包含额外的头文件。 #defined保护所有头文件都应该使用#define来防止头文件被多重包含，命名格式是&lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H。为保证唯一性，头文件的命名应该基于所在项目源代码树的全路径。 前置声明尽">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ Style of Google">
<meta property="og:url" content="https://javyxu.cn/c++/c++_style_of_google/index.html">
<meta property="og:site_name" content="Tech Blog">
<meta property="og:description" content="C++风格规范（Google版）头文件Self-contained头文件所有头文件要能够自给自足。即：用户和重工具不需要为特别场合而包含额外的头文件。 #defined保护所有头文件都应该使用#define来防止头文件被多重包含，命名格式是&lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H。为保证唯一性，头文件的命名应该基于所在项目源代码树的全路径。 前置声明尽">
<meta property="og:locale">
<meta property="article:published_time" content="2018-11-03T09:30:00.000Z">
<meta property="article:modified_time" content="2021-02-21T02:37:33.302Z">
<meta property="article:author" content="Javy">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://javyxu.cn/c++/c++_style_of_google/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh'
  };
</script>

  <title>C++ Style of Google | Tech Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Tech Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Javy's Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-algorithm">

    <a href="/algorithm/" rel="section"><i class="fa fa-code fa-fw"></i>Algorithm</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/javyxu" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="https://javyxu.cn/c++/c++_style_of_google/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Javy">
      <meta itemprop="description" content="You can create art and beauty on a computer.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tech Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++ Style of Google
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-11-03 17:30:00" itemprop="dateCreated datePublished" datetime="2018-11-03T17:30:00+08:00">2018-11-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-02-21 10:37:33" itemprop="dateModified" datetime="2021-02-21T10:37:33+08:00">2021-02-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="C-风格规范（Google版）"><a href="#C-风格规范（Google版）" class="headerlink" title="C++风格规范（Google版）"></a>C++风格规范（Google版）</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><h4 id="Self-contained头文件"><a href="#Self-contained头文件" class="headerlink" title="Self-contained头文件"></a>Self-contained头文件</h4><p>所有头文件要能够自给自足。即：用户和重工具不需要为特别场合而包含额外的头文件。</p>
<h4 id="defined保护"><a href="#defined保护" class="headerlink" title="#defined保护"></a>#defined保护</h4><p>所有头文件都应该使用#define来防止头文件被多重包含，命名格式是<font color=red><code>&lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H</code></font>。<br>为保证唯一性，头文件的命名应该基于所在项目源代码树的全路径。</p>
<h4 id="前置声明"><a href="#前置声明" class="headerlink" title="前置声明"></a>前置声明</h4><p>尽可能地避免使用前置声明。使用<font color=red><code>#include</code></font>包含需要的头文件即可。</p>
<h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>所谓<code>前置声明（forward declaration）</code>是类、函数和模板的纯粹声明，没伴随着其定义。</p>
<h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ul>
<li>前置声明能够节省编译时间，多余的<font color=red><code>#include</code></font>会迫使编译器展开更多的文件，处理更多的输入。</li>
<li>前置声明能够节省不必要的重新编译的时间。<font color=red><code>#inclue</code></font>使代码因头文件中无关的改动而被重新编译多次。</li>
</ul>
<h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ul>
<li>前置声明隐依赖关系，头文件改动时，用户的代码会跳过必要的重新编译过程。</li>
<li>前置声明可能会被库的后续更改所破坏。前置声明函数或模板有时会妨碍头文件开发者变动其API。</li>
<li>前置声明来自命名空间<font color=red><code>std::</code></font>的symbol时，其行为未定义。</li>
<li>很难判断什么时候该用前置声明，什么时候该用<font color=red><code>#include</code></font>。极端情况下，用前置声明代替<font color=red><code>inclues</code></font>甚至都会暗暗地改变代码的含义。</li>
<li>前置声明不少来自头文件的symbol时，就会比单单一行的<font color=red><code>include</code></font>冗长。</li>
<li>仅仅为了前置声明而重构代码，会使代码变得更慢更复杂。</li>
</ul>
<h5 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h5><ul>
<li>尽量避免前置声明那些定义在其他项目中的实体。</li>
<li>函数：总是使用<font color=red><code>#include</code></font></li>
<li>类模板：优先使用<font color=red><code>#include</code></font></li>
</ul>
<a id="more"></a>

<h4 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h4><p>只有当函数只有10行甚至更少时才将其定义为内联函数。</p>
<h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h5><p>当函数被声明为内联函数之后，编译器会将其内联展开，而不是按通常的函数调用机制进行调用。</p>
<h5 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h5><p>只要内联函数体较小，内联函数可以令目标代码更加高效。对于存取函数以及其他函数体比较短，性能关键的函数，鼓励使用内联。</p>
<h5 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h5><p>滥用内联函数导致程序变得更慢。内联可能使目标代码量或增或减，这取决于内联函数的大小。内联非常短小的存取函数通常会减少代码大小，但内联一个相当大得函数将戏剧性的增加代码大小。现代处理器由于更好的利用了指令缓存，小巧的代码往往执行更快。</p>
<h5 id="结论：-1"><a href="#结论：-1" class="headerlink" title="结论："></a>结论：</h5><ul>
<li>内联函数不要超过10行。谨慎对待析构函数，析构函数往往比其他表面看起来更长，因为有隐含的成员和基类析构函数被调用。</li>
<li>内联那些包含循环或<font color=red><code>switch</code></font>语句的函数常常是得不偿失。<br>有些函数即使声明为内联的也不一定会被编译内联。必须虚函数和递归函数就不会被正常内联。通常，递归函数不应该声明成内联函数。</li>
</ul>
<h4 id="include路径及顺序"><a href="#include路径及顺序" class="headerlink" title="#include路径及顺序"></a>#include路径及顺序</h4><p>使用标准的头文件包含顺序可增强可读性，避免隐藏依赖：相关头文件，C库、C++库，其他库的.h，本项目内的.h。<br>项目头文件应该按照项目源代码目录树结构排列，避免使用unix特殊的快捷目录<code>.</code>(当前目录)或<code>..</code>（上级目录）。</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p>鼓励在<font color=red><code>.cc</code></font>文件使用匿名命名空间或<font color=red><code>static</code></font>声明。使用具名的命名空间时，其名称可基于项目名或相对路径。精致使用using表示（using-directive）。禁止使用内联命名空间（inline namespace）。</p>
<h5 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h5><p>命名空间将全局作用域细分为独立的，具名的作用域，可有效防止全局作用域的命名冲突。</p>
<h5 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h5><p>虽然类已经提供了命名轴线，命名空间在这基础上又封装了一层。<br>内联命名空间会自动把内部的标识符放到外层作用域。</p>
<h5 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h5><p>命名空间具有迷惑性，因为它们使得区分两个相同命名所指代的定义更加困难。<br>内联命名空间很容易令人迷惑，毕竟其内部的成员不再受其声明所在命名空间的限制。内联命名空间只在大型版本控制里有用。<br>有时候不得不多次引用某个定义在许多嵌套命名空间里的实体，使用完整的命名空间会导致代码的冗长。<br>在头文件中使用匿名空间导致违背C++的唯一定义原则（One Definition Rule（ODR））。</p>
<h5 id="结论：-2"><a href="#结论：-2" class="headerlink" title="结论："></a>结论：</h5><ul>
<li>遵守命名空间命名的原则</li>
<li>在命名空间的最后注释出命名空间的名字</li>
<li>用命名空间把文件包含，gflags的声明/定义，以及类的前置声明以外的整个源文件封装起来，1以区别于其它命名空间</li>
<li>不要在命名空间<font color=red><code>std</code></font>内声明任何东西，包括标准库的类前置声明。在<font color=red><code>std</code></font>命名空间声明实体是未定义的行为，会导致如不可移植。声明标准库下的实体，需要包含对应的头文件。</li>
<li>不应该使用<em>using</em>指示引入整个命名空间的标识符号。</li>
<li>不要在头文件中使用<em>命名空间别名</em> 除非显式标记内部命名空间使用。因为任何在头文件中引入的命名空间都会成为公开API的一部分。</li>
<li>禁止使用内联命名空间。</li>
</ul>
<h4 id="匿名命名空间和静态变量"><a href="#匿名命名空间和静态变量" class="headerlink" title="匿名命名空间和静态变量"></a>匿名命名空间和静态变量</h4><p>在<font color=red><code>.cc</code></font>文件中定义一个不需要被外部引用的变量时，可以将它们放在匿名命名空间或声明为<font color=red><code>static</code></font>。但是不要在<font color=red><code>.h</code></font>文件中这么做。</p>
<h5 id="定义：-2"><a href="#定义：-2" class="headerlink" title="定义："></a>定义：</h5><p>所有置于匿名命名空间的声明都具有内部链接性，函数和变量可以经由声明为<font color=red><code>static</code></font>拥有内部链接性，这意味着你在这个文件中声明的这些标识符都不能在另一个文件中被访问。即使两个文件声明了完全一样名字的标识符，它们所指向的实体实际上是完全不同的。</p>
<h5 id="结论：-3"><a href="#结论：-3" class="headerlink" title="结论："></a>结论：</h5><p>推荐、鼓励在<font color=red><code>.cc</code></font>中对于不需要在其他地方引用的标识符使用内部链接性声明，但是不要在<font color=red><code>.h</code></font>中使用。</p>
<p>匿名命名空间的声明和具名的格式相同，在最后注释上<code>namespace</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;  <span class="comment">//namespace</span></span><br></pre></td></tr></table></figure>
<h4 id="非成员函数、静态成员函数和全局函数"><a href="#非成员函数、静态成员函数和全局函数" class="headerlink" title="非成员函数、静态成员函数和全局函数"></a>非成员函数、静态成员函数和全局函数</h4><p>使用静态成员函数或命名空间内的非成员函数，尽量不要用裸的全局函数。将一系列函数直接置于命名空间中，不要用类的静态方法模拟出命名空间的效果，类的静态方法应当和类的实例或静态数据紧密相关。</p>
<h5 id="优点：-3"><a href="#优点：-3" class="headerlink" title="优点："></a>优点：</h5><p>某些情况下，非成员函数和静态成员函数是非常有用的，将非成员函数放在命名空间内可避免污染全局作用域。</p>
<h5 id="缺点：-3"><a href="#缺点：-3" class="headerlink" title="缺点："></a>缺点：</h5><p>将非成员函数和静态成员函数作为新类的成员函数作为新类的成员或许更有意义。当它们需要访问外部资源或具有重要的依赖关系时更是如此。</p>
<h5 id="结论：-4"><a href="#结论：-4" class="headerlink" title="结论："></a>结论：</h5><p>有时, 把函数的定义同类的实例脱钩是有益的, 甚至是必要的. 这样的函数可以被定义成静态成员, 或是非成员函数. 非成员函数不应依赖于外部变量, 应尽量置于某个命名空间内. 相比单纯为了封装若干不共享任何静态数据的静态成员函数而创建类。</p>
<p>定义在同一编译单元的函数, 被其他编译单元直接调用可能会引入不必要的耦合和链接时依赖; 静态成员函数对此尤其敏感. 可以考虑提取到新类中, 或者将函数置于独立库的命名空间内.</p>
<p>如果必须定义非成员函数, 又只是在<font color=red><code>.cc</code></font>文件中使用它, 可使用<code>匿名命名空间</code>或<font color=red><code>static</code></font>链接关键字 (如<font color=red><code>static int Foo() &#123;...&#125;</code></font>) 限定其作用域.</p>
<h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化。</p>
<p>C++允许在函数的任何位置声明变量。我们提倡在尽可能小的作用域中声明变量, 离第一次使用越近越好。 这使得代码浏览者更容易定位变量声明的位置, 了解变量的类型和初始值。特别是，应使用初始化的方式替代声明再赋值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> j = g(); <span class="comment">//初始化声明</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">1</span>); <span class="comment">//用花括号初始化更好</span></span><br><span class="line">v.push_back(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>属于<code>if</code>,<code>while</code>和<code>for</code>语句的变量应当在这些语句中正常地声明，这样子这些变量的作用域就被限制在这些语句中了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">const</span> <span class="keyword">char</span>* p = <span class="built_in">strchr</span>(str, <span class="string">&#x27;/&#x27;</span>)) strr = p + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><strong>注：</strong>有一个例外, 如果变量是一个对象, 每次进入作用域都要调用其构造函数, 每次退出作用域都要调用其析构函数. 这会导致效率降低。</p>
<h4 id="静态和全局变量"><a href="#静态和全局变量" class="headerlink" title="静态和全局变量"></a>静态和全局变量</h4><p>禁止定义静态储存周期非POD变量，禁止使用含有副作用的函数初始化POD全局变量，因为多编译单元中的静态变量执行时的构造和析构顺序是未明确的，这将导致代码的不可移植。</p>
<p>禁止使用类的<code>静态储存周期</code>变量：由于构造和析构函数调用顺序的不确定性，它们会导致难以发现的 bug 。不过<code>constexpr</code>变量除外，毕竟它们又不涉及动态初始化或析构。</p>
<p>静态生存周期的对象，即包括了全局变量，静态变量，静态类成员变量和函数静态变量，都必须是原生数据类型 (POD : Plain Old Data): 即 int, char 和 float, 以及 POD 类型的指针、数组和结构体。</p>
<p>静态变量的构造函数、析构函数和初始化的顺序在C++中是只有部分明确的，甚至随着构建变化而变化，导致难以发现的bug. 所以除了禁用类类型的全局变量，我们也不允许用函数返回值来初始化POD变量，除非该函数（比如<code>getenv()</code>或<code>getpid()</code>）不涉及任何全局变量。函数作用域里的静态变量除外，毕竟它的初始化顺序是有明确定义的，而且只会在指令执行到它的声明那里才会发生。</p>
<p>同理，全局和静态变量在程序中断时会被析构，无论所谓中断是从<code>main()</code>返回还是对<code>exit()</code>的调用。析构顺序正好与构造函数调用的顺序相反。但既然构造顺序未定义，那么析构顺序当然也就不定了。比如，在程序结束时某静态变量已经被析构了，但代码还在跑——比如其它线程——并试图访问它且失败；再比如，一个静态 string 变量也许会在一个引用了前者的其它变量析构之前被析构掉。</p>
<p>改善以上析构问题的办法之一是用<code>quick_exit()</code>来代替<code>exit()</code>并中断程序。它们的不同之处是前者不会执行任何析构，也不会执行<code>atexit()</code>所绑定的任何handlers. 如果您想在执行<code>quick_exit()</code>来中断时执行某handler（比如刷新log），您可以把它绑定到<code>_at_quick_exit()</code>. 如果您想在<code>exit()</code>和<code>quick_exit()</code>都用上该handler, 都绑定上去。</p>
<p>综上所述，我们只允许POD类型的静态变量，即完全禁用<code>vector</code>(使用C数组替代)和<code>string</code>(使用 <code>const char []</code>)。</p>
<p>如果您确实需要一个<code>class</code>类型的静态或全局变量，可以考虑在<code>main()</code>函数或<code>pthread_once()</code>内初始化一个指针且永不回收。注意只能用 raw 指针，别用智能指针，毕竟后者的析构函数涉及到上文指出的不定顺序问题。</p>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>类是C++中代码的基本单元。</p>
<h4 id="构造函数的职责"><a href="#构造函数的职责" class="headerlink" title="构造函数的职责"></a>构造函数的职责</h4><h5 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h5><p>不要在构造函数中调用虚函数，也不要在无法报出错误时进行可能失败的初始化。</p>
<h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p>在构造函数中可以进行各种初始化操作。</p>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul>
<li>无需考虑类是否被初始化</li>
<li>经过构造函数完全初始化后的对象可以为<code>const</code>类型，也能更方便地被标准容器或算法使用。</li>
</ul>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>如果在构造函数内调用了自身的虚函数, 这类调用是不会重定向到子类的虚函数实现. 即使当前没有子类化实现, 将来仍是隐患。</li>
<li>在没有使程序崩溃 (因为并不是一个始终合适的方法) 或者使用异常 (因为已经被 禁用 了) 等方法的条件下, 构造函数很难上报错误。</li>
<li>如果执行失败, 会得到一个初始化失败的对象, 这个对象有可能进入不正常的状态, 必须使用<code>bool isValid()</code>或类似这样的机制才能检查出来, 然而这是一个十分容易被疏忽的方法。</li>
<li>构造函数的地址是无法被取得的, 因此, 举例来说, 由构造函数完成的工作是无法以简单的方式交给其他线程的。</li>
</ul>
<h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><p>构造函数不允许调用虚函数. 如果代码允许, 直接终止程序是一个合适的处理错误的方式。否则, 考虑用<code>Init()</code>方法或工厂函数。</p>
<p>构造函数不得调用虚函数, 或尝试报告一个非致命错误。如果对象需要进行有意义的(non-trivial)初始化, 考虑使用明确的<code>Init()</code>方法或使用工厂模式. Avoid Init() methods on objects with no other states that affect which public methods may be called(此类形式的半构造对象有时无法正确工作)。</p>
<h4 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h4><h5 id="总述-1"><a href="#总述-1" class="headerlink" title="总述"></a>总述</h5><p>不要定义隐式类型转换。对于转换运算符和单参数构造函数，请使用<code>explicit</code>关键字。</p>
<h5 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h5><p>隐式类型转换允许一个某种类型(源类型)的对象被用于需要另一种类型(目的类型)的位置。<br>除了语言所定义的隐式类型转换，用户还可以通过在类定义中添加合适的成员定义自己需要的转换。在源类型中定义的隐式类型转换，可以通过目的的类型名的类型转换运算符实现(<code>operator bool()</code>)。在目的类型中定义隐式类型转换，泽通过以源类型作为其唯一参数(或唯一无默认值的参数)的构造函数实现。</p>
<p><code>explicit</code>关键字可以用于构造函数或类型转换运算符，以保证只有当目的类型在调用点被显示写明时才能进行类型转换。例如<code>cast</code>。这不仅用于隐式类型转换，还能作用于C++11的初始化语法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">double</span> y)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(Foo, f)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li>有时目的类型名是一目了然的，通过避免显示地写出类型名，隐式类型转换可以让一个类型的可用性和表达性更强。</li>
<li>隐式类型转换可以简单地取代函数重载。</li>
<li>在初始化对象时，列表初始化语法是一种简洁明了的写法。</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>隐式类型转换会隐藏不匹配的错误，有时，目的类型并不符合用户的期望，甚至用户根本没有意识到发生了类型转换。</li>
<li>隐式类型转换会让代码难以阅读, 尤其是在有函数重载的时候, 因为这时很难判断到底是哪个函数被调用。</li>
<li>单参数构造函数有可能会被无意地用作隐式类型转换。</li>
<li>如果单参数构造函数没有加上<font color=red><code>explicit</code></font>关键字, 读者无法判断这一函数究竟是要作为隐式类型转换, 还是作者忘了加上<font color=red><code>explicit</code></font>标记。</li>
<li>并没有明确的方法用来判断哪个类应该提供类型转换, 这会使得代码变得含糊不清。</li>
<li>如果目的类型是隐式指定的, 那么列表初始化会出现和隐式类型转换一样的问题, 尤其是在列表中只有一个元素的时候。</li>
</ul>
<h5 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h5><p>在类型定义中, 类型转换运算符和单参数构造函数都应当用<code>explicit</code>进行标记。一个例外是, 拷贝和移动构造函数不应当被标记为<code>explicit</code>, 因为它们并不执行类型转换。对于设计目的就是用于对其他类型进行透明包装的类来说, 隐式类型转换有时是必要且合适的。这时应当联系项目组长并说明特殊情况.</p>
<p>不能以一个参数进行调用的构造函数不应当加上<font color=red><code>explicit</code></font>。接受一个<font color=red><code>std::initializer_list</code></font>作为参数的构造函数也应当省略,<font color=red><code>explicit</code></font> 以便支持拷贝初始化(例如<font color=red><code>MyType m = &#123;1, 2&#125;;</code></font>)。</p>
<h4 id="可拷贝类型和可移动类型"><a href="#可拷贝类型和可移动类型" class="headerlink" title="可拷贝类型和可移动类型"></a>可拷贝类型和可移动类型</h4><h4 id="总述-2"><a href="#总述-2" class="headerlink" title="总述"></a>总述</h4><p>如果你的类型需要，就让它们指出拷贝/移动，否则，就把隐式产生的拷贝和移动函数禁用。</p>
<h5 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h5><p>可拷贝类型允许对象在初始化时得到来自相同类型的另一对象的值, 或在赋值时被赋予相同类型的另一对象的值, 同时不改变源对象的值。对于用户定义的类型, 拷贝操作一般通过拷贝构造函数与拷贝赋值操作符定义. <font color=red><code>string</code></font>类型就是一个可拷贝类型的例子。</p>
<p>可移动类型允许对象在初始化时得到来自相同类型的临时对象的值, 或在赋值时被赋予相同类型的临时对象的值 (因此所有可拷贝对象也是可移动的)。<font color=red><code>std::unique_ptr&lt;int&gt;</code></font>就是一个可移动但不可复制的对象的例子。对于用户定义的类型, 移动操作一般是通过移动构造函数和移动赋值操作符实现的。</p>
<p>拷贝 / 移动构造函数在某些情况下会被编译器隐式调用. 例如, 通过传值的方式传递对象。</p>
<h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><p>可移动及可拷贝类型的对象可以通过传值的方式进行传递或者返回, 这使得API更简单, 更安全也更通用。 与传指针和引用不同, 这样的传递不会造成所有权, 生命周期, 可变性等方面的混乱, 也就没必要在协议中予以明确。这同时也防止了客户端与实现在非作用域内的交互, 使得它们更容易被理解与维护。这样的对象可以和需要传值操作的通用API一起使用, 例如大多数容器。</p>
<p>拷贝/移动构造函数与赋值操作一般来说要比它们的各种替代方案, 比如<font color=red><code>Clone()</code></font>, <font color=red><code>CopyFrom()</code></font> or <font color=red><code>Swap()</code></font>, 更容易定义, 因为它们能通过编译器产生, 无论是隐式的还是通过<font color=red><code>= default</code></font>。 这种方式很简洁, 也保证所有数据成员都会被复制. 拷贝与移动构造函数一般也更高效, 因为它们不需要堆的分配或者是单独的初始化和赋值步骤, 同时, 对于类似 省略不必要的拷贝 这样的优化它们也更加合适。</p>
<p>移动操作允许隐式且高效地将源数据转移出右值对象. 这有时能让代码风格更加清晰。</p>
<h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><p>许多类型都不需要拷贝, 为它们提供拷贝操作会让人迷惑, 也显得荒谬而不合理. 单件类型 (<font color=red><code>Registerer</code></font>), 与特定的作用域相关的类型 (<font color=red><code>Cleanup</code></font>), 与其他对象实体紧耦合的类型 (<font color=red><code>Mutex</code></font>) 从逻辑上来说都不应该提供拷贝操作. 为基类提供拷贝 / 赋值操作是有害的, 因为在使用它们时会造成 对象切割。默认的或者随意的拷贝操作实现可能是不正确的, 这往往导致令人困惑并且难以诊断出的错误。</p>
<p>拷贝构造函数是隐式调用的, 也就是说, 这些调用很容易被忽略. 这会让人迷惑, 尤其是对那些所用的语言约定或强制要求传引用的程序员来说更是如此. 同时, 这从一定程度上说会鼓励过度拷贝, 从而导致性能上的问题。</p>
<h5 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h5><p>如果需要就让你的类型可拷贝/可移动. 作为一个经验法则, 如果对于你的用户来说这个拷贝操作不是一眼就能看出来的, 那就不要把类型设置为可拷贝。如果让类型可拷贝, 一定要同时给出拷贝构造函数和赋值操作的定义, 反之亦然。如果让类型可拷贝, 同时移动操作的效率高于拷贝操作, 那么就把移动的两个操作 (移动构造函数和赋值操作) 也给出定义。如果类型不可拷贝, 但是移动操作的正确性对用户显然可见, 那么把这个类型设置为只可移动并定义移动的两个操作。</p>
<p>如果定义了拷贝/移动操作, 则要保证这些操作的默认实现是正确的. 记得时刻检查默认操作的正确性, 并且在文档中说明类是可拷贝的且/或可移动的。</p>
<p>由于存在对象切割的风险, 不要为任何有可能有派生类的对象提供赋值操作或者拷贝 / 移动构造函数 (当然也不要继承有这样的成员函数的类). 如果你的基类需要可复制属性, 请提供一个 <font color=red><code>public virtual Clone()</code></font> 和一个 <font color=red><code>protected</code></font> 的拷贝构造函数以供派生类实现。</p>
<p>如果你的类不需要拷贝/移动操作, 请显式地通过在 <font color=red><code>public</code></font> 域中使用 <font color=red><code>= delete</code></font> 或其他手段禁用之。</p>
<h4 id="结构体和类"><a href="#结构体和类" class="headerlink" title="结构体和类"></a>结构体和类</h4><h5 id="总述-3"><a href="#总述-3" class="headerlink" title="总述"></a>总述</h5><p>仅当只有数据成员时使用<font color=red><code>struct</code></font>,其它一概使用<font color=red><code>calss</code></font>。</p>
<h5 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h5><p>在C++中<font color=red><code>struct</code></font>和<font color=red><code>calss</code></font>关键字几乎含义一样。我们为这两个关键字添加我们自己的语义理解，以便为定义的数据类型选择合适的关键字。</p>
<p><code>struct</code><font color=red></font>用来定义包含数据的被动式对象，也可以包含相关的常量，但除了存取数据成员之外，没有别的函数功能。并且存取功能是通过直接访问位域，而非函数调用。除了构造函数、析构函数，<font color=red><code>Initialize</code></font>、<font color=red><code>Reset</code></font>，<font color=red><code>Validate</code></font>等类似的用于设定数据成员的函数，不能提供其它功能的函数。</p>
<p>如果需要更多的函数功能，<font color=red><code>class</code></font>更适合。如果拿不准，就用<font color=red><code>class</code></font>。</p>
<p>为了和STL保持一致，对于仿函数等特性可以不用<font color=red><code>class</code></font>而使用<font color=red><code>struct</code></font>。</p>
<p>注意：类和结构体的成员变量使用不同的<a href="">命名规则</a>。</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><h5 id="总述-4"><a href="#总述-4" class="headerlink" title="总述"></a>总述</h5><p>使用组合常常比使用继承更合适。如果使用继承的话，定义为<font color=red><code>public</code></font>继承。</p>
<h5 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h5><p>当子类继承基类时，子类包含了父基类所有的数据以及操作的定以。C++实践中，继承主要用于两种场合：实现继承，子类继承父类的实现代码；接口继承，子类仅继承父类的方法名称。</p>
<h5 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h5><p>实现继承通过原封不动的复用基类代码减少了代码量。由于继承是在编译时声明，程序员和编译器都可以理解相应操作并发现错误。从编程角度而言，接口继承是用来强制类输出特定的API。在类没有实现API中某个必须的方法，编译器同样会发现并报告错误。</p>
<h5 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h5><p>对于实现继承，由于子类的实现代码散布在父类和子类之间，要理解其实现变得更加困难。子类不能重写父类的非虚函数，当然也就不能修改其实现。基类也可能定义了一些函数成员，因此还必须区分基类的实现布局。</p>
<h5 id="结论-3"><a href="#结论-3" class="headerlink" title="结论"></a>结论</h5><p>所有继承必须是<font color=red><code>public</code></font>。如果你想要使用私有继承，你应该替换成把基类的实例作为成员对象的方式。</p>
<p>不要过度使用实现继承。组合常常更适合一些，尽量做到只在“是一个”（”is-a”）的情况下使用继承：如果<font color=red><code>bar</code></font>的确“是一种”<font color=red><code>Foo</code></font>，<font color=red><code>bar</code></font>才能继承<font color=red><code>Foo</code></font>。</p>
<p>必要的话，析构函数声明为<font color=red><code>virtual</code></font>。如果你的类有虚函数，则析构函数也应该为虚函数。</p>
<p>对于可能被子类访问的成员函数，不要过度使用<font color=red><code>protected</code></font>关键字。注意，数据成员都必须是<a href="">私有的</a>。</p>
<p>对于重载的虚函数或析构函数，使用<font color=red><code>override</code></font>，或<font color=red><code>final</code></font>关键字显示地进行标记。较早的代码可能使用<font color=red><code>virtual</code></font>关键字作为不得已的选项。因此，在声明重载时，请使用<font color=red><code>override</code></font>、<font color=red><code>final</code></font>、<font color=red><code>virtual</code></font>中其中之一进行标记。标记为<font color=red><code>override</code></font>或<font color=red><code>final</code></font>的析构函数如果不是对基类虚函数的重载的话，编译会报错。这有助于捕获常见的错误。这些标记起到了文档的作用，因为如果省略这些关键字，代码阅读者不得不检查所有父类，以判断该杉树是否是虚函数。</p>
<h4 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h4><h5 id="总述-5"><a href="#总述-5" class="headerlink" title="总述"></a>总述</h5><p>真正需要到多重实现继承的情况少之又少。只在一下情况下才允许多重继承：最多只有一个基类是非抽象类；其他基类都是以<font color=red><code>Interface</code></font>后缀的<a href="">纯接口类</a>。</p>
<h5 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h5><p>多重继承允许子类拥有多个基类。要将作为<em>纯接口</em>的基类和具有<em>实现</em>的基类区别开来。</p>
<h5 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h5><p>相比单继承，多重实现继承可以复用更多的代码。</p>
<h5 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h5><p>真正需要用到多重<em>实现</em>继承的情况少之又少。有时多重实现继承看上去是不错的解决方案，但这是你通常可以找到一个更明确、更清晰的不同解决方案。</p>
<h5 id="结论-4"><a href="#结论-4" class="headerlink" title="结论"></a>结论</h5><p>只有当所有父类除第一个外都是<a href="">纯接口类</a>时，才允许使用多重继承。为确保它们是纯接口，这些类必须以<font color=red><code>Interface</code></font>为后缀。</p>
<p><strong>注意</strong></p>
<p>关于该规则，Windows下有个<a href="">特例</a>。</p>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><h5 id="总述-6"><a href="#总述-6" class="headerlink" title="总述"></a>总述</h5><p>接口是指满足特定条件的类，这些类以<font color=red><code>Interface</code></font>为后缀（不强制）。</p>
<h5 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h5><p>当一个类满足以下要求时，称之为纯接口：</p>
<ul>
<li>只有纯虚函数（“<font color=red><code>=0</code></font>”）和静态函数（除了析构函数）。</li>
<li>没有非静态数据成员。</li>
<li>没有定义任何构造函数。如果有，也不能带有参数，并且必须为<font color=red><code>protected</code></font>。</li>
<li>如果它是一个子类，也只能从满足上述条件并以<font color=red><code>Interface</code></font>为后缀的类继承。</li>
</ul>
<p>接口类不能直接被实例化，因为它声明了纯虚函数。为确保接口类的所有实现可被正确销毁，必须为之声明析构函数。</p>
<h5 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h5><p>以<font color=red><code>Interface</code></font>为后缀可以提醒其他人不要为该接口类增加杉树实现或非静态数据成员。这一点对于<a href="">多重继承</a>尤其重要。另外。对于Java程序员来说，接口的概念已是深入人心。</p>
<h5 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h5><p><code>Interface</code>后缀增加了类名长度，为阅读和理解带来不便。同时，接口属性作为实现细节不应暴露给用户。</p>
<h5 id="结论-5"><a href="#结论-5" class="headerlink" title="结论"></a>结论</h5><p>只有在满足上述条件时，类才以<font color=red><code>Interface</code></font>结尾，但反过来，满足上述需要类未必一定以<font color=red><code>Interface</code></font>结尾。</p>
<h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><h5 id="总述-7"><a href="#总述-7" class="headerlink" title="总述"></a>总述</h5><p>除少数特定环境外，不要重载运算符。也不要创建用户定义字面量。</p>
<h5 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h5><p>C++允许用户通过使用<font color=red><code>operator</code></font>关键字<a href="">对内建运算符进行重新定义</a>，只要其中一个参数是用户定义的类型。<font color=red><code>operator</code></font>关键字还允许用户使用<font color=red><code>operator&quot;&quot;</code></font>定义新的字面运算符，并且定义类型转换函数，例如<font color=red><code>operator bool()</code></font>。</p>
<h5 id="优点-6"><a href="#优点-6" class="headerlink" title="优点"></a>优点</h5><p>重载运算符可以让代码更简洁易懂，也使得用户定义的类型和内建类型拥有相似的行为。重载运算符对于某些运算来说是符合符合语言习惯的名称(例如<font color=red><code>==</code></font>、<font color=red><code>&lt;</code></font>, <font color=red><code>=</code></font>, <font color=red><code>&lt;&lt;</code></font>)，遵循这些语言约定可以让用户定义的类型更易读，也能更好地和需要这些重载运算符的函数库进行交互操作。</p>
<p>对于创建用户定义的类型的对象来说，用户定义字面量是一种非常简洁的标记。</p>
<h5 id="缺点-6"><a href="#缺点-6" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>要提供正确、一致，不出现异常行为的操作符运算需要花费不少精力，而且如果达不到这些要求的话，会导致令人迷惑的bug。</li>
<li>过度使用运算符会带来难以理解的代码，尤其是在重载的操作符的语义与通常的约定不符合时。</li>
<li>函数重载有多少弊端，运算符重载就至少有多少。</li>
<li>运算符重载会混淆试，让你误以为一些好使的操作和操作内建类型一样轻巧。</li>
<li>对重载运算符的调用点的查找需要的可就不仅仅是像grep那样的程序了，这时需要能够理解C++ 语法的搜索工具。</li>
<li>对重载运算符的参数参数写错，此时得到的可能是一个完全不同的重载而非编译错误。例如：<br><font color=red><code>foo &lt; bar</code></font>执行的是一个行为，而<font color=red><code>&amp;foo &lt; &amp;bar</code></font>执行的就是完全不同的另一个行为了。</li>
<li>重载某些运算符本身就是有害的。例如，重载一元运算符<font color=red><code>&amp;</code></font>会导致同样的代码有完全不同的含义，这取决于重载的声明对某段代码而言是否是可见的。重载诸如<font color=red><code>&amp;&amp;</code></font>, <font color=red><code>||</code></font>和<font color=red><code>，</code></font>会导致运算顺序和内建运算的顺序不一致。</li>
<li>运算符从通常定义在类的外部，所以对于同一运算，可能出现不同的文件引入了不同的定义的风险。如果两种定义都链接到同一二进制文件，就会导致未定义的行为，有可能表现为难以发现的运行时错误。</li>
<li>用户定义字面量所创建的语义形式对于某些有经验的 C++ 程序员来说都是很陌生的。</li>
</ul>
<h5 id="结论-6"><a href="#结论-6" class="headerlink" title="结论"></a>结论</h5><p>只有在意义明显，不会出现奇怪的行为并且与对应的内建运算符的行为一致时才定义重载运算符。例如，<font color=red><code>|</code></font>要作为位或或逻辑或来使用，而不是作为shell中的管道。</p>
<p>只有对用户自己定义的类型重载运算符。更准确地说，将它们和它们所操作的类型定义在同一个头文件中，<font color=red><code>.cc</code></font>中和命名空间中。这样做无论类型在哪里都能够使用定义的运算符，并且最大程度上避免了多重定义的风险。如果可能的话，请避免将运算符定义为模板，因为此时它们必须对任何模板参数都能够作用。如果你定义了一个运算符，请将其相关且有意义的运算符都进行定义，并且保证这些定义的语义是一致的。例如，如果你重载了<font color=red><code>&lt;</code></font>，那么请将所有的比较运算符都进行重载，并且保证对于同一组参数，<font color=red><code>&lt;</code></font>和<font color=red><code>&gt;</code></font>不会同时返回<font color=red><code>true</code></font>。</p>
<p>建议不要将不进行修改的二元运算符定义为成员函数。如果一个二元运算符被定义为类成员，这时隐式转换会作用域右侧的参数却不会作用于左侧。这时会出现<font color=red><code>a &lt; b</code></font> 能够通过编译而<font color=red><code>b &lt; a</code></font>不能的情况，这是很让人迷惑的。</p>
<p>不要为了避免重载操作符而走极端。比如说，应当定义 <font color=red><code>==</code></font>, <font color=red><code>=</code></font>, 和<font color=red><code>&lt;&lt;</code></font>而不是<font color=red><code>Equals()</code></font>， <font color=red><code>CopyFrom()</code></font>和<font color=red><code>PrintTo()</code></font>。反过来说，不要只是为了满足函数库需要而去定义运算符重载。比如说，如果你的类型没有自然顺序，而你要将它们存入<font color=red><code>std::set</code></font>中，最好还是定义一个自定义的比较运算符而不是重载 <font color=red><code>&lt;</code></font>。</p>
<p>不要重载<font color=red><code>&amp;&amp;</code></font>, <font color=red><code>||</code></font>，<font color=red><code>,</code></font> 或一元运算符<font color=red><code>&amp;</code></font>。不要重载 <font color=red><code>operator&quot;&quot;</code></font>，也就是说，不要引入用户定义字面量。</p>
<p>类型转换运算符在<a href="">隐式类型转换</a>一节有提及。<font color=red><code>=</code></font>运算符在<a href="">可拷贝类型和可移动类型</a>一节有提及。 运算符<font color=red><code>&lt;&lt;</code></font>在<a href="">流</a>一节有提及。同时请参见<a href="">函数重载</a>一节，其中提到的的规则对运算符重载同样适用。</p>
<h4 id="存取控制"><a href="#存取控制" class="headerlink" title="存取控制"></a>存取控制</h4><h5 id="总述-8"><a href="#总述-8" class="headerlink" title="总述"></a>总述</h5><p>将<em>所有</em>数据成员声明为<font color=red><code>private</code></font>，除非是<font color=red><code>static const</code></font>类型成员（遵循<a href="">常量命名规则</a>）。处于技术上的原因，在使用<a target="_blank" rel="noopener" href="https://github.com/google/googletest">Google Test</a>时我们允许测试固件类中的数据成员为<font color=red><code>protected</code></font>。</p>
<h4 id="声明顺序"><a href="#声明顺序" class="headerlink" title="声明顺序"></a>声明顺序</h4><p>将相似的声明放在一起，将<font color=red><code>public</code></font>部分放在最前。</p>
<h5 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h5><p>类定义一般应在<font color=red><code>public：</code></font>开始，后跟<font color=red><code>protected：</code></font>，最后是<font color=red><code>private：</code></font>。省略空部分。</p>
<p>在各个部分中，建议将类似的声明放在一起，并且建议以如下顺序：类型（包括<font color=red><code>typedef</code></font>、<font color=red><code>using</code></font>和嵌套的结构体与类），常量，工厂函数、构造函数、赋值运算符、析构函数、其他函数，数据成员。</p>
<p>不要将大段的函数定义内联在类定义中。通常，只有那些普通的，或性能关键且短小的函数可以内联在类定义中。参考<a href="">内联函数</a>一节。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="参数顺序"><a href="#参数顺序" class="headerlink" title="参数顺序"></a>参数顺序</h4><h5 id="总述-9"><a href="#总述-9" class="headerlink" title="总述"></a>总述</h5><p>函数的参数顺序为：输入参数在先，后跟输出参数。</p>
<h5 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h5><p>C/C++中的函数参数或者函数的输入，或者是函数的输出，或兼而有之。输入参数通常是值参或<font color=red><code>const</code></font>引用，输出参数或者输入/输出参数则一般为非<font color=red><code>const</code></font>指针。在排列参数顺序时，将所有的输入参数置于输出参数之前。特别注意，在加入新参数时不要因它们是新参数就置于参数列表最后，是仍要按照前述的规则，即将新的输入参数也置于输出参数之前。</p>
<p>这并非一个硬性规定。输入/输出参数（通常是类或结构体）让这个问题变得复杂，并且，有时候为了其他函数保持一致，你可能不得不有所变通。</p>
<h4 id="编写简短函数"><a href="#编写简短函数" class="headerlink" title="编写简短函数"></a>编写简短函数</h4><h5 id="总述-10"><a href="#总述-10" class="headerlink" title="总述"></a>总述</h5><p>我们倾向于编写简短、凝练的函数。</p>
<h5 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h5><p>我们承认长函数有时是合理的，因此并不硬性限制函数的长度。如果函数超过40行，可以思索一下能不能在不影响程序结构的前提下对其进行分割。</p>
<p>即使一个长函数现在工作的非常好，一旦有人对其修改，有可能出现新的问题，甚至导致难以发现的 bug。使函数尽量简短，以便于他人阅读和修改代码。</p>
<p>在处理代码时，你可能会发现复杂的长函数。不要害怕修改现有代码：如果证实这些代码使用/调试起来很困难，或者你只需要使用其中的一小段代码，考虑将其分割为更加简短并易于管理的若干函数。</p>
<h4 id="引用参数"><a href="#引用参数" class="headerlink" title="引用参数"></a>引用参数</h4><h5 id="总述-11"><a href="#总述-11" class="headerlink" title="总述"></a>总述</h5><p>所有按引用传递的参数必须加上<font color=red><code>const</code></font>。</p>
<h5 id="定义-8"><a href="#定义-8" class="headerlink" title="定义"></a>定义</h5><p>在C语言中，如果函数需要修改变量的值，参数必须为指针，如<font color=red><code>int foo(int *pval)</code></font>。在C++中，函数还可以声明为引用参数：<font color=red><code>int foo(Interface &amp;val)</code></font>。</p>
<h5 id="优点-7"><a href="#优点-7" class="headerlink" title="优点"></a>优点</h5><p>定义引用参数可以防止出现<font color=red><code>(*pval)++</code></font>这样丑陋的代码。引用参数对于拷贝构造函数这样的应用也是需要的。同时也更明确地不接受空指针。</p>
<h5 id="缺点-7"><a href="#缺点-7" class="headerlink" title="缺点"></a>缺点</h5><p>容易引起误解，因为引用在语法上是值变量却拥有指针的语义。</p>
<h5 id="结论-7"><a href="#结论-7" class="headerlink" title="结论"></a>结论</h5><p>函数参数列表中，所有引用参数都必须是<font color=red><code>const</code></font>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;in, <span class="built_in">string</span> *out)</span></span>;</span><br></pre></td></tr></table></figure>
<p>事实上这在Google Code是一个硬性约定：输入参数是值参或<font color=red><code>const</code></font>引用，输出参数为指针。输入参数可以是<font color=red><code>const</code></font>指针，但绝不能是非<font color=red><code>const</code></font>的引用参数，除非特殊要求，比如<font color=red><code>swap</code></font>。</p>
<p>有时候，在输入形参中用<font color=red><code>const T*</code></font>指针比<font color=red><code>const T&amp;</code></font>更明智。比如：</p>
<ul>
<li>可能会传递空指针。</li>
<li>函数要把指针或地址的引用赋值给输入形参。</li>
</ul>
<p>总而言之，大多时候输入形参往往是<font color=red><code>const T&amp;</code></font>。若用<font color=red><code>const T*</code></font>则说明输入另有处理。所以若要使用<font color=red><code>const T*</code></font>，则应给出相应的理由，否则会使得读者感到迷惑。</p>
<h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><h5 id="总述-12"><a href="#总述-12" class="headerlink" title="总述"></a>总述</h5><p>若要使用函数重载，则必须能让读一看调用点就胸有成竹，而不用花心思猜测调用的重载函数到底是哪一种，这样一规则也适用于构造函数。</p>
<h5 id="定义-9"><a href="#定义-9" class="headerlink" title="定义"></a>定义</h5><p>你可以编写一个参数类型为<font color=red><code>const string&amp;</code></font>的函数，然后用另一个参数类型为<font color=red><code>const char*</code></font>的函数对齐进行重载：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Analyze</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;text)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Analyze</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* text, <span class="keyword">size_t</span> textlen)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="优点-8"><a href="#优点-8" class="headerlink" title="优点"></a>优点</h5><p>通过重载参数不同的同名参数，可以令代码更加直观，模版化代码需要重载，这同时也能为使用这带来便利。</p>
<h5 id="缺点-8"><a href="#缺点-8" class="headerlink" title="缺点"></a>缺点</h5><p>如果函数单靠不同的参数类型而重载，读者就得十分熟悉C++五花八门的匹配规则，以了解匹配过程具体到底如何。另外，如果派生类只重载了某个函数的部分变体，继承语义的容易令人困惑。</p>
<h5 id="结论-8"><a href="#结论-8" class="headerlink" title="结论"></a>结论</h5><p>如果打算重载一个函数，可以试试改在函数名里加上参数信息。例如，用<font color=red><code>AppendString()</code></font>和<font color=red><code>AppendInt</code></font>等, 而不是一口气重载多个<font color=red><code>Append()</code></font>。如果重载函数的目的是为了支持不同数量的同一类型参数，则优先考虑使用<font color=red><code>std::vector</code></font>以便使用者可以用<a href="">列表初始化</a>指定参数。</p>
<h4 id="缺省参数"><a href="#缺省参数" class="headerlink" title="缺省参数"></a>缺省参数</h4><h5 id="总述-13"><a href="#总述-13" class="headerlink" title="总述"></a>总述</h5><p>只允许在非虚函数中使用缺省参数，且必须保证缺省参数的值始终一致。缺省参数与<a href="">函数重载</a>遵循同样的规则。一般情况下建议使用函数重载，尤其是在缺省函数带来的可读性提升不能弥补下文中所提到的缺点的情况下。</p>
<h5 id="优点-9"><a href="#优点-9" class="headerlink" title="优点"></a>优点</h5><p>有些函数一般情况下使用默认参数，但有时需要又使用非默认的参数。缺省参数为这样的情形提供了便利，使程序员不需要为了极少的例外情况编写大量的函数。和函数重载相比，缺省参数的语法更简洁明了，减少了大量的样板代码，也更好地区别了“必要参数”和“可选参数”。</p>
<h5 id="缺点-9"><a href="#缺点-9" class="headerlink" title="缺点"></a>缺点</h5><p>缺省参数实际上是函数重载语义的另一种实现方式，因此所有<a href="">不应当使用函数重载的理由</a>也都适用于缺省参数。</p>
<p>虚函数调用的缺省参数取决于目标对象的静态类型，此时无法保证给定函数的所有重载声明的都是同样的缺省参数。</p>
<p>缺省参数是在每个调用点都要进行重新求值的，这会造成生成的代码迅速膨胀。作为读者，一般来说也更希望缺省的参数在声明时就已经被固定了，而不是在每次调用时都可能会有不同的取值。</p>
<p>缺省参数会干扰函数指针，导致函数签名与调用点的签名不一致。而函数重载不会导致这样的问题。</p>
<h5 id="结论-9"><a href="#结论-9" class="headerlink" title="结论"></a>结论</h5><p>对于虚函数，不允许使用缺省参数，因为在虚函数中缺省参数不一定能正常工作。如果在每个调用点缺省参数的值都有可能不同，在这种情况下缺省函数也不允许使用。(例如，不要写像<font color=red>void f(int n = counter++);</font>这样的代码。)</p>
<p>在其他情况下，如果缺省参数对可读性的提升远远超过了以上提及的缺点的话，可以使用缺省参数。 如果仍有疑惑，就使用函数重载。</p>
<h4 id="函数返回类型后置语法"><a href="#函数返回类型后置语法" class="headerlink" title="函数返回类型后置语法"></a>函数返回类型后置语法</h4><h5 id="总述-14"><a href="#总述-14" class="headerlink" title="总述"></a>总述</h5><p>只有在常规写法 (返回类型前置) 不便于书写或不便于阅读时使用返回类型后置语法。</p>
<h5 id="定义-10"><a href="#定义-10" class="headerlink" title="定义"></a>定义</h5><p>C++现在允许两种不同的函数声明方式。以往的写法是将返回类型置于函数名之前。例如:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<p>C++11引入了这一新的形式. 现在可以在函数名前使用<font color=red><code>auto</code></font>关键字, 在参数列表之后后置返回类型. 例如:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto foo(int x) -&gt; int;</span><br></pre></td></tr></table></figure>
<p>后置返回类型为函数作用域。对于像<font color=red><code>int</code></font>这样简单的类型，两种写法没有区别。但对于复杂的情况，例如类域中的类型声明或者以函数参数的形式书写的类型，写法的不同会造成区别。</p>
<h5 id="优点-10"><a href="#优点-10" class="headerlink" title="优点"></a>优点</h5><p>后置返回类型是显式地指定<a href="">Lambda表达式</a>的返回值的唯一方式。某些情况下，编译器可以自动推导出Lambda表达式的返回类型，但并不是在所有的情况下都能实现。即使编译器能够自动推导，显式地指定返回类型也能让读者更明了。</p>
<p>有时在已经出现了的函数参数列表之后指定返回类型，能够让书写更简单，也更易读，尤其是在返回类型依赖于模板参数时。例如:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T, class U&gt; auto add(T t, U u) -&gt; decltype(t + u);</span><br></pre></td></tr></table></figure>
<p>对比下面的例子:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">U</span>&gt;</span> <span class="keyword">decltype</span>(declval&lt;T&amp;&gt;() + declval&lt;U&amp;&gt;()) add(T t, U u);</span><br></pre></td></tr></table></figure>
<h5 id="缺点-10"><a href="#缺点-10" class="headerlink" title="缺点"></a>缺点</h5><p>后置返回类型相对来说是非常新的语法，而且在C和Java中都没有相似的写法，因此可能对读者来说比较陌生。</p>
<p>在已有的代码中有大量的函数声明，你不可能把它们都用新的语法重写一遍。因此实际的做法只能是使用旧的语法或者新旧混用。在这种情况下，只使用一种版本是相对来说更规整的形式。</p>
<h5 id="结论-10"><a href="#结论-10" class="headerlink" title="结论"></a>结论</h5><p>在大部分情况下，应当继续使用以往的函数声明写法，即将返回类型置于函数名前。只有在必需的时候(如Lambda表达式)或者使用后置语法能够简化书写并且提高易读性的时候才使用新的返回类型后置语法。但是后一种情况一般来说是很少见的，大部分时候都出现在相当复杂的模板代码中，而多数情况下不鼓励写这样<a href="">复杂的模板代码</a>。</p>
<h3 id="其他C-特性"><a href="#其他C-特性" class="headerlink" title="其他C++特性"></a>其他C++特性</h3><h3 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h3><p>最重要的一致性规则是命名管理。命名的风格能让我们在不需要去查找类型声明的条件下快速地了解某个名字代表的含义：类型、变量、函数、常量、宏等等，甚至，我们大脑中的模式匹配引擎非常依赖这些命名规则。</p>
<p>命名规则具有一定随意性。但相比按个人喜好命名，一致性更重要，所以无论你认为它们是否重要，规则总是规则。</p>
<h4 id="通用命名规则"><a href="#通用命名规则" class="headerlink" title="通用命名规则"></a>通用命名规则</h4><h5 id="总述-15"><a href="#总述-15" class="headerlink" title="总述"></a>总述</h5><p>函数命名、变量命名，文件命名要有描述性；少用缩写。</p>
<h5 id="说明-4"><a href="#说明-4" class="headerlink" title="说明"></a>说明</h5><p>尽可能使用描述性的命名，别心疼空间，毕竟相比之下代码易于新读者理解更重要。不要用只有项目开发者能理解的缩写，也不要通过砍掉一个字母来缩写单词。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> price_count_reader;    <span class="comment">// 无缩写</span></span><br><span class="line"><span class="keyword">int</span> num_errors;            <span class="comment">// &quot;num&quot; 是一个常见的写法</span></span><br><span class="line"><span class="keyword">int</span> num_dns_connections;   <span class="comment">// 人人都知道 &quot;DNS&quot; 是什么</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;                     <span class="comment">// 毫无意义.</span></span><br><span class="line"><span class="keyword">int</span> nerr;                  <span class="comment">// 含糊不清的缩写.</span></span><br><span class="line"><span class="keyword">int</span> n_comp_conns;          <span class="comment">// 含糊不清的缩写.</span></span><br><span class="line"><span class="keyword">int</span> wgc_connections;       <span class="comment">// 只有贵团队知道是什么意思.</span></span><br><span class="line"><span class="keyword">int</span> pc_reader;             <span class="comment">// &quot;pc&quot; 有太多可能的解释了.</span></span><br><span class="line"><span class="keyword">int</span> cstmr_id;              <span class="comment">// 删减了若干字母.</span></span><br></pre></td></tr></table></figure>
<p>注意，一些特定的广为人知的缩写是允许的，例如用<font color=red><code>i</code></font>和用<font color=red><code>T</code></font>表示模版参数。</p>
<p>模板参数的命名应当遵循对应的分类：类型模板参数应当遵循<a href="">类型命名</a>的规则，而非类型模板应当遵循<a href="">变量命名</a>的规则。</p>
<h4 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h4><h5 id="总述-16"><a href="#总述-16" class="headerlink" title="总述"></a>总述</h5><p>文件名要全部小写，可以包含下划线（<font color=red><code>_</code></font>）和连字符（<font color=red><code>-</code></font>），依照项目约定，如果没有约定，那么“<font color=red><code>_</code></font>”更好。</p>
<h5 id="说明-5"><a href="#说明-5" class="headerlink" title="说明"></a>说明</h5><p>可接受的文件命名实例：</p>
<ul>
<li><font color=red><code>my_userful_class.cc</code></font></li>
<li><font color=red><code>my-userful-class.cc</code></font></li>
<li><font color=red><code>myuserfulclass.cc</code></font></li>
<li><font color=red><code>myuserfulclass_test.cc</code></font> // <font color=red><code>_unittest.cc</code></font> 和<font color=red><code>_regtest.cc</code></font>以弃用。</li>
</ul>
<p>C++文件要以<font color=red><code>.cc</code></font>结尾，头文件以<font color=red><code>.h</code></font>结尾。专门插入文本的文件则以<font color=red><code>.inc</code></font> 结尾，参见<a href="">头文件自足</a>。</p>
<p>不要使用已经存在于<font color=red><code>/usr/include</code></font>下的文件名。如：<font color=red><code>db.h</code></font></p>
<p>通常应尽量让文件名更加明确。<font color=red><code>http_servr.h</code></font>就比<font color=red><code>logs.h</code></font>要好。定义类时文件名一般成对出现，如：<font color=red><code>foo_bar.h</code></font>和<font color=red><code>foo_bar.cc</code></font>，对应于类<br><code>FooBar</code>。</p>
<p>内联函数必须放在<font color=red><code>.h</code></font>文件中，如果内联函数比较短，就直接放在<font color=red><code>.h</code></font>。</p>
<h4 id="类型命名"><a href="#类型命名" class="headerlink" title="类型命名"></a>类型命名</h4><h5 id="总述-17"><a href="#总述-17" class="headerlink" title="总述"></a>总述</h5><p>类型名称的每个单词首字母均大写，不包好下划线：<font color=red><code>MyExcitingClass</code></font>，<font color=red><code>MyExcitingEnum</code></font>。</p>
<h5 id="说明-6"><a href="#说明-6" class="headerlink" title="说明"></a>说明</h5><p>所有类型命名——类、结构体、类型定义（<font color=red><code>typedef</code></font>）、枚举、类型模板参数——均使用相同约定，即以大写字母开始，每个单词首字母均大写，不包含下划线。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类和结构体</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UrlTable</span> &#123;</span> ...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UrlTableTester</span> &#123;</span> ...</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UrlTableProperties</span> &#123;</span> ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型定义</span></span><br><span class="line"><span class="keyword">typedef</span> hash_map&lt;UrlTableProperties *, <span class="built_in">string</span>&gt; PropertiesMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// using 别名</span></span><br><span class="line"><span class="keyword">using</span> PropertiesMap = hash_map&lt;UrlTableProperties *, <span class="built_in">string</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UrlTableErrors</span> &#123;</span> ...</span><br></pre></td></tr></table></figure>
<h4 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h4><h5 id="总述-18"><a href="#总述-18" class="headerlink" title="总述"></a>总述</h5><p>变量（包含函数参数）和数据成员名一律小写，单词之间用下划线连接。类的成员变量以下划线结尾，但结构体就不用。比如：<font color=red><code>a_local_variable</code></font>，<font color=red><code>a_struct_data_member</code></font>，<font color=red><code>a_class_data_member</code></font>。</p>
<h5 id="说明-7"><a href="#说明-7" class="headerlink" title="说明"></a>说明</h5><p><strong>普通变量命名</strong><br>举例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> table_name;  <span class="comment">// 好 - 用下划线.</span></span><br><span class="line"><span class="built_in">string</span> tablename;   <span class="comment">// 好 - 全小写.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> tableName;  <span class="comment">// 差 - 混合大小写</span></span><br></pre></td></tr></table></figure>
<p><strong>类数据成员</strong><br>不管是静态的还是非静态的，类数据成员都可以和普通变量一样，但要接下划线。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableInfo</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">string</span> table_name_;  <span class="comment">// 好 - 后加下划线.</span></span><br><span class="line">  <span class="built_in">string</span> tablename_;   <span class="comment">// 好.</span></span><br><span class="line">  <span class="keyword">static</span> Pool&lt;TableInfo&gt;* pool_;  <span class="comment">// 好.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>结构体变量</strong><br>不管是静态的还是非静态的，结构体数据成员都可以和普通变量一样，不要像类那样接下划线。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UrlTableProperties</span> &#123;</span></span><br><span class="line">  <span class="built_in">string</span> name;</span><br><span class="line">  <span class="keyword">int</span> num_entries;</span><br><span class="line">  <span class="keyword">static</span> Pool&lt;UrlTableProperties&gt;* pool;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结构体与类的使用讨论，参考<a href="">结构体和类</a>。</p>
<h4 id="常量命名"><a href="#常量命名" class="headerlink" title="常量命名"></a>常量命名</h4><h5 id="总述-19"><a href="#总述-19" class="headerlink" title="总述"></a>总述</h5><p>声明为<font color=red><code>constexpr</code></font>或<font color=red><code>const</code></font>的变量，或在程序运行期间其值始终保持不变的，命名时以“K”开头，大小写混合。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kDaysInAWeek = <span class="number">7</span>;</span><br></pre></td></tr></table></figure>
<h5 id="说明-8"><a href="#说明-8" class="headerlink" title="说明"></a>说明</h5><p>所有具有静态存储类型的变量(例如静态变量或全局变量，参见<a href="">存储类型</a>) 都应当以此方式命名。对于其他存储类型的变量，如自动变量等，这条规则是可选的。如果不采用这条规则，就按照一般的变量命名规则。</p>
<h4 id="函数命名"><a href="#函数命名" class="headerlink" title="函数命名"></a>函数命名</h4><h5 id="总述-20"><a href="#总述-20" class="headerlink" title="总述"></a>总述</h5><p>常规函数使用大小写混合，取值和设值函数则要求与变量名匹配:<font color=red><code>MyExcitingFunction()</code></font>，<font color=red><code>MyExcitingMethod()</code></font>， <font color=red><code>my_exciting_member_variable()</code></font>， <font color=red><code>set_my_exciting_member_variable()</code></font>。</p>
<h5 id="说明-9"><a href="#说明-9" class="headerlink" title="说明"></a>说明</h5><p>一般来说，函数名的每个单词首字母大写(即“驼峰变量名”或“帕斯卡变量名”)，没有下划线。对于首字母缩写的单词，更倾向于将它们视作一个单词进行首字母大写（例如，写作<font color=red><code>StartRpc()</code></font>而非<font color=red><code>StartRPC()</code></font>）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AddTableEntry()</span><br><span class="line">DeleteUrl()</span><br><span class="line">OpenFileOrDie()</span><br></pre></td></tr></table></figure>
<p>(同样的命名规则同时适用于类作用域与命名空间作用域的常量，因为它们是作为API的一部分暴露对外的，因此应当让它们看起来像是一个函数，因为在这时，它们实际上是一个对象而非函数的这一事实对外不过是一个无关紧要的实现细节。)</p>
<p>取值和设值函数的命名与变量一致。一般来说它们的名称与实际的成员变量对应，但并不强制要求.。例如<font color=red><code>sint count()</code></font>与<font color=red><code>void set_count(int count)</code></font>。</p>
<h4 id="命名空间命名"><a href="#命名空间命名" class="headerlink" title="命名空间命名"></a>命名空间命名</h4><h5 id="总述-21"><a href="#总述-21" class="headerlink" title="总述"></a>总述</h5><p>命名空间以小写字母命名。最高级命名空间的名字取决于项目名称。要注意避免嵌套命名空间的名字之间和行间的顶级命名空间的名字之间发生的冲突。</p>
<p>顶级命名空间的名称应当是项目名称或是该命名空间中的代码所属的团队的名字。命名空间中的代码，应该存放于和命名空间的名字匹配的文件夹或其子文件夹中。</p>
<p>注意<a href="">不使用缩写作为名称</a>的规则同样适用于命名空间。命名空间中的代码极少需要设计命名空间的名称，因为没有必要在命名空间中使用缩写。</p>
<p>要避免嵌套的命名空间与常见的顶级命名空间发生名称冲突。由于名称查找规则的存在，命名空间之间的冲突完全有可能导致编译失败。尤其是，不要创建嵌套的<font color=red><code>std</code></font>m命名空间。建议使用更独特的项目标识符（<font color=red><code>websearch::index</code></font>、<font color=red><code>websearch::index_util</code></font>），而非常见的极易发生冲突的名名称（比如：<font color=red><code>websearch::util</code></font>）。</p>
<p>对于<font color=red><code>internal</code></font>命名空间，要当心加入到同一<font color=red><code>internal</code></font>命名空间的代码之间发生冲突（由于内部维护人员通常来自于同一个团队，因此常有可能导致冲突）。在这样的情况下，请使用文件名以使得内部名称独一无二（例如对于<font color=red><code>frobber.h</code></font>，使用<font color=red><code>websearch::index::frobber_internal</code></font>）。</p>
<h4 id="枚举命名"><a href="#枚举命名" class="headerlink" title="枚举命名"></a>枚举命名</h4><h5 id="总述-22"><a href="#总述-22" class="headerlink" title="总述"></a>总述</h5><p>枚举的命名应当和<a href="">常量</a>或<a href="">宏</a>一致：<font color=red><code>kEnumName</code></font>或是<font color=red><code>ENUM_NAME</code></font>。</p>
<h5 id="说明-10"><a href="#说明-10" class="headerlink" title="说明"></a>说明</h5><p>单独的枚举值应该优先采用<a href="">常量</a>的命名方式。但<a href="">宏</a>方式的命名也可以接受，枚举名<font color=red><code>UrlTableErrors</code></font>（以及<font color=red><code>AlternateUrlTableErrors</code></font>）是类型，所以要用大小写混合的方式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UrlTableErrors</span> &#123;</span></span><br><span class="line">    kOK = <span class="number">0</span>,</span><br><span class="line">    kErrorOutOfMemory,</span><br><span class="line">    kErrorMalformedInput,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">AlternateUrlTableErrors</span> &#123;</span></span><br><span class="line">    OK = <span class="number">0</span>,</span><br><span class="line">    OUT_OF_MEMORY = <span class="number">1</span>,</span><br><span class="line">    MALFORMED_INPUT = <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>2009年1月之前，我们一直建议采用<a href="">宏</a>的方式命名枚举值。由于枚举值和宏之间的命名冲突，直接导致了很多问题。由此，这里改为优先选择常量风格的命名方式。新代码应该尽可能优先使用常量风格。但是老代码没必要切换到常量风格，除非宏风格确实会产生编译期问题。</p>
<h4 id="宏命名"><a href="#宏命名" class="headerlink" title="宏命名"></a>宏命名</h4><h5 id="总述-23"><a href="#总述-23" class="headerlink" title="总述"></a>总述</h5><p>你并不打算[使用宏]，对吧？如果你一定要用，就像这样命名：<font color=red><code>MY_MACRO_THAT_SCARES_SMALL_CHILDREN</code></font>。</p>
<h5 id="说明-11"><a href="#说明-11" class="headerlink" title="说明"></a>说明</h5><p>参考<a href="">预处理宏</a>；通常，<em>不应该</em>使用宏，如果不得不用，其命名像枚举命名一样全部大写，使用下划线：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROUND(x) ...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI_ROUNDED 3.0</span></span><br></pre></td></tr></table></figure>
<h4 id="命名规则特例"><a href="#命名规则特例" class="headerlink" title="命名规则特例"></a>命名规则特例</h4><h5 id="总述-24"><a href="#总述-24" class="headerlink" title="总述"></a>总述</h5><p>如果你命名的实体与已有C/C++实体相似，可参考现有命名策略。<br><font color=red><code>bigopen()</code></font>:函数名，参照<font color=red><code>open()</code></font>的形式。<br><font color=red><code>uint</code></font>：<font color=red><code>typedef</code></font><br><font color=red><code>bigpos</code></font>：<font color=red><code>struct</code></font>或<font color=red><code>class</code></font>，参照<font color=red><code>pos</code></font>的形式。<br><font color=red><code>sparse_hash_map</code></font>：STL型实体；参照STL命名约定。<br><font color=red><code>UrlTableErrors</code></font>常量，如同<font color=red><code>INT_MAX</code></font></p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>注释虽然写起来很痛苦，但对保证代码可读性至关重要。下面的规则描述了如何注释以及在哪儿注释。当然也要记住：注释固然很重要，但最好的代码应当本身就是文档。有意义的类型名和变量名，要远胜过要用注释解释的含糊不清的名字。</p>
<p>你写的注释是给代码读者看的，也就是下一个需要理解你的代码的人。所以慷慨些吧，下一个读者可能就是你!</p>
<h4 id="注释风格"><a href="#注释风格" class="headerlink" title="注释风格"></a>注释风格</h4><h5 id="总述-25"><a href="#总述-25" class="headerlink" title="总述"></a>总述</h5><p>使用<font color=red><code>//</code></font>或<font color=red><code>/* */</code></font>，统一就好。</p>
<h5 id="说明-12"><a href="#说明-12" class="headerlink" title="说明"></a>说明</h5><p>虽然<font color=red><code>//</code></font>或<font color=red><code>/* */</code></font>都可以，但<font color=red><code>//</code></font>更常用。更在如何注释以及注释风格上确保统一。</p>
<h4 id="文件注释"><a href="#文件注释" class="headerlink" title="文件注释"></a>文件注释</h4><h5 id="总述-26"><a href="#总述-26" class="headerlink" title="总述"></a>总述</h5><p>在每一个文件开头加入版权公告。</p>
<p>文件注释描述了该文件的内容。如果一个文件只声明，或实现，或测试了一个对象，并且这个对象已经在它的声明处进行了详细的注释，那么就没必要再加上文件注释。除此之外的其他文件都需要文件注释。</p>
<h5 id="说明-13"><a href="#说明-13" class="headerlink" title="说明"></a>说明</h5><p><font size=5><strong>法律公告和作者信息</strong></font></p>
<p>每个文件都应该包含许可证引用。为项目选择合适的许可证版本。(比如，Apache 2.0、BSD、LGPL,、GPL)。</p>
<p>如果你对原始作者的文件做了重大修改。请考虑删除原作者信息。</p>
<p><font size=5><strong>文件内容</strong></font></p>
<p>如果一个<font color=red><code>.h</code></font>文件声明了多个概念，则文件注释应当对文件的内容做一个大致的说明，同时说明各概念之间的联系。一个一到两行的文件注释就足够了，对于每个概念的详细文档应当放在各个概念中，而不是文件注释中。</p>
<p>不要在<font color=red><code>.h</code></font>和<font color=red><code>.cc</code></font>之间复制注释，这样的注释偏离了注释的实际意义.</p>
<h4 id="类注释"><a href="#类注释" class="headerlink" title="类注释"></a>类注释</h4><h5 id="总述-27"><a href="#总述-27" class="headerlink" title="总述"></a>总述</h5><p>每个类的定义都要附带一份注释，描述类的功能和用法，除非它的功能相当明显。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Iterates over the contents of a GargantuanTable.</span></span><br><span class="line"><span class="comment">// Example:</span></span><br><span class="line"><span class="comment">//    GargantuanTableIterator* iter = table-&gt;NewIterator();</span></span><br><span class="line"><span class="comment">//    for (iter-&gt;Seek(&quot;foo&quot;); !iter-&gt;done(); iter-&gt;Next()) &#123;</span></span><br><span class="line"><span class="comment">//      process(iter-&gt;key(), iter-&gt;value());</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    delete iter;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GargantuanTableIterator</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="说明-14"><a href="#说明-14" class="headerlink" title="说明"></a>说明</h5><p>类注释应当为读者理解如何使用与何时使用类提供足够的信息，同时应当提醒读者在正确使用此类时应当考虑的因素。如果类有任何同步前提，请用文档说明。如果该类的实例可被多线程访问，要特别注意文档说明多线程环境下相关的规则和常量使用。</p>
<p>如果你想用一小段代码演示这个类的基本用法或通常用法，放在类注释里也非常合适。</p>
<p>如果类的声明和定义分开了(例如分别放在了<font color=red><code>.h</code></font>和<font color=red><code>.cc</code></font>文件中)，此时，描述类用法的注释应当和接口定义放在一起，描述类的操作和实现的注释应当和实现放在一起。</p>
<h4 id="函数注释"><a href="#函数注释" class="headerlink" title="函数注释"></a>函数注释</h4><h5 id="总述-28"><a href="#总述-28" class="headerlink" title="总述"></a>总述</h5><p>函数声明处的注释描述函数功能；定义处的注释描述函数实现。</p>
<h5 id="说明-15"><a href="#说明-15" class="headerlink" title="说明"></a>说明</h5><p><font size=5>函数声明</font></p>
<p>基本上每个函数声明处前都应当加上注释，描述函数的功能和用途。只有在函数的功能简单而明显时才能省略这些注释(例如，简单的取值和设值函数)。注释使用叙述式(“Opens the file”)而非指令式 (“Open the file”)；注释只是为了描述函数，而不是命令函数做什么。通常，注释不会描述函数如何工作。那是函数定义部分的事情。</p>
<p>函数声明处注释的内容：</p>
<ul>
<li>函数的输入输出。</li>
<li>对类成员函数而言：函数调用期间对象是否需要保持引用参数，是否会释放这些参数。</li>
<li>函数是否分配了必须由调用者释放的空间。</li>
<li>参数是否可以为空指针。</li>
<li>是否存在函数使用上的性能隐患。</li>
<li>如果函数是可重入的，其同步前提是什么？</li>
</ul>
<p>举例如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns an iterator for this table.  It is the client&#x27;s</span></span><br><span class="line"><span class="comment">// responsibility to delete the iterator when it is done with it,</span></span><br><span class="line"><span class="comment">// and it must not use the iterator once the GargantuanTable object</span></span><br><span class="line"><span class="comment">// on which the iterator was created has been deleted.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The iterator is initially positioned at the beginning of the table.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This method is equivalent to:</span></span><br><span class="line"><span class="comment">//    Iterator* iter = table-&gt;NewIterator();</span></span><br><span class="line"><span class="comment">//    iter-&gt;Seek(&quot;&quot;);</span></span><br><span class="line"><span class="comment">//    return iter;</span></span><br><span class="line"><span class="comment">// If you are going to immediately seek to another place in the</span></span><br><span class="line"><span class="comment">// returned iterator, it will be faster to use NewIterator()</span></span><br><span class="line"><span class="comment">// and avoid the extra seek.</span></span><br><span class="line"><span class="function">Iterator* <span class="title">GetIterator</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>但也要避免罗罗嗦嗦，或者对显而易见的内容进行说明。下面的注释就没有必要加上“否则返回 false”, 因为已经暗含其中了:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns true if the table cannot hold any more entries.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsTableFull</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>注释函数重载时，注释的重点应该是函数中被重载的部分，而不是简单的重复被重载的函数的注释。多数情况下，函数重载不需要额外的文档，因此也没有必要加上注释。</p>
<p>注释构造/析构函数时，切记读代码的人知道构造/析构函数的功能，所以“销毁这一对象”这样的注释是没有意义的。你应当注明的是注明构造函数对参数做了什么(例如，是否取得指针所有权)以及析构函数清理了什么。如果都是些无关紧要的内容，直接省掉注释。析构函数前没有注释是很正常的。</p>
<p>不要从<font color=red><code>.h</code></font>文件或其他地方的函数声明处直接复制注释。简要重述函数功能是可以的，但注释重点要放在如何实现上。</p>
<h4 id="变量注释"><a href="#变量注释" class="headerlink" title="变量注释"></a>变量注释</h4><h5 id="总述-29"><a href="#总述-29" class="headerlink" title="总述"></a>总述</h5><p>通常变量名本身足以很好说明变量用途。某些情况下，也需要额外的注释说明。</p>
<h5 id="说明-16"><a href="#说明-16" class="headerlink" title="说明"></a>说明</h5><p><font size=5>类数据成员</font></p>
<p>每个类数据成员(也叫实例变量或成员变量)都应该用注释说明用途。如果有非变量的参数(例如特殊值，数据成员之间的关系、生命周期等)不能够用类型与变量名明确表达，则应当加上注释。然而，如果变量类型与变量名已经足以描述一个变量，那么就不再需要加上注释。</p>
<p>特别地，如果变量可以接受<font color=red><code>NULL</code></font>或<font color=red><code>-1</code></font>等警戒值，须加以说明。比如:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="comment">// Used to bounds-check table accesses. -1 means</span></span><br><span class="line"> <span class="comment">// that we don&#x27;t yet know how many entries the table has.</span></span><br><span class="line"> <span class="keyword">int</span> num_total_entries_;</span><br></pre></td></tr></table></figure>
<p><font size=5>全局变量</font></p>
<p>和数据成员一样，所有全局变量也要注释说明含义及用途，以及作为全局变量的原因。比如:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The total number of tests cases that we run through in this regression test.</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kNumTestCases = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>
<h4 id="实现注释"><a href="#实现注释" class="headerlink" title="实现注释"></a>实现注释</h4><h5 id="总述-30"><a href="#总述-30" class="headerlink" title="总述"></a>总述</h5><p>对于代码中巧妙的，晦涩的，有趣的，重要的地方加以注释。</p>
<h5 id="说明-17"><a href="#说明-17" class="headerlink" title="说明"></a>说明</h5><p><font size=5>代码前注释</font></p>
<p>巧妙或复杂的代码段前要加注释。比如:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Divide result by two, taking into account that x</span></span><br><span class="line"><span class="comment">// contains the carry from the add.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result-&gt;size(); i++) &#123;</span><br><span class="line">  x = (x &lt;&lt; <span class="number">8</span>) + (*result)[i];</span><br><span class="line">  (*result)[i] = x &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  x &amp;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font size=5>行注释</font></p>
<p>比较隐晦的地方要在行尾加入注释。在行尾空两格进行注释。比如:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If we have enough memory, mmap the data portion too.</span></span><br><span class="line">mmap_budget = max&lt;int64&gt;(<span class="number">0</span>, mmap_budget - index_-&gt;length());</span><br><span class="line"><span class="keyword">if</span> (mmap_budget &gt;= data_size_ &amp;&amp; !MmapData(mmap_chunk_bytes, mlock))</span><br><span class="line">  <span class="keyword">return</span>;  <span class="comment">// Error already logged.</span></span><br></pre></td></tr></table></figure>
<p>注意，这里用了两段注释分别描述这段代码的作用，和提示函数返回时错误已经被记入日志。</p>
<p>如果你需要连续进行多行注释，可以使之对齐获得更好的可读性：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DoSomething();                  <span class="comment">// Comment here so the comments line up.</span></span><br><span class="line">DoSomethingElseThatIsLonger();  <span class="comment">// Two spaces between the code and the comment.</span></span><br><span class="line">&#123; <span class="comment">// One space before comment when opening a new scope is allowed,</span></span><br><span class="line">  <span class="comment">// thus the comment lines up with the following comments and code.</span></span><br><span class="line">  DoSomethingElse();  <span class="comment">// Two spaces before line comments normally.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="built_in">list</span>&#123;</span><br><span class="line">                    <span class="comment">// Comments in braced lists describe the next element...</span></span><br><span class="line">                    <span class="string">&quot;First item&quot;</span>,</span><br><span class="line">                    <span class="comment">// .. and should be aligned appropriately.</span></span><br><span class="line"><span class="string">&quot;Second item&quot;</span>&#125;;</span><br><span class="line">DoSomething(); <span class="comment">/* For trailing block comments, one space is fine. */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><font size=5>函数参数注释</font></p>
<p>如果函数参数的意义不明显，考虑用下面的方式进行弥补:</p>
<ul>
<li>如果参数是一个字面常量，并且这一常量在多处函数调用中被使用，用以推断它们一致，你应当用一个常量名让这一约定变得更明显，并且保证这一约定不会被打破。</li>
<li>考虑更改函数的签名，让某个<font color=red><code>bool</code></font>类型的参数变为<font color=red><code>enum</code></font>类型，这样可以让这个参数的值表达其意义。</li>
<li>如果某个函数有多个配置选项，你可以考虑定义一个类或结构体以保存所有的选项，并传入类或结构体的实例。这样的方法有许多优点，例如这样的选项可以在调用处用变量名引用，这样就能清晰地表明其意义。同时也减少了函数参数的数量，使得函数调用更易读也易写。除此之外，以这样的方式，如果你使用其他的选项，就无需对调用点进行更改。</li>
<li>用具名变量代替大段而复杂的嵌套表达式。</li>
<li>万不得已时, 才考虑在调用点用注释阐明参数的意义.</li>
</ul>
<p>比如下面的示例的对比:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// What are these arguments?</span></span><br><span class="line"><span class="keyword">const</span> DecimalNumber product = CalculateProduct(values, <span class="number">7</span>, <span class="literal">false</span>, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ProductOptions options;</span><br><span class="line">options.set_precision_decimals(<span class="number">7</span>);</span><br><span class="line">options.set_use_cache(ProductOptions::kDontUseCache);</span><br><span class="line"><span class="keyword">const</span> DecimalNumber product =</span><br><span class="line">    CalculateProduct(values, options, <span class="comment">/*completion_callback=*/</span><span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure>
<p>哪个更清晰一目了然。</p>
<p><font size=5>不允许的行为</font></p>
<p>不要描述显而易见的现象，<em>永远不要</em>用自然语言翻译代码作为注释，除非即使对深入理解C++的读者来说代码的行为都是不明显的。要假设读代码的人C++水平比你高，即便他/她可能不知道你的用意:</p>
<p>你所提供的注释应当解释代码<em>为什么</em>要这么做和代码的目的，或者最好是让代码自文档化。</p>
<p>比较这样的注释:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find the element in the vector.  &lt;-- 差: 这太明显了!</span></span><br><span class="line"><span class="keyword">auto</span> iter = <span class="built_in">std</span>::find(v.begin(), v.end(), element);</span><br><span class="line"><span class="keyword">if</span> (iter != v.end()) &#123;</span><br><span class="line">  Process(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和这样的注释：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Process &quot;element&quot; unless it was already processed.</span></span><br><span class="line"><span class="keyword">auto</span> iter = <span class="built_in">std</span>::find(v.begin(), v.end(), element);</span><br><span class="line"><span class="keyword">if</span> (iter != v.end()) &#123;</span><br><span class="line">  Process(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自文档化的代码根本就不需要注释。上面例子中的注释对下面的代码来说就是毫无必要的:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!IsAlreadyProcessed(element)) &#123;</span><br><span class="line">  Process(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="标点、拼写和语法"><a href="#标点、拼写和语法" class="headerlink" title="标点、拼写和语法"></a>标点、拼写和语法</h4><h5 id="总述-31"><a href="#总述-31" class="headerlink" title="总述"></a>总述</h5><p>注意标点，拼写和语法；写的好的注释比差的要易读的多。</p>
<h5 id="说明-18"><a href="#说明-18" class="headerlink" title="说明"></a>说明</h5><p>注释的通常写法是包含正确大小写和结尾句号的完整叙述性语句。大多数情况下，完整的句子比句子片段可读性更高。短一点的注释，比如代码行尾注释，可以随意点。但依然要注意风格的一致性.</p>
<p>虽然被别人指出该用分号时却用了逗号多少有些尴尬，但清晰易读的代码还是很重要的。正确的标点、拼写和语法对此会有很大帮助。</p>
<h4 id="TODO注释"><a href="#TODO注释" class="headerlink" title="TODO注释"></a>TODO注释</h4><h5 id="总述-32"><a href="#总述-32" class="headerlink" title="总述"></a>总述</h5><p>对那些临时的、短期的解决方案，或已经够好但仍不完美的代码使用<font color=red><code>TODO</code></font>注释。</p>
<h5 id="说明-19"><a href="#说明-19" class="headerlink" title="说明"></a>说明</h5><p><font color=red><code>TODO</code></font>注释要使用全大写的字符串<font color=red><code>TODO</code></font>，在随后的圆括号里写上你的名字、邮件地址、bug ID或其它身份标识和与这一<font color=red><code>TODO</code></font>相关的issue。主要目的是让添加注释的人(也是可以请求提供更多细节的人)可根据规范的<font color=red><code>TODO</code></font>格式进行查找。添加<font color=red><code>TODO</code></font>注释并不意味着你要自己来修正，因此当你加上带有姓名的<font color=red><code>TODO</code></font>时，一般都是写上自己的名字。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO(kl@gmail.com): Use a &quot;*&quot; here for concatenation operator.</span></span><br><span class="line"><span class="comment">// TODO(Zeke) change this to use relations.</span></span><br><span class="line"><span class="comment">// TODO(bug 12345): remove the &quot;Last visitors&quot; feature</span></span><br></pre></td></tr></table></figure>
<p>如果加<font color=red><code>TODO</code></font>为了在“将来某一天做某事”，可以附上一个非常明确的时间 “Fix by November 2005”)，或者一个明确的事项(“Remove this code when all clients can handle XML responses.”)。</p>
<h4 id="弃用注释"><a href="#弃用注释" class="headerlink" title="弃用注释"></a>弃用注释</h4><h5 id="总述-33"><a href="#总述-33" class="headerlink" title="总述"></a>总述</h5><p>通过弃用注释（<font color=red>DEPRECATED</font> comments）以标记某接口点已弃用。</p>
<p>您可以写上包含全大写的<font color=red>DEPRECATED</font>的注释，以标记某接口为弃用状态。 注释可以放在接口声明前或者同一行。</p>
<p>在<font color=red>DEPRECATED</font>一词后，在括号中留下您的名字，邮箱地址以及其他身份标识。</p>
<p>弃用注释应当包涵简短而清晰的指引，以帮助其他人修复其调用点。在 C++ 中，你可以将一个弃用函数改造成一个内联函数，这一函数将调用新的接口。</p>
<p>仅仅标记接口为<font color=red>DEPRECATED</font>并不会让大家不约而同地弃用，您还得亲自主动修正调用点（callsites）或是找个帮手。</p>
<p>修正好的代码应该不会再涉及弃用接口点了，着实改用新接口点。如果您不知从何下手，可以找标记弃用注释的当事人一起商量。</p>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>每个人都可能有自己的代码风格和格式，但如果一个项目中的所有人都遵循同一风格的话，这个项目就能更顺利地进行。每个人未必能同意下述的每一处格式规则，而且其中的不少规则需要一定时间的适应，但整个项目服从统一的编程风格是很重要的，只有这样才能让所有人轻松地阅读和理解代码。</p>
<p>为了帮助你正确的格式化代码，我们写了一个<a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/google/styleguide/gh-pages/google-c-style.el">emacs配置文件</a>。</p>
<h4 id="行长度"><a href="#行长度" class="headerlink" title="行长度"></a>行长度</h4><h5 id="总述-34"><a href="#总述-34" class="headerlink" title="总述"></a>总述</h5><p>每一行代码字符数不超过80。</p>
<p>我们也认识到这条规则是有争议的，但很多已有代码都遵照这一规则，因此我们感觉一致性更重要。</p>
<h5 id="优点-11"><a href="#优点-11" class="headerlink" title="优点"></a>优点</h5><p>提倡该原则的人认为强迫他们调整编辑器窗口大小是很野蛮的行为。很多人同时并排开几个代码窗口，根本没有多余的空间拉伸窗口。大家都把窗口最大尺寸加以限定并且80列宽是传统标准。那么为什么要改变呢?</p>
<h5 id="缺点-11"><a href="#缺点-11" class="headerlink" title="缺点"></a>缺点</h5><p>反对该原则的人则认为更宽的代码行更易阅读。80列的限制是上个世纪60年代的大型机的古板缺陷；现代设备具有更宽的显示屏，可以很轻松地显示更多代码。</p>
<h5 id="结论-11"><a href="#结论-11" class="headerlink" title="结论"></a>结论</h5><p>如果无法在不伤害易读性的条件下进行断行，那么注释行可以超过80个字符，这样可以方便复制粘贴。例如，带有命令示例或URL的行可以超过80个字符。</p>
<p>包含长路径的<font color=red><code>#include</code></font>语句可以超出80列。</p>
<p><font color=blue><code>头文件保护</code></font>可以无视该原则.</p>
<h4 id="非ASCII字符"><a href="#非ASCII字符" class="headerlink" title="非ASCII字符"></a>非ASCII字符</h4><h5 id="总述-35"><a href="#总述-35" class="headerlink" title="总述"></a>总述</h5><p>尽量不使用非ASCII字符，使用时必须使用UTF-8编码。</p>
<h5 id="说明-20"><a href="#说明-20" class="headerlink" title="说明"></a>说明</h5><p>即使是英文，也不应将用户界面的文本硬编码到源代码中，因此非ASCII字符应当很少被用到。特殊情况下可以适当包含此类字符。例如，代码分析外部数据文件时，可以适当硬编码数据文件中作为分隔符的非 ASCII字符串；更常见的是(不需要本地化的)单元测试代码可能包含非ASCII字符串。此类情况下，应使用UTF-8编码，因为很多工具都可以理解和处理UTF-8编码。</p>
<p>十六进制编码也可以，能增强可读性的情况下尤其鼓励 —— 比如<font color=red><code>&quot;\xEF\xBB\xBF&quot;</code></font>，或者更简洁地写作<font color=red><code>u8&quot;\uFEFF&quot;</code></font>，在Unicode中是<em>零宽度 无间断</em>的间隔符号，如果不用十六进制直接放在UTF-8格式的源文件中，是看不到的。</p>
<p>使用<font color=red>u8</font>前缀把带<font color=red><code>uXXXX</code></font>转义序列的字符串字面值编码成UTF-8。不要用在本身就带UTF-8字符的字符串字面值上，因为如果编译器不把源代码识别成UTF-8，输出就会出错。</p>
<p>别用C++11的<font color=red><code>char16_t</code></font>和<font color=red><code>char32_t</code></font>，它们和UTF-8文本没有关系，<font color=red><code>wchar_t</code></font>同理，除非你写的代码要调用Windows API，后者广泛使用了<font color=red><code>wchar_t</code></font>。</p>
<h4 id="空格还是制表符"><a href="#空格还是制表符" class="headerlink" title="空格还是制表符"></a>空格还是制表符</h4><h5 id="总述-36"><a href="#总述-36" class="headerlink" title="总述"></a>总述</h5><p>只使用空格，每次缩进2个空格。</p>
<h5 id="说明-21"><a href="#说明-21" class="headerlink" title="说明"></a>说明</h5><p>我们使用空格缩，不要在代码中使用制表符。你应该设置编辑器将制表符转为空格。</p>
<h4 id="函数声明和定义"><a href="#函数声明和定义" class="headerlink" title="函数声明和定义"></a>函数声明和定义</h4><h5 id="总述-37"><a href="#总述-37" class="headerlink" title="总述"></a>总述</h5><p>返回类型和函数名在同一行，参数也尽量放在同一行，如果放不下就对形参分行，分行方式与<a href="">函数调用</a>一致。</p>
<h5 id="说明-22"><a href="#说明-22" class="headerlink" title="说明"></a>说明</h5><p>函数看上去像这样:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ReturnType <span class="title">ClassName::FunctionName</span><span class="params">(Type par_name1, Type par_name2)</span> </span>&#123;</span><br><span class="line">  DoSomething();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果同一行文本太多，放不下所有参数:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ReturnType <span class="title">ClassName::ReallyLongFunctionName</span><span class="params">(Type par_name1, Type par_name2,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             Type par_name3)</span> </span>&#123;</span><br><span class="line">  DoSomething();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>甚至连第一个参数都放不下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ReturnType <span class="title">LongClassName::ReallyReallyReallyLongFunctionName</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Type par_name1,  <span class="comment">// 4 space indent</span></span></span></span><br><span class="line"><span class="function"><span class="params">    Type par_name2,</span></span></span><br><span class="line"><span class="function"><span class="params">    Type par_name3)</span> </span>&#123;</span><br><span class="line">  DoSomething();  <span class="comment">// 2 space indent</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意以下几点:</p>
<ul>
<li>使用好的参数名。</li>
<li>只有在参数违背使用或者其用途非常明显时，才能省略参数名。</li>
<li>如果返回类型和函数名在一行放不下，分行。</li>
<li>如果返回类型与函数声明或定义分行了，不要缩进。</li>
<li>左圆括号总是和函数名在同一行。</li>
<li>函数名和左圆括号间永远没有空格。</li>
<li>圆括号与参数间没有空格。</li>
<li>左大括号总在最后一个参数同一行的末尾处，不另起新行。</li>
<li>右大括号总是单独位于函数最后一行，或者与左大括号同一行。</li>
<li>右圆括号和左大括号间总是有一个空格。</li>
<li>所有形参应尽可能对齐。</li>
<li>缺省缩进为2个空格。</li>
<li>换行后的参数保持4个空格的缩进。</li>
</ul>
<p>未被使用的参数，或者根据上下文很容易看出其用途的参数，可以省略参数名:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Foo(Foo&amp;&amp;);</span><br><span class="line">  Foo(<span class="keyword">const</span> Foo&amp;);</span><br><span class="line">  Foo&amp; <span class="keyword">operator</span>=(Foo&amp;&amp;);</span><br><span class="line">  Foo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Foo&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>未被使用的参数如果其用途不明显的话，在函数定义处将参数名注释起来:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Rotate</span><span class="params">(<span class="keyword">double</span> radians)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Shape &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Rotate</span><span class="params">(<span class="keyword">double</span> radians)</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Circle::Rotate</span><span class="params">(<span class="keyword">double</span> <span class="comment">/*radians*/</span>)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/ 差 - 如果将来有人要实现, 很难猜出变量的作用.</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Circle::Rotate</span><span class="params">(<span class="keyword">double</span>)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>属性和展开为属性的宏，写在函数声明或定义的最前面，即返回类型之前:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MUST_USE_RESULT <span class="keyword">bool</span> <span class="title">IsOK</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><h5 id="总述-38"><a href="#总述-38" class="headerlink" title="总述"></a>总述</h5><p>Lambda表达式对形参和函数体的格式化和其他函数一致；捕获列表同理，表项用逗号隔开。</p>
<h5 id="说明-23"><a href="#说明-23" class="headerlink" title="说明"></a>说明</h5><p>若用引用捕获，在变量名和<font color=red><code>&amp;</code></font>之间不留空格。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> add_to_x = [&amp;x](<span class="keyword">int</span> n) &#123; x += n; &#125;;</span><br></pre></td></tr></table></figure>
<p>短lambda就写得和内联函数一样。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; blacklist = &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; digits = &#123;<span class="number">3</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>&#125;;</span><br><span class="line">digits.erase(<span class="built_in">std</span>::remove_if(digits.begin(), digits.end(), [&amp;blacklist](<span class="keyword">int</span> i) &#123;</span><br><span class="line">               <span class="keyword">return</span> blacklist.find(i) != blacklist.end();</span><br><span class="line">             &#125;),</span><br><span class="line">             digits.end());</span><br></pre></td></tr></table></figure>
<h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><h5 id="总述-39"><a href="#总述-39" class="headerlink" title="总述"></a>总述</h5><p>要么一行写完函数调用，要么在圆括号里对参数分行，要么参数另起一行且缩进四格。如果没有其它顾虑的话，尽可能精简行数，比如把多个参数适当地放在同一行里。</p>
<h5 id="说明-24"><a href="#说明-24" class="headerlink" title="说明"></a>说明</h5><p>函数调用遵循如下形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> retval = DoSomething(argument1, argument2, argument3);</span><br></pre></td></tr></table></figure>
<p>如果同一行放不下，可断为多行，后面每一行都和第一个实参对齐，左圆括号后和右圆括号前不要留空格：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> retval = DoSomething(averyveryveryverylongargument1,</span><br><span class="line">                          argument2, argument3);</span><br></pre></td></tr></table></figure>
<p>参数也可以放在次行，缩进四格：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (...) &#123;</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (...) &#123;</span><br><span class="line">    DoSomething(</span><br><span class="line">        argument1, argument2,  <span class="comment">// 4 空格缩进</span></span><br><span class="line">        argument3, argument4);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>把多个参数放在同一行以减少函数调用所需的行数，除非影响到可读性。有人认为把每个参数都独立成行，不仅更好读而且方便编辑参数。不过，比起所谓的参数编辑，我们更看重可读性，且后者比较好办。</p>
<p>如果一些参数本身就是略复杂的表达式，且降低了可读性，那么可以直接创建临时变量描述该表达式，并传递给函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> my_heuristic = scores[x] * y + bases[x];</span><br><span class="line"><span class="keyword">bool</span> retval = DoSomething(my_heuristic, x, y, z);</span><br></pre></td></tr></table></figure>
<p>或者放着不管，补充上注释：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> retval = DoSomething(scores[x] * y + bases[x],  <span class="comment">// Score heuristic.</span></span><br><span class="line">                          x, y, z);</span><br></pre></td></tr></table></figure>
<p>如果某参数独立成行，对可读性更有帮助的话，那也可以如此做。参数的格式处理应当以可读性而非其他作为最重要的原则。</p>
<p>此外，如果一系列参数本身就有一定的结构，可以酌情地按其结构来决定参数格式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 3x3 矩阵转换 widget.</span></span><br><span class="line">my_widget.Transform(x1, x2, x3,</span><br><span class="line">                    y1, y2, y3,</span><br><span class="line">                    z1, z2, z3);</span><br></pre></td></tr></table></figure>
<h4 id="列表初始化格式"><a href="#列表初始化格式" class="headerlink" title="列表初始化格式"></a>列表初始化格式</h4><h5 id="总述-40"><a href="#总述-40" class="headerlink" title="总述"></a>总述</h5><p>您平时怎么格式化函数调用，就怎么格式化<a href="">列表初始化</a>。</p>
<h5 id="说明-25"><a href="#说明-25" class="headerlink" title="说明"></a>说明</h5><p>如果列表初始化伴随着名字，比如类型或变量名，格式化时将将名字视作函数调用名，*{}*视作函数调用的括号。如果没有名字，就视作名字长度为零。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一行列表初始化示范.</span></span><br><span class="line"><span class="keyword">return</span> &#123;foo, bar&#125;;</span><br><span class="line">functioncall(&#123;foo, bar&#125;);</span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p&#123;foo, bar&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当不得不断行时.</span></span><br><span class="line">SomeFunction(</span><br><span class="line">    &#123;<span class="string">&quot;assume a zero-length name before &#123;&quot;</span>&#125;,  <span class="comment">// 假设在 &#123; 前有长度为零的名字.</span></span><br><span class="line">    some_other_function_parameter);</span><br><span class="line">SomeType variable&#123;</span><br><span class="line">    some, other, values,</span><br><span class="line">    &#123;<span class="string">&quot;assume a zero-length name before &#123;&quot;</span>&#125;,  <span class="comment">// 假设在 &#123; 前有长度为零的名字.</span></span><br><span class="line">    SomeOtherType&#123;</span><br><span class="line">        <span class="string">&quot;Very long string requiring the surrounding breaks.&quot;</span>,  <span class="comment">// 非常长的字符串, 前后都需要断行.</span></span><br><span class="line">        some, other values&#125;,</span><br><span class="line">    SomeOtherType&#123;<span class="string">&quot;Slightly shorter string&quot;</span>,  <span class="comment">// 稍短的字符串.</span></span><br><span class="line">                  some, other, values&#125;&#125;;</span><br><span class="line">SomeType variable&#123;</span><br><span class="line">    <span class="string">&quot;This is too long to fit all in one line&quot;</span>&#125;;  <span class="comment">// 字符串过长, 因此无法放在同一行.</span></span><br><span class="line">MyType m = &#123;  <span class="comment">// 注意了, 您可以在 &#123; 前断行.</span></span><br><span class="line">    superlongvariablename1,</span><br><span class="line">    superlongvariablename2,</span><br><span class="line">    &#123;<span class="keyword">short</span>, interior, <span class="built_in">list</span>&#125;,</span><br><span class="line">    &#123;interiorwrappinglist,</span><br><span class="line">     interiorwrappinglist2&#125;&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><h5 id="总述-41"><a href="#总述-41" class="headerlink" title="总述"></a>总述</h5><p>倾向于不在圆括号内使用空格。关键字<font color=red><code>if</code></font>和<font color=red><code>else</code></font>另起一行。</p>
<h5 id="说明-26"><a href="#说明-26" class="headerlink" title="说明"></a>说明</h5><p>对基本条件语句有两种可以接受的格式。一种在圆括号和条件之间有空格，另一种没有。</p>
<p>最常见的是没有空格的格式，哪一种都可以，最重要的是<em>保持一致</em>，如果你是在修改一个文件，参考当前已有格式。如果是写新的代码，参考目录下或项目中其它文件。还在犹豫的话，就不要加空格了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;  <span class="comment">// 圆括号里没有空格.</span></span><br><span class="line">  ...  <span class="comment">// 2 空格缩进.</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (...) &#123;  <span class="comment">// else 与 if 的右括号同一行.</span></span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你更喜欢在圆括号内部加空格:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( condition ) &#123;  <span class="comment">// 圆括号与空格紧邻 - 不常见</span></span><br><span class="line">  ...  <span class="comment">// 2 空格缩进.</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  <span class="comment">// else 与 if 的右括号同一行.</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意所有情况下<font color=red><code>if</code></font>和左圆括号间都有个空格。右圆括号和左大括号之间也要有个空格:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition)     <span class="comment">// 差 - IF 后面没空格.</span></span><br><span class="line"><span class="keyword">if</span> (condition)&#123;   <span class="comment">// 差 - &#123; 前面没空格.</span></span><br><span class="line"><span class="keyword">if</span>(condition)&#123;    <span class="comment">// 变本加厉地差.</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;  <span class="comment">// 好 - IF 和 &#123; 都与空格紧邻.</span></span><br></pre></td></tr></table></figure>
<p>如果能增强可读性，简短的条件语句允许写在同一行。只有当语句简单并且没有使用<font color=red><code>else</code></font>子句时使用:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x == kFoo) <span class="keyword">return</span> <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="keyword">if</span> (x == kBar) <span class="keyword">return</span> <span class="keyword">new</span> Bar();</span><br></pre></td></tr></table></figure>
<p>如果语句有<font color=red><code>else</code></font>分支则不允许:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不允许 - 当有 ELSE 分支时 IF 块却写在同一行</span></span><br><span class="line"><span class="keyword">if</span> (x) DoThis();</span><br><span class="line"><span class="keyword">else</span> DoThat();</span><br></pre></td></tr></table></figure>
<p>通常，单行语句不需要使用大括号，如果你喜欢用也没问题；复杂的条件或循环语句用大括号可读性会更好。也有一些项目要求<font color=red><code>if</code></font>必须总是使用大括号:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">  DoSomething();  <span class="comment">// 2 空格缩进.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  DoSomething();  <span class="comment">// 2 空格缩进.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但如果语句中某个<font color=red><code>if-else</code></font>分支使用了大括号的话，其它分支也必须使用:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不可以这样子 - IF 有大括号 ELSE 却没有.</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  foo;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">  bar;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可以这样子 - ELSE 有大括号 IF 却没有.</span></span><br><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">  foo;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  bar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只要其中一个分支用了大括号, 两个分支都要用上大括号.</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  foo;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  bar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="循环和开关选择语句"><a href="#循环和开关选择语句" class="headerlink" title="循环和开关选择语句"></a>循环和开关选择语句</h4><h5 id="总述-42"><a href="#总述-42" class="headerlink" title="总述"></a>总述</h5><p><font color=red><code>switch</code></font>语句可以使用大括号分段，以表明font color=red&gt;<code>case</code></font>之间不是连在一起的。在单语句循环里，括号可用可不用。空循环体应使用font color=red&gt;<code>&#123;&#125;</code></font>或font color=red&gt;<code>switch</code></font>。</p>
<h5 id="说明-27"><a href="#说明-27" class="headerlink" title="说明"></a>说明</h5><p><font color=red><code>switch</code></font>语句中的<font color=red><code>case</code></font>块可以使用大括号也可以不用，取决于你的个人喜好。如果用的话，要按照下文所述的方法。</p>
<p>如果有不满足<font color=red><code>case</code></font>条件的枚举值，<font color=red><code>switch</code></font>应该总是包含一个<font color=red><code>default</code></font>匹配(如果有输入值没有<font color=red><code>case</code></font>去处理，编译器将给出warning)。如果<font color=red><code>default</code></font>应该永远执行不到，简单的加条<font color=red><code>assert</code></font>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (var) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>: &#123;  <span class="comment">// 2 空格缩进</span></span><br><span class="line">    ...      <span class="comment">// 4 空格缩进</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">default</span>: &#123;</span><br><span class="line">    assert(<span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在单语句循环里，括号可用可不用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; kSomeNumber; ++i)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;I love you\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; kSomeNumber; ++i) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;I take it back\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>空循环体应使用<font color=red><code>&#123;&#125;</code></font>或<font color=red><code>continue</code></font>，而不是一个简单的分号。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition) &#123;</span><br><span class="line">  <span class="comment">// 反复循环直到条件失效.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; kSomeNumber; ++i) &#123;&#125;  <span class="comment">// 可 - 空循环体.</span></span><br><span class="line"><span class="keyword">while</span> (condition) <span class="keyword">continue</span>;  <span class="comment">// 可 - contunue 表明没有逻辑.</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition);  <span class="comment">// 差 - 看起来仅仅只是 while/loop 的部分之一.</span></span><br></pre></td></tr></table></figure>
<h4 id="指针和引用表达式"><a href="#指针和引用表达式" class="headerlink" title="指针和引用表达式"></a>指针和引用表达式</h4><h5 id="总述-43"><a href="#总述-43" class="headerlink" title="总述"></a>总述</h5><p>句点或箭头前后不要有空格。指针/地址操作符(<font color=red><code>*，&amp;</code></font>)之后不能有空格。</p>
<h5 id="说明-28"><a href="#说明-28" class="headerlink" title="说明"></a>说明</h5><p>下面是指针和引用表达式的正确使用范例:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = *p;</span><br><span class="line">p = &amp;x;</span><br><span class="line">x = r.y;</span><br><span class="line">x = r-&gt;y;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>在访问成员时，句点或箭头前后没有空格。</li>
<li>指针操作符<font color=red><code>*</code></font>或<font color=red><code>&amp;</code></font>后没有空格.</li>
</ul>
<p>在声明指针变量或参数时，星号与类型或变量名紧挨都可以:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好, 空格前置.</span></span><br><span class="line"><span class="keyword">char</span> *c;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> &amp;str;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好, 空格后置.</span></span><br><span class="line"><span class="keyword">char</span>* c;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span>&amp; str;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x, *y;  <span class="comment">// 不允许 - 在多重声明中不能使用 &amp; 或 *</span></span><br><span class="line"><span class="keyword">char</span> * c;  <span class="comment">// 差 - * 两边都有空格</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> &amp; str;  <span class="comment">// 差 - &amp; 两边都有空格.</span></span><br></pre></td></tr></table></figure>
<p>在单个文件内要保持风格一致，所以，如果是修改现有文件，要遵照该文件的风格。</p>
<h4 id="布尔表达式"><a href="#布尔表达式" class="headerlink" title="布尔表达式"></a>布尔表达式</h4><h5 id="总述-44"><a href="#总述-44" class="headerlink" title="总述"></a>总述</h5><p>如果一个布尔表达式超过<a href="">标准行宽</a>，断行方式要统一一下。</p>
<h5 id="说明-29"><a href="#说明-29" class="headerlink" title="说明"></a>说明</h5><p>下例中，逻辑与(<font color=red><code>&amp;&amp;</code></font>)操作符总位于行尾:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (this_one_thing &gt; this_other_thing &amp;&amp;</span><br><span class="line">    a_third_thing == a_fourth_thing &amp;&amp;</span><br><span class="line">    yet_another &amp;&amp; last_one) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，上例的逻辑与(<font color=red><code>&amp;&amp;</code></font>)操作符均位于行尾。这个格式在Google里很常见，虽然把所有操作符放在开头也可以。可以考虑额外插入圆括号，合理使用的话对增强可读性是很有帮助的。此外，直接用符号形式的操作符，比如<font color=red><code>&amp;&amp;</code></font>和<font color=red><code>～</code></font>，不要用词语形式的<font color=red><code>and</code></font>和<font color=red><code>compl</code></font>。</p>
<h4 id="函数返回类型"><a href="#函数返回类型" class="headerlink" title="函数返回类型"></a>函数返回类型</h4><h5 id="总述-45"><a href="#总述-45" class="headerlink" title="总述"></a>总述</h5><p>不要在<font color=red><code>return</code></font>表达式里加上非必须的圆括号。</p>
<h5 id="说明-30"><a href="#说明-30" class="headerlink" title="说明"></a>说明</h5><p>只有在写<font color=red><code>x = expr</code></font>要加上括号的时候才在<font color=red><code>return expr;</code></font>里使用括号。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> result;                  <span class="comment">// 返回值很简单, 没有圆括号.</span></span><br><span class="line"><span class="comment">// 可以用圆括号把复杂表达式圈起来, 改善可读性.</span></span><br><span class="line"><span class="keyword">return</span> (some_long_condition &amp;&amp;</span><br><span class="line">        another_condition);</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (value);                <span class="comment">// 毕竟您从来不会写 var = (value);</span></span><br><span class="line"><span class="keyword">return</span>(result);                <span class="comment">// return 可不是函数！</span></span><br></pre></td></tr></table></figure>
<h4 id="变量及数组初始化"><a href="#变量及数组初始化" class="headerlink" title="变量及数组初始化"></a>变量及数组初始化</h4><h5 id="总述-46"><a href="#总述-46" class="headerlink" title="总述"></a>总述</h5><p>用<font color=red><code>=</code></font>，<font color=red><code>()</code></font>和<font color=red><code>&#123;&#125;</code></font>均可。</p>
<h5 id="说明-31"><a href="#说明-31" class="headerlink" title="说明"></a>说明</h5><p>您可以用<font color=red><code>=</code></font>，<font color=red><code>()</code></font>和<font color=red><code>&#123;&#125;</code></font>，以下的例子都是正确的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">x</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> x&#123;<span class="number">3</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">name</span><span class="params">(<span class="string">&quot;Some Name&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">string</span> name = <span class="string">&quot;Some Name&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> name&#123;<span class="string">&quot;Some Name&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>请务必小心列表初始化<font color=red><code>&#123;...&#125;</code></font>用<font color=red><code>std::initializer_list</code></font>构造函数初始化出的类型。非空列表初始化就会优先调用<font color=red><code>std::initializer_list</code></font>，不过空列表初始化除外，后者原则上会调用默认构造函数。为了强制禁用<font color=red><code>std::initializer_list</code></font>构造函数，请改用括号。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">100</span>, <span class="number">1</span>)</span></span>;  <span class="comment">// 内容为 100 个 1 的向量.</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">100</span>, <span class="number">1</span>&#125;;  <span class="comment">// 内容为 100 和 1 的向量.</span></span><br></pre></td></tr></table></figure>
<p>此外，列表初始化不允许整型类型的四舍五入，这可以用来避免一些类型上的编程失误。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pi</span><span class="params">(<span class="number">3.14</span>)</span></span>;  <span class="comment">// 好 - pi == 3.</span></span><br><span class="line"><span class="keyword">int</span> pi&#123;<span class="number">3.14</span>&#125;;  <span class="comment">// 编译错误: 缩窄转换.</span></span><br></pre></td></tr></table></figure>
<h4 id="预处理指令"><a href="#预处理指令" class="headerlink" title="预处理指令"></a>预处理指令</h4><h5 id="总述-47"><a href="#总述-47" class="headerlink" title="总述"></a>总述</h5><p>预处理指令不要缩进，从行首开始。</p>
<h5 id="说明-32"><a href="#说明-32" class="headerlink" title="说明"></a>说明</h5><p>即使预处理指令位于缩进代码块中，指令也应从行首开始。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好 - 指令从行首开始</span></span><br><span class="line">  <span class="keyword">if</span> (lopsided_score) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISASTER_PENDING      <span class="comment">// 正确 - 从行首开始</span></span></span><br><span class="line">    DropEverything();</span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> NOTIFY               <span class="comment">// 非必要 - # 后跟空格</span></span></span><br><span class="line">    NotifyClient();</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    BackToNormal();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 差 - 指令缩进</span></span><br><span class="line">  <span class="keyword">if</span> (lopsided_score) &#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> DISASTER_PENDING  <span class="comment">// 差 - &quot;#if&quot; 应该放在行开头</span></span></span><br><span class="line">    DropEverything();</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span>                <span class="comment">// 差 - ”#endif“不要缩进</span></span></span><br><span class="line">    BackToNormal();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="类格式"><a href="#类格式" class="headerlink" title="类格式"></a>类格式</h4><h5 id="总述-48"><a href="#总述-48" class="headerlink" title="总述"></a>总述</h5><p>访问控制块的声明依次序是<font color=red>public:</font>，<font color=red>protected:</font>，<font color=red>private:</font>，每个都缩进 1 个空格。</p>
<h5 id="说明-33"><a href="#说明-33" class="headerlink" title="说明"></a>说明</h5><p>类声明(下面的代码中缺少注释，参考<a href="">类注释</a>)的基本格式如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> :</span> <span class="keyword">public</span> OtherClass &#123;</span><br><span class="line"> <span class="keyword">public</span>:      <span class="comment">// 注意有一个空格的缩进</span></span><br><span class="line">  MyClass();  <span class="comment">// 标准的两空格缩进</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="keyword">int</span> var)</span></span>;</span><br><span class="line">  ~MyClass() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SomeFunction</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SomeFunctionThatDoesNothing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_some_var</span><span class="params">(<span class="keyword">int</span> var)</span> </span>&#123; some_var_ = var; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">some_var</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> some_var_; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">SomeInternalFunction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> some_var_;</span><br><span class="line">  <span class="keyword">int</span> some_other_var_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<ul>
<li>所有基类名应在80列限制下尽量与子类名放在同一行。</li>
<li>关键词<font color=red>public:</font>，<font color=red>protected:</font>，<font color=red>private:</font>要缩进1个空格。</li>
<li>除第一个关键词(一般是<font color=red>public:</font>)外，其他关键词前要空一行。如果类比较小的话也可以不空。</li>
<li><font color=red>public:</font>放在最前面，然后是<font color=red>protected:</font>，最后是<font color=red>private:</font>。</li>
<li>关于声明顺序的规则请参考<a href="">声明顺序</a>一节。</li>
</ul>
<h4 id="构造函数初始化列表"><a href="#构造函数初始化列表" class="headerlink" title="构造函数初始化列表"></a>构造函数初始化列表</h4><h5 id="总述-49"><a href="#总述-49" class="headerlink" title="总述"></a>总述</h5><p>构造函数初始化列表放在同一行或按四格缩进并排多行。</p>
<h5 id="说明-34"><a href="#说明-34" class="headerlink" title="说明"></a>说明</h5><p>下面两种初始值列表方式都可以接受:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果所有变量能放在同一行:</span></span><br><span class="line">MyClass::MyClass(<span class="keyword">int</span> var) : some_var_(var) &#123;</span><br><span class="line">  DoSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不能放在同一行,</span></span><br><span class="line"><span class="comment">// 必须置于冒号后, 并缩进 4 个空格</span></span><br><span class="line">MyClass::MyClass(<span class="keyword">int</span> var)</span><br><span class="line">    : some_var_(var), some_other_var_(var + <span class="number">1</span>) &#123;</span><br><span class="line">  DoSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果初始化列表需要置于多行, 将每一个成员放在单独的一行</span></span><br><span class="line"><span class="comment">// 并逐行对齐</span></span><br><span class="line">MyClass::MyClass(<span class="keyword">int</span> var)</span><br><span class="line">    : some_var_(var),             <span class="comment">// 4 space indent</span></span><br><span class="line">      some_other_var_(var + <span class="number">1</span>) &#123;  <span class="comment">// lined up</span></span><br><span class="line">  DoSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右大括号 &#125; 可以和左大括号 &#123; 放在同一行</span></span><br><span class="line"><span class="comment">// 如果这样做合适的话</span></span><br><span class="line">MyClass::MyClass(<span class="keyword">int</span> var)</span><br><span class="line">    : some_var_(var) &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="命名空间格式化"><a href="#命名空间格式化" class="headerlink" title="命名空间格式化"></a>命名空间格式化</h4><h5 id="总述-50"><a href="#总述-50" class="headerlink" title="总述"></a>总述</h5><p>命名空间内容不缩进。</p>
<h5 id="说明-35"><a href="#说明-35" class="headerlink" title="说明"></a>说明</h5><p><a href="">命名空间</a>不要增加额外的缩进层次，例如:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;  <span class="comment">// 正确. 命名空间内没有额外的缩进.</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace</span></span><br></pre></td></tr></table></figure>
<p>不要在命名空间内缩进:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 错, 缩进多余了.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace</span></span><br></pre></td></tr></table></figure>
<p>声明嵌套命名空间时，每个命名空间都独立成行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> foo &#123;</span><br><span class="line"><span class="keyword">namespace</span> bar &#123;</span><br></pre></td></tr></table></figure>
<h4 id="水平留白"><a href="#水平留白" class="headerlink" title="水平留白"></a>水平留白</h4><h5 id="总述-51"><a href="#总述-51" class="headerlink" title="总述"></a>总述</h5><p>水平留白的使用根据在代码中的位置决定，永远不要在行尾添加没意义的留白。</p>
<h5 id="说明-36"><a href="#说明-36" class="headerlink" title="说明"></a>说明</h5><p><strong>通用</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">bool</span> b)</span> </span>&#123;  <span class="comment">// 左大括号前总是有空格.</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;  <span class="comment">// 分号前不加空格.</span></span><br><span class="line"><span class="comment">// 列表初始化中大括号内的空格是可选的.</span></span><br><span class="line"><span class="comment">// 如果加了空格, 那么两边都要加上.</span></span><br><span class="line"><span class="keyword">int</span> x[] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> x[] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承与初始化列表中的冒号前后恒有空格.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> :</span> <span class="keyword">public</span> Bar &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 对于单行函数的实现, 在大括号内加上空格</span></span><br><span class="line">  <span class="comment">// 然后是函数实现</span></span><br><span class="line">  Foo(<span class="keyword">int</span> b) : Bar(), baz_(b) &#123;&#125;  <span class="comment">// 大括号里面是空的话, 不加空格.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Reset</span><span class="params">()</span> </span>&#123; baz_ = <span class="number">0</span>; &#125;  <span class="comment">// 用括号把大括号与实现分开.</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>添加冗余的留白会给其他人编辑时造成额外负担。因此，行尾不要留空格。如果确定一行代码已经修改完毕，将多余的空格去掉；或者在专门清理空格时去掉（尤其是在没有其他人在处理这件事的时候)。</p>
<p><strong>循环和条件语句</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (b) &#123;          <span class="comment">// if 条件语句和循环语句关键字后均有空格.</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;          <span class="comment">// else 前后有空格.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (test) &#123;&#125;   <span class="comment">// 圆括号内部不紧邻空格.</span></span><br><span class="line"><span class="keyword">switch</span> (i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line"><span class="keyword">switch</span> ( i ) &#123;    <span class="comment">// 循环和条件语句的圆括号里可以与空格紧邻.</span></span><br><span class="line"><span class="keyword">if</span> ( test ) &#123;     <span class="comment">// 圆括号, 但这很少见. 总之要一致.</span></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i ) &#123;</span><br><span class="line"><span class="keyword">for</span> ( ; i &lt; <span class="number">5</span> ; ++i) &#123;  <span class="comment">// 循环里内 ; 后恒有空格, ;  前可以加个空格.</span></span><br><span class="line"><span class="keyword">switch</span> (i) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:         <span class="comment">// switch case 的冒号前无空格.</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">break</span>;  <span class="comment">// 如果冒号有代码, 加个空格.</span></span><br></pre></td></tr></table></figure>
<p><strong>操作符</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 赋值运算符前后总是有空格.</span></span><br><span class="line">x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其它二元操作符也前后恒有空格, 不过对于表达式的子式可以不加空格.</span></span><br><span class="line"><span class="comment">// 圆括号内部没有紧邻空格.</span></span><br><span class="line">v = w * x + y / z;</span><br><span class="line">v = w*x + y/z;</span><br><span class="line">v = w * (x + z);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在参数和一元操作符之间不加空格.</span></span><br><span class="line">x = <span class="number">-5</span>;</span><br><span class="line">++x;</span><br><span class="line"><span class="keyword">if</span> (x &amp;&amp; !y)</span><br></pre></td></tr></table></figure>
<p><strong>模板和转换</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尖括号(&lt; and &gt;) 不与空格紧邻, &lt; 前没有空格, &gt; 和 ( 之间也没有.</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; x;</span><br><span class="line">y = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在类型与指针操作符之间留空格也可以, 但要保持一致.</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">char</span> *&gt; x;</span><br></pre></td></tr></table></figure>
<h4 id="垂直留白"><a href="#垂直留白" class="headerlink" title="垂直留白"></a>垂直留白</h4><h5 id="总述-52"><a href="#总述-52" class="headerlink" title="总述"></a>总述</h5><p>垂直留白越少越好.</p>
<h5 id="说明-37"><a href="#说明-37" class="headerlink" title="说明"></a>说明</h5><p>这不仅仅是规则而是原则问题了：不在万不得已，不要使用空行。尤其是: 两个函数定义之间的空行不要超过2行，函数体首尾不要留空行，函数体中也不要随意添加空行。</p>
<p>基本原则是: 同一屏可以显示的代码越多，越容易理解程序的控制流。当然，过于密集的代码块和过于疏松的代码块同样难看，这取决于你的判断。但通常是垂直留白越少越好。</p>
<p>下面的规则可以让加入的空行更有效:</p>
<ul>
<li>函数体内开头或结尾的空行可读性微乎其微。</li>
<li>在多重if-else块里加空行或许有点可读性。</li>
</ul>
<h3 id="规则特例"><a href="#规则特例" class="headerlink" title="规则特例"></a>规则特例</h3><p>前面说明的编程习惯基本都是强制性的。但所有优秀的规则都允许例外，这里就是探讨这些特例。</p>
<h4 id="现有不合规范代码"><a href="#现有不合规范代码" class="headerlink" title="现有不合规范代码"></a>现有不合规范代码</h4><h5 id="总述-53"><a href="#总述-53" class="headerlink" title="总述"></a>总述</h5><p>对于现有不符合既定编程风格的代码可以网开一面。</p>
<h5 id="说明-38"><a href="#说明-38" class="headerlink" title="说明"></a>说明</h5><p>当你修改使用其他风格的代码时，为了与代码原有风格保持一致可以不使用本指南约定。如果不放心， 可以与代码原作者或现在的负责人员商讨。记住，<em>一致性</em>也包括原有的一致性。</p>
<h4 id="Windows代码"><a href="#Windows代码" class="headerlink" title="Windows代码"></a>Windows代码</h4><h5 id="总述-54"><a href="#总述-54" class="headerlink" title="总述"></a>总述</h5><p>Windows程序员有自己的编程习惯，主要源于Windows头文件和其它Microsoft代码。我们希望任何人都可以顺利读懂你的代码，所以针对所有平台的C++编程只给出一个单独的指南。</p>
<h5 id="说明-39"><a href="#说明-39" class="headerlink" title="说明"></a>说明</h5><p>如果你习惯使用Windows编码风格，这儿有必要重申一下某些你可能会忘记的指南:</p>
<ul>
<li>不要使用匈牙利命名法(比如把整型变量命名成<font color=red><code>iNum</code></font>)。使用 Google命名约定，包括对源文件使用<font color=red><code>.cc</code></font>扩展名。</li>
<li>Windows定义了很多原生类型的同义词，如<font color=red><code>DWORD</code></font>、<font color=red><code>HANDLE</code></font>等等。在调用Windows API时这是完全可以接受甚至鼓励的。即使如此，还是尽量使用原有的C++类型，例如使用<font color=red><code>const TCHAR *</code></font>而不是 <font color=red><code>LPCSTR</code></font>。</li>
<li>使用Microsoft Visual C++进行编译时，将警告级别设置为3或更高，并将所有警告(warnings)当作错误(errors)处理.</li>
<li>不要使用<font color=red><code>#pragma once</code></font>；而应该使用Google的头文件保护规则。 头文件保护的路径应该相对于项目根目录。</li>
<li>除非万不得已，不要使用任何非标准的扩展，如<font color=red><code>#program</code></font>和<font color=red><code>__declspec</code></font>。使用<font color=red><code>__declspec(dllimport)</code></font>和<font color=red><code>__declspec(dllxeport)</code></font>是允许的，但必须通过宏来使用，比如 <font color=red><code>DLLIMPORT</code></font>和<font color=red><code>DLLEXPORT</code></font> ，这样其他人在分享使用这些代码时可以很容易地禁用这些扩展。</li>
</ul>
<p>然而，在Windows上仍然有一些我们偶尔需要违反的规则:</p>
<ul>
<li>通常我们<a href="">禁止使用多重继承</a>，但在使用COM和ATL/WTL类时可以使用多重继承。为了实现COM或 ATL/WTL类/接口，你可能不得不使用多重实现继承。</li>
<li>虽然代码中不应该使用异常，但是在ATL和部分STL（包括Visual C++的STL)中异常被广泛使用。使用ATL时，应定义<font color=red><code>_ATL_NO_EXCEPTIONS</code></font> 以禁用异常。你需要研究一下是否能够禁用STL的异常，如果无法禁用，可以启用编译器异常。(注意这只是为了编译STL，自己的代码里仍然不应当包含异常处理)。</li>
<li>通常为了利用头文件预编译，每个每个源文件的开头都会包含一个名为<font color=red><code>StdAfx.h</code></font>或<font color=red><code>precompile.h</code></font>的文件。为了使代码方便与其他项目共享，请避免显式包含此文件(除了在<font color=red><code>precompile.cc</code></font>中)，使用<font color=red><code>/FI</code></font>编译器选项以自动包含该文件.</li>
<li>资源头文件通常命名为<font color=red><code>resource.h</code></font>且只包含宏，这一文件不需要遵守本风格指南。</li>
</ul>
<h3 id="来自Google的奇特（Cpplint）"><a href="#来自Google的奇特（Cpplint）" class="headerlink" title="来自Google的奇特（Cpplint）"></a>来自Google的奇特（Cpplint）</h3><p>Google用了很多自己实现的技巧/工具使C++代码更加健壮，我们使用C++的方式可能和你在其它地方见到的有所不同。</p>
<h4 id="所有权与智能指针"><a href="#所有权与智能指针" class="headerlink" title="所有权与智能指针"></a>所有权与智能指针</h4><h5 id="gt-总述"><a href="#gt-总述" class="headerlink" title="&gt; 总述"></a>&gt; 总述</h5><p>动态分配出的对象最好有单一且固定的所有主，并通过智能指针传递所有权。</p>
<h5 id="gt-定义"><a href="#gt-定义" class="headerlink" title="&gt; 定义"></a>&gt; 定义</h5><p>所有权是一种登记／管理动态内存和其它资源的技术。动态分配对象的所有主是一个对象或函数，后者负责确保当前者无用时就自动销毁前者。所有权有时可以共享，此时就由最后一个所有主来负责销毁它。甚至也可以不用共享，在代码中直接把所有权传递给其它对象。</p>
<p>智能指针是一个通过重载<font color=red><code>*</code></font>和<font color=red><code>-&gt;</code></font>运算符以表现得如指针一样的类。智能指针类型被用来自动化所有权的登记工作，来确保执行销毁义务到位。<a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/memory/unique_ptr">std::unique_ptr</a>是C++11新推出的一种智能指针类型，用来表示动态分配出的对象的独一无二的所有权；当<a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/memory/unique_ptr">std::unique_ptr</a>离开作用域时，对象就会被销毁。<font color=red><code>std::unique_ptr</code></font>不能被复制，但可以把它移动（move）给新所有主。std::unique_ptr](<a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/memory/unique_ptr)%E5%90%8C%E6%A0%B7%E8%A1%A8%E7%A4%BA%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%8C%E4%BD%86%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%85%B1%E4%BA%AB%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%A4%8D%E5%88%B6%EF%BC%9B%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83%E7%94%B1%E6%89%80%E6%9C%89%E5%A4%8D%E5%88%B6%E8%80%85%E5%85%B1%E5%90%8C%E6%8B%A5%E6%9C%89%EF%BC%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%A4%8D%E5%88%B6%E8%80%85%E8%A2%AB%E9%94%80%E6%AF%81%E6%97%B6%EF%BC%8C%E5%AF%B9%E8%B1%A1%E4%B9%9F%E4%BC%9A%E9%9A%8F%E7%9D%80%E8%A2%AB%E9%94%80%E6%AF%81%E3%80%82">http://en.cppreference.com/w/cpp/memory/unique_ptr)同样表示动态分配对象的所有权，但可以被共享，也可以被复制；对象的所有权由所有复制者共同拥有，最后一个复制者被销毁时，对象也会随着被销毁。</a></p>
<h5 id="gt-优点"><a href="#gt-优点" class="headerlink" title="&gt; 优点"></a>&gt; 优点</h5><ul>
<li>如果没有清晰、逻辑条理的所有权安排，不可能管理好动态分配的内存。</li>
<li>传递对象的所有权，开销比复制来得小，如果可以复制的话。</li>
<li>传递所有权也比”借用”指针或引用来得简单，毕竟它大大省去了两个用户一起协调对象生命周期的工作。</li>
<li>如果所有权逻辑条理，有文档且不紊乱的话，可读性会有很大提升。</li>
<li>可以不用手动完成所有权的登记工作，大大简化了代码，也免去了一大波错误之恼。</li>
<li>对于const对象来说，智能指针简单易用，也比深度复制高效。</li>
</ul>
<h5 id="gt-缺点"><a href="#gt-缺点" class="headerlink" title="&gt; 缺点"></a>&gt; 缺点</h5><ul>
<li>不得不用指针（不管是智能的还是原生的）来表示和传递所有权。指针语义可要比值语义复杂得许多了，特别是在API里：这时不光要操心所有权，还要顾及别名、生命周期、可变性以及其它大大小小的问题。</li>
<li>其实值语义的开销经常被高估，所以所有权传递带来的性能提升不一定能弥补可读性和复杂度的损失。</li>
<li>如果API依赖所有权的传递，就会害得客户端不得不用单一的内存管理模型。</li>
<li>如果使用智能指针，那么资源释放发生的位置就会变得不那么明显。</li>
<li><font color=red><code>std::unique_ptr</code></font>的所有权传递原理是C++11的move语法，后者毕竟是刚刚推出的，容易迷惑程序员。</li>
<li>如果原本的所有权设计已经够完善了，那么若要引入所有权共享机制，可能不得不重构整个系统。</li>
<li>所有权共享机制的登记工作在运行时进行，开销可能相当大。</li>
<li>某些极端情况下 (例如循环引用)，所有权被共享的对象永远不会被销毁。</li>
<li>智能指针并不能够完全代替原生指针。</li>
</ul>
<h5 id="gt-结论"><a href="#gt-结论" class="headerlink" title="&gt; 结论"></a>&gt; 结论</h5><p>如果必须使用动态分配，那么更倾向于将所有权保持在分配者手中。如果其他地方要使用这个对象，最好传递它的拷贝，或者传递一个不用改变所有权的指针或引用。倾向于使用<font color=red><code>std::unique_ptr</code></font>来明确所有权传递，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Foo&gt; <span class="title">FooFactory</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FooConsumer</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Foo&gt; ptr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果没有很好的理由，则不要使用共享所有权。这里的理由可以是为了避免开销昂贵的拷贝操作，但是只有当性能提升非常明显，并且操作的对象是不可变的（比如说<font color=red><code>std::shared_ptr&lt;const Foo&gt;</code></font>）时候，才能这么做。如果确实要使用共享所有权, 建议于使用<font color=red><code>std::shared_ptr</code></font>.</p>
<p>不要使用<font color=red><code>std::auto_ptr</code></font>，使用<font color=red><code>std::unique_ptr</code></font>代替它.</p>
<h4 id="Cpplint"><a href="#Cpplint" class="headerlink" title="Cpplint"></a>Cpplint</h4><h5 id="gt-总述-1"><a href="#gt-总述-1" class="headerlink" title="&gt; 总述"></a>&gt; 总述</h5><p>使用<font color=red><code>cpplint.py</code></font>检查风格错误。</p>
<h5 id="gt-说明"><a href="#gt-说明" class="headerlink" title="&gt; 说明"></a>&gt; 说明</h5><p><font color=red><code>cpplint.py</code></font>是一个用来分析源文件，能检查出多种风格错误的工具，它不并完美，甚至还会漏报和误报，但它仍然是一个非常有用的工具。在行尾加<font color=red><code>//NOLINT</code></font>或在上一行加<font color=red><code>// NOLINTNEXTLINE</code></font>，可以忽略报错。</p>
<p>某些项目会指导你如何使用他们的项目工具运行 <font color=red><code>cpplint.py</code></font>。如果你参与的项目没有提供，你可以单独下载<a target="_blank" rel="noopener" href="https://github.com/google/styleguide/blob/gh-pages/cpplint/cpplint.py">cpplint.py</a>。</p>

    </div>

    
    
    
        <div class="reward-container">
  <div>原创技术分享，您的支持将鼓励我继续创作</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    Donate
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="Javy WeChat Pay">
        <p>WeChat Pay</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="Javy Alipay">
        <p>Alipay</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/python/python_style_of_google/" rel="prev" title="Python Style of Google">
      <i class="fa fa-chevron-left"></i> Python Style of Google
    </a></div>
      <div class="post-nav-item">
    <a href="/rests/markdown_font/" rel="next" title="Markdown编辑器语法——设置字体、字号和颜色">
      Markdown编辑器语法——设置字体、字号和颜色 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E9%A3%8E%E6%A0%BC%E8%A7%84%E8%8C%83%EF%BC%88Google%E7%89%88%EF%BC%89"><span class="nav-number">1.</span> <span class="nav-text">C++风格规范（Google版）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="nav-number">1.1.</span> <span class="nav-text">头文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Self-contained%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="nav-number">1.1.1.</span> <span class="nav-text">Self-contained头文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#defined%E4%BF%9D%E6%8A%A4"><span class="nav-number">1.1.2.</span> <span class="nav-text">#defined保护</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%8D%E7%BD%AE%E5%A3%B0%E6%98%8E"><span class="nav-number">1.1.3.</span> <span class="nav-text">前置声明</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">优点：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">缺点：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%93%E8%AE%BA%EF%BC%9A"><span class="nav-number">1.1.3.4.</span> <span class="nav-text">结论：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.4.</span> <span class="nav-text">内联函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">定义：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A-1"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">优点：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A-1"><span class="nav-number">1.1.4.3.</span> <span class="nav-text">缺点：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%93%E8%AE%BA%EF%BC%9A-1"><span class="nav-number">1.1.4.4.</span> <span class="nav-text">结论：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#include%E8%B7%AF%E5%BE%84%E5%8F%8A%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.1.5.</span> <span class="nav-text">#include路径及顺序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">1.2.</span> <span class="nav-text">作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-number">1.2.1.</span> <span class="nav-text">命名空间</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A-1"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">定义：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A-2"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">优点：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A-2"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">缺点：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%93%E8%AE%BA%EF%BC%9A-2"><span class="nav-number">1.2.1.4.</span> <span class="nav-text">结论：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%92%8C%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="nav-number">1.2.2.</span> <span class="nav-text">匿名命名空间和静态变量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A-2"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">定义：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%93%E8%AE%BA%EF%BC%9A-3"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">结论：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E3%80%81%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%92%8C%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.3.</span> <span class="nav-text">非成员函数、静态成员函数和全局函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A-3"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">优点：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A-3"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">缺点：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%93%E8%AE%BA%EF%BC%9A-4"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">结论：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="nav-number">1.2.4.</span> <span class="nav-text">局部变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="nav-number">1.2.5.</span> <span class="nav-text">静态和全局变量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB"><span class="nav-number">1.3.</span> <span class="nav-text">类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%81%8C%E8%B4%A3"><span class="nav-number">1.3.1.</span> <span class="nav-text">构造函数的职责</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%98%E7%82%B9"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9"><span class="nav-number">1.3.1.4.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%93%E8%AE%BA"><span class="nav-number">1.3.1.5.</span> <span class="nav-text">结论</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.3.2.</span> <span class="nav-text">隐式类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-1"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-2"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">定义</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-1"><span class="nav-number">1.3.3.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-1"><span class="nav-number">1.3.4.</span> <span class="nav-text">缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%93%E8%AE%BA-1"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">结论</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E6%8B%B7%E8%B4%9D%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8F%AF%E7%A7%BB%E5%8A%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.3.5.</span> <span class="nav-text">可拷贝类型和可移动类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-2"><span class="nav-number">1.3.6.</span> <span class="nav-text">总述</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-3"><span class="nav-number">1.3.6.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-2"><span class="nav-number">1.3.6.2.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-2"><span class="nav-number">1.3.6.3.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%93%E8%AE%BA-2"><span class="nav-number">1.3.6.4.</span> <span class="nav-text">结论</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB"><span class="nav-number">1.3.7.</span> <span class="nav-text">结构体和类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-3"><span class="nav-number">1.3.7.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E"><span class="nav-number">1.3.7.2.</span> <span class="nav-text">说明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">1.3.8.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-4"><span class="nav-number">1.3.8.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-4"><span class="nav-number">1.3.8.2.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-3"><span class="nav-number">1.3.8.3.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-3"><span class="nav-number">1.3.8.4.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%93%E8%AE%BA-3"><span class="nav-number">1.3.8.5.</span> <span class="nav-text">结论</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="nav-number">1.3.9.</span> <span class="nav-text">多重继承</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-5"><span class="nav-number">1.3.9.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-5"><span class="nav-number">1.3.9.2.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-4"><span class="nav-number">1.3.9.3.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-4"><span class="nav-number">1.3.9.4.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%93%E8%AE%BA-4"><span class="nav-number">1.3.9.5.</span> <span class="nav-text">结论</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.3.10.</span> <span class="nav-text">接口</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-6"><span class="nav-number">1.3.10.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-6"><span class="nav-number">1.3.10.2.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-5"><span class="nav-number">1.3.10.3.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-5"><span class="nav-number">1.3.10.4.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%93%E8%AE%BA-5"><span class="nav-number">1.3.10.5.</span> <span class="nav-text">结论</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">1.3.11.</span> <span class="nav-text">运算符重载</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-7"><span class="nav-number">1.3.11.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-7"><span class="nav-number">1.3.11.2.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-6"><span class="nav-number">1.3.11.3.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-6"><span class="nav-number">1.3.11.4.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%93%E8%AE%BA-6"><span class="nav-number">1.3.11.5.</span> <span class="nav-text">结论</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6"><span class="nav-number">1.3.12.</span> <span class="nav-text">存取控制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-8"><span class="nav-number">1.3.12.1.</span> <span class="nav-text">总述</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.3.13.</span> <span class="nav-text">声明顺序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-1"><span class="nav-number">1.3.13.1.</span> <span class="nav-text">说明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.4.1.</span> <span class="nav-text">参数顺序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-9"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-2"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">说明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E7%AE%80%E7%9F%AD%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.2.</span> <span class="nav-text">编写简短函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-10"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-3"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">说明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0"><span class="nav-number">1.4.3.</span> <span class="nav-text">引用参数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-11"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-8"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-7"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-7"><span class="nav-number">1.4.3.4.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%93%E8%AE%BA-7"><span class="nav-number">1.4.3.5.</span> <span class="nav-text">结论</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="nav-number">1.4.4.</span> <span class="nav-text">函数重载</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-12"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-9"><span class="nav-number">1.4.4.2.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-8"><span class="nav-number">1.4.4.3.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-8"><span class="nav-number">1.4.4.4.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%93%E8%AE%BA-8"><span class="nav-number">1.4.4.5.</span> <span class="nav-text">结论</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0"><span class="nav-number">1.4.5.</span> <span class="nav-text">缺省参数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-13"><span class="nav-number">1.4.5.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-9"><span class="nav-number">1.4.5.2.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-9"><span class="nav-number">1.4.5.3.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%93%E8%AE%BA-9"><span class="nav-number">1.4.5.4.</span> <span class="nav-text">结论</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E5%90%8E%E7%BD%AE%E8%AF%AD%E6%B3%95"><span class="nav-number">1.4.6.</span> <span class="nav-text">函数返回类型后置语法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-14"><span class="nav-number">1.4.6.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-10"><span class="nav-number">1.4.6.2.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-10"><span class="nav-number">1.4.6.3.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-10"><span class="nav-number">1.4.6.4.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%93%E8%AE%BA-10"><span class="nav-number">1.4.6.5.</span> <span class="nav-text">结论</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96C-%E7%89%B9%E6%80%A7"><span class="nav-number">1.5.</span> <span class="nav-text">其他C++特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%BA%A6%E5%AE%9A"><span class="nav-number">1.6.</span> <span class="nav-text">命名约定</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="nav-number">1.6.1.</span> <span class="nav-text">通用命名规则</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-15"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-4"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">说明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%91%BD%E5%90%8D"><span class="nav-number">1.6.2.</span> <span class="nav-text">文件命名</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-16"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-5"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">说明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%91%BD%E5%90%8D"><span class="nav-number">1.6.3.</span> <span class="nav-text">类型命名</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-17"><span class="nav-number">1.6.3.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-6"><span class="nav-number">1.6.3.2.</span> <span class="nav-text">说明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D"><span class="nav-number">1.6.4.</span> <span class="nav-text">变量命名</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-18"><span class="nav-number">1.6.4.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-7"><span class="nav-number">1.6.4.2.</span> <span class="nav-text">说明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E5%91%BD%E5%90%8D"><span class="nav-number">1.6.5.</span> <span class="nav-text">常量命名</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-19"><span class="nav-number">1.6.5.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-8"><span class="nav-number">1.6.5.2.</span> <span class="nav-text">说明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%91%BD%E5%90%8D"><span class="nav-number">1.6.6.</span> <span class="nav-text">函数命名</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-20"><span class="nav-number">1.6.6.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-9"><span class="nav-number">1.6.6.2.</span> <span class="nav-text">说明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%91%BD%E5%90%8D"><span class="nav-number">1.6.7.</span> <span class="nav-text">命名空间命名</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-21"><span class="nav-number">1.6.7.1.</span> <span class="nav-text">总述</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E5%91%BD%E5%90%8D"><span class="nav-number">1.6.8.</span> <span class="nav-text">枚举命名</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-22"><span class="nav-number">1.6.8.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-10"><span class="nav-number">1.6.8.2.</span> <span class="nav-text">说明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8F%E5%91%BD%E5%90%8D"><span class="nav-number">1.6.9.</span> <span class="nav-text">宏命名</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-23"><span class="nav-number">1.6.9.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-11"><span class="nav-number">1.6.9.2.</span> <span class="nav-text">说明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99%E7%89%B9%E4%BE%8B"><span class="nav-number">1.6.10.</span> <span class="nav-text">命名规则特例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-24"><span class="nav-number">1.6.10.1.</span> <span class="nav-text">总述</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E9%87%8A"><span class="nav-number">1.7.</span> <span class="nav-text">注释</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E9%87%8A%E9%A3%8E%E6%A0%BC"><span class="nav-number">1.7.1.</span> <span class="nav-text">注释风格</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-25"><span class="nav-number">1.7.1.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-12"><span class="nav-number">1.7.1.2.</span> <span class="nav-text">说明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%B3%A8%E9%87%8A"><span class="nav-number">1.7.2.</span> <span class="nav-text">文件注释</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-26"><span class="nav-number">1.7.2.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-13"><span class="nav-number">1.7.2.2.</span> <span class="nav-text">说明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E6%B3%A8%E9%87%8A"><span class="nav-number">1.7.3.</span> <span class="nav-text">类注释</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-27"><span class="nav-number">1.7.3.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-14"><span class="nav-number">1.7.3.2.</span> <span class="nav-text">说明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%B3%A8%E9%87%8A"><span class="nav-number">1.7.4.</span> <span class="nav-text">函数注释</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-28"><span class="nav-number">1.7.4.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-15"><span class="nav-number">1.7.4.2.</span> <span class="nav-text">说明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E6%B3%A8%E9%87%8A"><span class="nav-number">1.7.5.</span> <span class="nav-text">变量注释</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-29"><span class="nav-number">1.7.5.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-16"><span class="nav-number">1.7.5.2.</span> <span class="nav-text">说明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%B3%A8%E9%87%8A"><span class="nav-number">1.7.6.</span> <span class="nav-text">实现注释</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-30"><span class="nav-number">1.7.6.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-17"><span class="nav-number">1.7.6.2.</span> <span class="nav-text">说明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E7%82%B9%E3%80%81%E6%8B%BC%E5%86%99%E5%92%8C%E8%AF%AD%E6%B3%95"><span class="nav-number">1.7.7.</span> <span class="nav-text">标点、拼写和语法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-31"><span class="nav-number">1.7.7.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-18"><span class="nav-number">1.7.7.2.</span> <span class="nav-text">说明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TODO%E6%B3%A8%E9%87%8A"><span class="nav-number">1.7.8.</span> <span class="nav-text">TODO注释</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-32"><span class="nav-number">1.7.8.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-19"><span class="nav-number">1.7.8.2.</span> <span class="nav-text">说明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%83%E7%94%A8%E6%B3%A8%E9%87%8A"><span class="nav-number">1.7.9.</span> <span class="nav-text">弃用注释</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-33"><span class="nav-number">1.7.9.1.</span> <span class="nav-text">总述</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F"><span class="nav-number">1.8.</span> <span class="nav-text">格式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%8C%E9%95%BF%E5%BA%A6"><span class="nav-number">1.8.1.</span> <span class="nav-text">行长度</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-34"><span class="nav-number">1.8.1.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-11"><span class="nav-number">1.8.1.2.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-11"><span class="nav-number">1.8.1.3.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%93%E8%AE%BA-11"><span class="nav-number">1.8.1.4.</span> <span class="nav-text">结论</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9EASCII%E5%AD%97%E7%AC%A6"><span class="nav-number">1.8.2.</span> <span class="nav-text">非ASCII字符</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-35"><span class="nav-number">1.8.2.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-20"><span class="nav-number">1.8.2.2.</span> <span class="nav-text">说明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A9%BA%E6%A0%BC%E8%BF%98%E6%98%AF%E5%88%B6%E8%A1%A8%E7%AC%A6"><span class="nav-number">1.8.3.</span> <span class="nav-text">空格还是制表符</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-36"><span class="nav-number">1.8.3.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-21"><span class="nav-number">1.8.3.2.</span> <span class="nav-text">说明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89"><span class="nav-number">1.8.4.</span> <span class="nav-text">函数声明和定义</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-37"><span class="nav-number">1.8.4.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-22"><span class="nav-number">1.8.4.2.</span> <span class="nav-text">说明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.8.5.</span> <span class="nav-text">Lambda表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-38"><span class="nav-number">1.8.5.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-23"><span class="nav-number">1.8.5.2.</span> <span class="nav-text">说明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="nav-number">1.8.6.</span> <span class="nav-text">函数调用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-39"><span class="nav-number">1.8.6.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-24"><span class="nav-number">1.8.6.2.</span> <span class="nav-text">说明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A0%BC%E5%BC%8F"><span class="nav-number">1.8.7.</span> <span class="nav-text">列表初始化格式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-40"><span class="nav-number">1.8.7.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-25"><span class="nav-number">1.8.7.2.</span> <span class="nav-text">说明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.8.8.</span> <span class="nav-text">条件语句</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-41"><span class="nav-number">1.8.8.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-26"><span class="nav-number">1.8.8.2.</span> <span class="nav-text">说明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E5%92%8C%E5%BC%80%E5%85%B3%E9%80%89%E6%8B%A9%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.8.9.</span> <span class="nav-text">循环和开关选择语句</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-42"><span class="nav-number">1.8.9.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-27"><span class="nav-number">1.8.9.2.</span> <span class="nav-text">说明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.8.10.</span> <span class="nav-text">指针和引用表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-43"><span class="nav-number">1.8.10.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-28"><span class="nav-number">1.8.10.2.</span> <span class="nav-text">说明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%83%E5%B0%94%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.8.11.</span> <span class="nav-text">布尔表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-44"><span class="nav-number">1.8.11.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-29"><span class="nav-number">1.8.11.2.</span> <span class="nav-text">说明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.8.12.</span> <span class="nav-text">函数返回类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-45"><span class="nav-number">1.8.12.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-30"><span class="nav-number">1.8.12.2.</span> <span class="nav-text">说明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E5%8F%8A%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.8.13.</span> <span class="nav-text">变量及数组初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-46"><span class="nav-number">1.8.13.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-31"><span class="nav-number">1.8.13.2.</span> <span class="nav-text">说明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4"><span class="nav-number">1.8.14.</span> <span class="nav-text">预处理指令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-47"><span class="nav-number">1.8.14.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-32"><span class="nav-number">1.8.14.2.</span> <span class="nav-text">说明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E6%A0%BC%E5%BC%8F"><span class="nav-number">1.8.15.</span> <span class="nav-text">类格式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-48"><span class="nav-number">1.8.15.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-33"><span class="nav-number">1.8.15.2.</span> <span class="nav-text">说明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="nav-number">1.8.16.</span> <span class="nav-text">构造函数初始化列表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-49"><span class="nav-number">1.8.16.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-34"><span class="nav-number">1.8.16.2.</span> <span class="nav-text">说明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="nav-number">1.8.17.</span> <span class="nav-text">命名空间格式化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-50"><span class="nav-number">1.8.17.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-35"><span class="nav-number">1.8.17.2.</span> <span class="nav-text">说明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B0%B4%E5%B9%B3%E7%95%99%E7%99%BD"><span class="nav-number">1.8.18.</span> <span class="nav-text">水平留白</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-51"><span class="nav-number">1.8.18.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-36"><span class="nav-number">1.8.18.2.</span> <span class="nav-text">说明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9E%82%E7%9B%B4%E7%95%99%E7%99%BD"><span class="nav-number">1.8.19.</span> <span class="nav-text">垂直留白</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-52"><span class="nav-number">1.8.19.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-37"><span class="nav-number">1.8.19.2.</span> <span class="nav-text">说明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%84%E5%88%99%E7%89%B9%E4%BE%8B"><span class="nav-number">1.9.</span> <span class="nav-text">规则特例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8E%B0%E6%9C%89%E4%B8%8D%E5%90%88%E8%A7%84%E8%8C%83%E4%BB%A3%E7%A0%81"><span class="nav-number">1.9.1.</span> <span class="nav-text">现有不合规范代码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-53"><span class="nav-number">1.9.1.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-38"><span class="nav-number">1.9.1.2.</span> <span class="nav-text">说明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Windows%E4%BB%A3%E7%A0%81"><span class="nav-number">1.9.2.</span> <span class="nav-text">Windows代码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0-54"><span class="nav-number">1.9.2.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-39"><span class="nav-number">1.9.2.2.</span> <span class="nav-text">说明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A5%E8%87%AAGoogle%E7%9A%84%E5%A5%87%E7%89%B9%EF%BC%88Cpplint%EF%BC%89"><span class="nav-number">1.10.</span> <span class="nav-text">来自Google的奇特（Cpplint）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%80%E6%9C%89%E6%9D%83%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">1.10.1.</span> <span class="nav-text">所有权与智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#gt-%E6%80%BB%E8%BF%B0"><span class="nav-number">1.10.1.1.</span> <span class="nav-text">&gt; 总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#gt-%E5%AE%9A%E4%B9%89"><span class="nav-number">1.10.1.2.</span> <span class="nav-text">&gt; 定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#gt-%E4%BC%98%E7%82%B9"><span class="nav-number">1.10.1.3.</span> <span class="nav-text">&gt; 优点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#gt-%E7%BC%BA%E7%82%B9"><span class="nav-number">1.10.1.4.</span> <span class="nav-text">&gt; 缺点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#gt-%E7%BB%93%E8%AE%BA"><span class="nav-number">1.10.1.5.</span> <span class="nav-text">&gt; 结论</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Cpplint"><span class="nav-number">1.10.2.</span> <span class="nav-text">Cpplint</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#gt-%E6%80%BB%E8%BF%B0-1"><span class="nav-number">1.10.2.1.</span> <span class="nav-text">&gt; 总述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#gt-%E8%AF%B4%E6%98%8E"><span class="nav-number">1.10.2.2.</span> <span class="nav-text">&gt; 说明</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Javy"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Javy</p>
  <div class="site-description" itemprop="description">You can create art and beauty on a computer.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">74</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/javyxu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;javyxu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>


      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2018 - 2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Javy</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : 'de44f4e91f73c590197c',
      clientSecret: '840b907d657247c9ddcbcec968b641fda5d3b969',
      repo        : 'javyxu.github.io',
      owner       : 'javyxu',
      admin       : ['javyxu'],
      id          : 'eda9081d3e19453cb12cf7ba2ee31be9',
      proxy       : 'https://netnr-proxy.cloudno.de/https://github.com/login/oauth/access_token',
        language: 'en',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
