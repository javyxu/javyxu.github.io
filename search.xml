<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++ Style of Google</title>
    <url>/c++/c++_style_of_google/</url>
    <content><![CDATA[<h2 id="C-风格规范（Google版）"><a href="#C-风格规范（Google版）" class="headerlink" title="C++风格规范（Google版）"></a>C++风格规范（Google版）</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><h4 id="Self-contained头文件"><a href="#Self-contained头文件" class="headerlink" title="Self-contained头文件"></a>Self-contained头文件</h4><p>所有头文件要能够自给自足。即：用户和重工具不需要为特别场合而包含额外的头文件。</p>
<h4 id="defined保护"><a href="#defined保护" class="headerlink" title="#defined保护"></a>#defined保护</h4><p>所有头文件都应该使用#define来防止头文件被多重包含，命名格式是<font color=red><code>&lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H</code></font>。<br>为保证唯一性，头文件的命名应该基于所在项目源代码树的全路径。</p>
<h4 id="前置声明"><a href="#前置声明" class="headerlink" title="前置声明"></a>前置声明</h4><p>尽可能地避免使用前置声明。使用<font color=red><code>#include</code></font>包含需要的头文件即可。</p>
<h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>所谓<code>前置声明（forward declaration）</code>是类、函数和模板的纯粹声明，没伴随着其定义。</p>
<h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ul>
<li>前置声明能够节省编译时间，多余的<font color=red><code>#include</code></font>会迫使编译器展开更多的文件，处理更多的输入。</li>
<li>前置声明能够节省不必要的重新编译的时间。<font color=red><code>#inclue</code></font>使代码因头文件中无关的改动而被重新编译多次。</li>
</ul>
<h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ul>
<li>前置声明隐依赖关系，头文件改动时，用户的代码会跳过必要的重新编译过程。</li>
<li>前置声明可能会被库的后续更改所破坏。前置声明函数或模板有时会妨碍头文件开发者变动其API。</li>
<li>前置声明来自命名空间<font color=red><code>std::</code></font>的symbol时，其行为未定义。</li>
<li>很难判断什么时候该用前置声明，什么时候该用<font color=red><code>#include</code></font>。极端情况下，用前置声明代替<font color=red><code>inclues</code></font>甚至都会暗暗地改变代码的含义。</li>
<li>前置声明不少来自头文件的symbol时，就会比单单一行的<font color=red><code>include</code></font>冗长。</li>
<li>仅仅为了前置声明而重构代码，会使代码变得更慢更复杂。</li>
</ul>
<h5 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h5><ul>
<li>尽量避免前置声明那些定义在其他项目中的实体。</li>
<li>函数：总是使用<font color=red><code>#include</code></font></li>
<li>类模板：优先使用<font color=red><code>#include</code></font></li>
</ul>
<a id="more"></a>

<h4 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h4><p>只有当函数只有10行甚至更少时才将其定义为内联函数。</p>
<h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h5><p>当函数被声明为内联函数之后，编译器会将其内联展开，而不是按通常的函数调用机制进行调用。</p>
<h5 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h5><p>只要内联函数体较小，内联函数可以令目标代码更加高效。对于存取函数以及其他函数体比较短，性能关键的函数，鼓励使用内联。</p>
<h5 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h5><p>滥用内联函数导致程序变得更慢。内联可能使目标代码量或增或减，这取决于内联函数的大小。内联非常短小的存取函数通常会减少代码大小，但内联一个相当大得函数将戏剧性的增加代码大小。现代处理器由于更好的利用了指令缓存，小巧的代码往往执行更快。</p>
<h5 id="结论：-1"><a href="#结论：-1" class="headerlink" title="结论："></a>结论：</h5><ul>
<li>内联函数不要超过10行。谨慎对待析构函数，析构函数往往比其他表面看起来更长，因为有隐含的成员和基类析构函数被调用。</li>
<li>内联那些包含循环或<font color=red><code>switch</code></font>语句的函数常常是得不偿失。<br>有些函数即使声明为内联的也不一定会被编译内联。必须虚函数和递归函数就不会被正常内联。通常，递归函数不应该声明成内联函数。</li>
</ul>
<h4 id="include路径及顺序"><a href="#include路径及顺序" class="headerlink" title="#include路径及顺序"></a>#include路径及顺序</h4><p>使用标准的头文件包含顺序可增强可读性，避免隐藏依赖：相关头文件，C库、C++库，其他库的.h，本项目内的.h。<br>项目头文件应该按照项目源代码目录树结构排列，避免使用unix特殊的快捷目录<code>.</code>(当前目录)或<code>..</code>（上级目录）。</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p>鼓励在<font color=red><code>.cc</code></font>文件使用匿名命名空间或<font color=red><code>static</code></font>声明。使用具名的命名空间时，其名称可基于项目名或相对路径。精致使用using表示（using-directive）。禁止使用内联命名空间（inline namespace）。</p>
<h5 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h5><p>命名空间将全局作用域细分为独立的，具名的作用域，可有效防止全局作用域的命名冲突。</p>
<h5 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h5><p>虽然类已经提供了命名轴线，命名空间在这基础上又封装了一层。<br>内联命名空间会自动把内部的标识符放到外层作用域。</p>
<h5 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h5><p>命名空间具有迷惑性，因为它们使得区分两个相同命名所指代的定义更加困难。<br>内联命名空间很容易令人迷惑，毕竟其内部的成员不再受其声明所在命名空间的限制。内联命名空间只在大型版本控制里有用。<br>有时候不得不多次引用某个定义在许多嵌套命名空间里的实体，使用完整的命名空间会导致代码的冗长。<br>在头文件中使用匿名空间导致违背C++的唯一定义原则（One Definition Rule（ODR））。</p>
<h5 id="结论：-2"><a href="#结论：-2" class="headerlink" title="结论："></a>结论：</h5><ul>
<li>遵守命名空间命名的原则</li>
<li>在命名空间的最后注释出命名空间的名字</li>
<li>用命名空间把文件包含，gflags的声明/定义，以及类的前置声明以外的整个源文件封装起来，1以区别于其它命名空间</li>
<li>不要在命名空间<font color=red><code>std</code></font>内声明任何东西，包括标准库的类前置声明。在<font color=red><code>std</code></font>命名空间声明实体是未定义的行为，会导致如不可移植。声明标准库下的实体，需要包含对应的头文件。</li>
<li>不应该使用<em>using</em>指示引入整个命名空间的标识符号。</li>
<li>不要在头文件中使用<em>命名空间别名</em> 除非显式标记内部命名空间使用。因为任何在头文件中引入的命名空间都会成为公开API的一部分。</li>
<li>禁止使用内联命名空间。</li>
</ul>
<h4 id="匿名命名空间和静态变量"><a href="#匿名命名空间和静态变量" class="headerlink" title="匿名命名空间和静态变量"></a>匿名命名空间和静态变量</h4><p>在<font color=red><code>.cc</code></font>文件中定义一个不需要被外部引用的变量时，可以将它们放在匿名命名空间或声明为<font color=red><code>static</code></font>。但是不要在<font color=red><code>.h</code></font>文件中这么做。</p>
<h5 id="定义：-2"><a href="#定义：-2" class="headerlink" title="定义："></a>定义：</h5><p>所有置于匿名命名空间的声明都具有内部链接性，函数和变量可以经由声明为<font color=red><code>static</code></font>拥有内部链接性，这意味着你在这个文件中声明的这些标识符都不能在另一个文件中被访问。即使两个文件声明了完全一样名字的标识符，它们所指向的实体实际上是完全不同的。</p>
<h5 id="结论：-3"><a href="#结论：-3" class="headerlink" title="结论："></a>结论：</h5><p>推荐、鼓励在<font color=red><code>.cc</code></font>中对于不需要在其他地方引用的标识符使用内部链接性声明，但是不要在<font color=red><code>.h</code></font>中使用。</p>
<p>匿名命名空间的声明和具名的格式相同，在最后注释上<code>namespace</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;  <span class="comment">//namespace</span></span><br></pre></td></tr></table></figure>
<h4 id="非成员函数、静态成员函数和全局函数"><a href="#非成员函数、静态成员函数和全局函数" class="headerlink" title="非成员函数、静态成员函数和全局函数"></a>非成员函数、静态成员函数和全局函数</h4><p>使用静态成员函数或命名空间内的非成员函数，尽量不要用裸的全局函数。将一系列函数直接置于命名空间中，不要用类的静态方法模拟出命名空间的效果，类的静态方法应当和类的实例或静态数据紧密相关。</p>
<h5 id="优点：-3"><a href="#优点：-3" class="headerlink" title="优点："></a>优点：</h5><p>某些情况下，非成员函数和静态成员函数是非常有用的，将非成员函数放在命名空间内可避免污染全局作用域。</p>
<h5 id="缺点：-3"><a href="#缺点：-3" class="headerlink" title="缺点："></a>缺点：</h5><p>将非成员函数和静态成员函数作为新类的成员函数作为新类的成员或许更有意义。当它们需要访问外部资源或具有重要的依赖关系时更是如此。</p>
<h5 id="结论：-4"><a href="#结论：-4" class="headerlink" title="结论："></a>结论：</h5><p>有时, 把函数的定义同类的实例脱钩是有益的, 甚至是必要的. 这样的函数可以被定义成静态成员, 或是非成员函数. 非成员函数不应依赖于外部变量, 应尽量置于某个命名空间内. 相比单纯为了封装若干不共享任何静态数据的静态成员函数而创建类。</p>
<p>定义在同一编译单元的函数, 被其他编译单元直接调用可能会引入不必要的耦合和链接时依赖; 静态成员函数对此尤其敏感. 可以考虑提取到新类中, 或者将函数置于独立库的命名空间内.</p>
<p>如果必须定义非成员函数, 又只是在<font color=red><code>.cc</code></font>文件中使用它, 可使用<code>匿名命名空间</code>或<font color=red><code>static</code></font>链接关键字 (如<font color=red><code>static int Foo() &#123;...&#125;</code></font>) 限定其作用域.</p>
<h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化。</p>
<p>C++允许在函数的任何位置声明变量。我们提倡在尽可能小的作用域中声明变量, 离第一次使用越近越好。 这使得代码浏览者更容易定位变量声明的位置, 了解变量的类型和初始值。特别是，应使用初始化的方式替代声明再赋值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> j = g(); <span class="comment">//初始化声明</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">1</span>); <span class="comment">//用花括号初始化更好</span></span><br><span class="line">v.push_back(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>属于<code>if</code>,<code>while</code>和<code>for</code>语句的变量应当在这些语句中正常地声明，这样子这些变量的作用域就被限制在这些语句中了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">const</span> <span class="keyword">char</span>* p = <span class="built_in">strchr</span>(str, <span class="string">&#x27;/&#x27;</span>)) strr = p + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><strong>注：</strong>有一个例外, 如果变量是一个对象, 每次进入作用域都要调用其构造函数, 每次退出作用域都要调用其析构函数. 这会导致效率降低。</p>
<h4 id="静态和全局变量"><a href="#静态和全局变量" class="headerlink" title="静态和全局变量"></a>静态和全局变量</h4><p>禁止定义静态储存周期非POD变量，禁止使用含有副作用的函数初始化POD全局变量，因为多编译单元中的静态变量执行时的构造和析构顺序是未明确的，这将导致代码的不可移植。</p>
<p>禁止使用类的<code>静态储存周期</code>变量：由于构造和析构函数调用顺序的不确定性，它们会导致难以发现的 bug 。不过<code>constexpr</code>变量除外，毕竟它们又不涉及动态初始化或析构。</p>
<p>静态生存周期的对象，即包括了全局变量，静态变量，静态类成员变量和函数静态变量，都必须是原生数据类型 (POD : Plain Old Data): 即 int, char 和 float, 以及 POD 类型的指针、数组和结构体。</p>
<p>静态变量的构造函数、析构函数和初始化的顺序在C++中是只有部分明确的，甚至随着构建变化而变化，导致难以发现的bug. 所以除了禁用类类型的全局变量，我们也不允许用函数返回值来初始化POD变量，除非该函数（比如<code>getenv()</code>或<code>getpid()</code>）不涉及任何全局变量。函数作用域里的静态变量除外，毕竟它的初始化顺序是有明确定义的，而且只会在指令执行到它的声明那里才会发生。</p>
<p>同理，全局和静态变量在程序中断时会被析构，无论所谓中断是从<code>main()</code>返回还是对<code>exit()</code>的调用。析构顺序正好与构造函数调用的顺序相反。但既然构造顺序未定义，那么析构顺序当然也就不定了。比如，在程序结束时某静态变量已经被析构了，但代码还在跑——比如其它线程——并试图访问它且失败；再比如，一个静态 string 变量也许会在一个引用了前者的其它变量析构之前被析构掉。</p>
<p>改善以上析构问题的办法之一是用<code>quick_exit()</code>来代替<code>exit()</code>并中断程序。它们的不同之处是前者不会执行任何析构，也不会执行<code>atexit()</code>所绑定的任何handlers. 如果您想在执行<code>quick_exit()</code>来中断时执行某handler（比如刷新log），您可以把它绑定到<code>_at_quick_exit()</code>. 如果您想在<code>exit()</code>和<code>quick_exit()</code>都用上该handler, 都绑定上去。</p>
<p>综上所述，我们只允许POD类型的静态变量，即完全禁用<code>vector</code>(使用C数组替代)和<code>string</code>(使用 <code>const char []</code>)。</p>
<p>如果您确实需要一个<code>class</code>类型的静态或全局变量，可以考虑在<code>main()</code>函数或<code>pthread_once()</code>内初始化一个指针且永不回收。注意只能用 raw 指针，别用智能指针，毕竟后者的析构函数涉及到上文指出的不定顺序问题。</p>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>类是C++中代码的基本单元。</p>
<h4 id="构造函数的职责"><a href="#构造函数的职责" class="headerlink" title="构造函数的职责"></a>构造函数的职责</h4><h5 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h5><p>不要在构造函数中调用虚函数，也不要在无法报出错误时进行可能失败的初始化。</p>
<h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p>在构造函数中可以进行各种初始化操作。</p>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul>
<li>无需考虑类是否被初始化</li>
<li>经过构造函数完全初始化后的对象可以为<code>const</code>类型，也能更方便地被标准容器或算法使用。</li>
</ul>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>如果在构造函数内调用了自身的虚函数, 这类调用是不会重定向到子类的虚函数实现. 即使当前没有子类化实现, 将来仍是隐患。</li>
<li>在没有使程序崩溃 (因为并不是一个始终合适的方法) 或者使用异常 (因为已经被 禁用 了) 等方法的条件下, 构造函数很难上报错误。</li>
<li>如果执行失败, 会得到一个初始化失败的对象, 这个对象有可能进入不正常的状态, 必须使用<code>bool isValid()</code>或类似这样的机制才能检查出来, 然而这是一个十分容易被疏忽的方法。</li>
<li>构造函数的地址是无法被取得的, 因此, 举例来说, 由构造函数完成的工作是无法以简单的方式交给其他线程的。</li>
</ul>
<h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><p>构造函数不允许调用虚函数. 如果代码允许, 直接终止程序是一个合适的处理错误的方式。否则, 考虑用<code>Init()</code>方法或工厂函数。</p>
<p>构造函数不得调用虚函数, 或尝试报告一个非致命错误。如果对象需要进行有意义的(non-trivial)初始化, 考虑使用明确的<code>Init()</code>方法或使用工厂模式. Avoid Init() methods on objects with no other states that affect which public methods may be called(此类形式的半构造对象有时无法正确工作)。</p>
<h4 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h4><h5 id="总述-1"><a href="#总述-1" class="headerlink" title="总述"></a>总述</h5><p>不要定义隐式类型转换。对于转换运算符和单参数构造函数，请使用<code>explicit</code>关键字。</p>
<h5 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h5><p>隐式类型转换允许一个某种类型(源类型)的对象被用于需要另一种类型(目的类型)的位置。<br>除了语言所定义的隐式类型转换，用户还可以通过在类定义中添加合适的成员定义自己需要的转换。在源类型中定义的隐式类型转换，可以通过目的的类型名的类型转换运算符实现(<code>operator bool()</code>)。在目的类型中定义隐式类型转换，泽通过以源类型作为其唯一参数(或唯一无默认值的参数)的构造函数实现。</p>
<p><code>explicit</code>关键字可以用于构造函数或类型转换运算符，以保证只有当目的类型在调用点被显示写明时才能进行类型转换。例如<code>cast</code>。这不仅用于隐式类型转换，还能作用于C++11的初始化语法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">double</span> y)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(Foo, f)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li>有时目的类型名是一目了然的，通过避免显示地写出类型名，隐式类型转换可以让一个类型的可用性和表达性更强。</li>
<li>隐式类型转换可以简单地取代函数重载。</li>
<li>在初始化对象时，列表初始化语法是一种简洁明了的写法。</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>隐式类型转换会隐藏不匹配的错误，有时，目的类型并不符合用户的期望，甚至用户根本没有意识到发生了类型转换。</li>
<li>隐式类型转换会让代码难以阅读, 尤其是在有函数重载的时候, 因为这时很难判断到底是哪个函数被调用。</li>
<li>单参数构造函数有可能会被无意地用作隐式类型转换。</li>
<li>如果单参数构造函数没有加上<font color=red><code>explicit</code></font>关键字, 读者无法判断这一函数究竟是要作为隐式类型转换, 还是作者忘了加上<font color=red><code>explicit</code></font>标记。</li>
<li>并没有明确的方法用来判断哪个类应该提供类型转换, 这会使得代码变得含糊不清。</li>
<li>如果目的类型是隐式指定的, 那么列表初始化会出现和隐式类型转换一样的问题, 尤其是在列表中只有一个元素的时候。</li>
</ul>
<h5 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h5><p>在类型定义中, 类型转换运算符和单参数构造函数都应当用<code>explicit</code>进行标记。一个例外是, 拷贝和移动构造函数不应当被标记为<code>explicit</code>, 因为它们并不执行类型转换。对于设计目的就是用于对其他类型进行透明包装的类来说, 隐式类型转换有时是必要且合适的。这时应当联系项目组长并说明特殊情况.</p>
<p>不能以一个参数进行调用的构造函数不应当加上<font color=red><code>explicit</code></font>。接受一个<font color=red><code>std::initializer_list</code></font>作为参数的构造函数也应当省略,<font color=red><code>explicit</code></font> 以便支持拷贝初始化(例如<font color=red><code>MyType m = &#123;1, 2&#125;;</code></font>)。</p>
<h4 id="可拷贝类型和可移动类型"><a href="#可拷贝类型和可移动类型" class="headerlink" title="可拷贝类型和可移动类型"></a>可拷贝类型和可移动类型</h4><h4 id="总述-2"><a href="#总述-2" class="headerlink" title="总述"></a>总述</h4><p>如果你的类型需要，就让它们指出拷贝/移动，否则，就把隐式产生的拷贝和移动函数禁用。</p>
<h5 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h5><p>可拷贝类型允许对象在初始化时得到来自相同类型的另一对象的值, 或在赋值时被赋予相同类型的另一对象的值, 同时不改变源对象的值。对于用户定义的类型, 拷贝操作一般通过拷贝构造函数与拷贝赋值操作符定义. <font color=red><code>string</code></font>类型就是一个可拷贝类型的例子。</p>
<p>可移动类型允许对象在初始化时得到来自相同类型的临时对象的值, 或在赋值时被赋予相同类型的临时对象的值 (因此所有可拷贝对象也是可移动的)。<font color=red><code>std::unique_ptr&lt;int&gt;</code></font>就是一个可移动但不可复制的对象的例子。对于用户定义的类型, 移动操作一般是通过移动构造函数和移动赋值操作符实现的。</p>
<p>拷贝 / 移动构造函数在某些情况下会被编译器隐式调用. 例如, 通过传值的方式传递对象。</p>
<h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><p>可移动及可拷贝类型的对象可以通过传值的方式进行传递或者返回, 这使得API更简单, 更安全也更通用。 与传指针和引用不同, 这样的传递不会造成所有权, 生命周期, 可变性等方面的混乱, 也就没必要在协议中予以明确。这同时也防止了客户端与实现在非作用域内的交互, 使得它们更容易被理解与维护。这样的对象可以和需要传值操作的通用API一起使用, 例如大多数容器。</p>
<p>拷贝/移动构造函数与赋值操作一般来说要比它们的各种替代方案, 比如<font color=red><code>Clone()</code></font>, <font color=red><code>CopyFrom()</code></font> or <font color=red><code>Swap()</code></font>, 更容易定义, 因为它们能通过编译器产生, 无论是隐式的还是通过<font color=red><code>= default</code></font>。 这种方式很简洁, 也保证所有数据成员都会被复制. 拷贝与移动构造函数一般也更高效, 因为它们不需要堆的分配或者是单独的初始化和赋值步骤, 同时, 对于类似 省略不必要的拷贝 这样的优化它们也更加合适。</p>
<p>移动操作允许隐式且高效地将源数据转移出右值对象. 这有时能让代码风格更加清晰。</p>
<h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><p>许多类型都不需要拷贝, 为它们提供拷贝操作会让人迷惑, 也显得荒谬而不合理. 单件类型 (<font color=red><code>Registerer</code></font>), 与特定的作用域相关的类型 (<font color=red><code>Cleanup</code></font>), 与其他对象实体紧耦合的类型 (<font color=red><code>Mutex</code></font>) 从逻辑上来说都不应该提供拷贝操作. 为基类提供拷贝 / 赋值操作是有害的, 因为在使用它们时会造成 对象切割。默认的或者随意的拷贝操作实现可能是不正确的, 这往往导致令人困惑并且难以诊断出的错误。</p>
<p>拷贝构造函数是隐式调用的, 也就是说, 这些调用很容易被忽略. 这会让人迷惑, 尤其是对那些所用的语言约定或强制要求传引用的程序员来说更是如此. 同时, 这从一定程度上说会鼓励过度拷贝, 从而导致性能上的问题。</p>
<h5 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h5><p>如果需要就让你的类型可拷贝/可移动. 作为一个经验法则, 如果对于你的用户来说这个拷贝操作不是一眼就能看出来的, 那就不要把类型设置为可拷贝。如果让类型可拷贝, 一定要同时给出拷贝构造函数和赋值操作的定义, 反之亦然。如果让类型可拷贝, 同时移动操作的效率高于拷贝操作, 那么就把移动的两个操作 (移动构造函数和赋值操作) 也给出定义。如果类型不可拷贝, 但是移动操作的正确性对用户显然可见, 那么把这个类型设置为只可移动并定义移动的两个操作。</p>
<p>如果定义了拷贝/移动操作, 则要保证这些操作的默认实现是正确的. 记得时刻检查默认操作的正确性, 并且在文档中说明类是可拷贝的且/或可移动的。</p>
<p>由于存在对象切割的风险, 不要为任何有可能有派生类的对象提供赋值操作或者拷贝 / 移动构造函数 (当然也不要继承有这样的成员函数的类). 如果你的基类需要可复制属性, 请提供一个 <font color=red><code>public virtual Clone()</code></font> 和一个 <font color=red><code>protected</code></font> 的拷贝构造函数以供派生类实现。</p>
<p>如果你的类不需要拷贝/移动操作, 请显式地通过在 <font color=red><code>public</code></font> 域中使用 <font color=red><code>= delete</code></font> 或其他手段禁用之。</p>
<h4 id="结构体和类"><a href="#结构体和类" class="headerlink" title="结构体和类"></a>结构体和类</h4><h5 id="总述-3"><a href="#总述-3" class="headerlink" title="总述"></a>总述</h5><p>仅当只有数据成员时使用<font color=red><code>struct</code></font>,其它一概使用<font color=red><code>calss</code></font>。</p>
<h5 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h5><p>在C++中<font color=red><code>struct</code></font>和<font color=red><code>calss</code></font>关键字几乎含义一样。我们为这两个关键字添加我们自己的语义理解，以便为定义的数据类型选择合适的关键字。</p>
<p><code>struct</code><font color=red></font>用来定义包含数据的被动式对象，也可以包含相关的常量，但除了存取数据成员之外，没有别的函数功能。并且存取功能是通过直接访问位域，而非函数调用。除了构造函数、析构函数，<font color=red><code>Initialize</code></font>、<font color=red><code>Reset</code></font>，<font color=red><code>Validate</code></font>等类似的用于设定数据成员的函数，不能提供其它功能的函数。</p>
<p>如果需要更多的函数功能，<font color=red><code>class</code></font>更适合。如果拿不准，就用<font color=red><code>class</code></font>。</p>
<p>为了和STL保持一致，对于仿函数等特性可以不用<font color=red><code>class</code></font>而使用<font color=red><code>struct</code></font>。</p>
<p>注意：类和结构体的成员变量使用不同的<a href="">命名规则</a>。</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><h5 id="总述-4"><a href="#总述-4" class="headerlink" title="总述"></a>总述</h5><p>使用组合常常比使用继承更合适。如果使用继承的话，定义为<font color=red><code>public</code></font>继承。</p>
<h5 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h5><p>当子类继承基类时，子类包含了父基类所有的数据以及操作的定以。C++实践中，继承主要用于两种场合：实现继承，子类继承父类的实现代码；接口继承，子类仅继承父类的方法名称。</p>
<h5 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h5><p>实现继承通过原封不动的复用基类代码减少了代码量。由于继承是在编译时声明，程序员和编译器都可以理解相应操作并发现错误。从编程角度而言，接口继承是用来强制类输出特定的API。在类没有实现API中某个必须的方法，编译器同样会发现并报告错误。</p>
<h5 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h5><p>对于实现继承，由于子类的实现代码散布在父类和子类之间，要理解其实现变得更加困难。子类不能重写父类的非虚函数，当然也就不能修改其实现。基类也可能定义了一些函数成员，因此还必须区分基类的实现布局。</p>
<h5 id="结论-3"><a href="#结论-3" class="headerlink" title="结论"></a>结论</h5><p>所有继承必须是<font color=red><code>public</code></font>。如果你想要使用私有继承，你应该替换成把基类的实例作为成员对象的方式。</p>
<p>不要过度使用实现继承。组合常常更适合一些，尽量做到只在“是一个”（”is-a”）的情况下使用继承：如果<font color=red><code>bar</code></font>的确“是一种”<font color=red><code>Foo</code></font>，<font color=red><code>bar</code></font>才能继承<font color=red><code>Foo</code></font>。</p>
<p>必要的话，析构函数声明为<font color=red><code>virtual</code></font>。如果你的类有虚函数，则析构函数也应该为虚函数。</p>
<p>对于可能被子类访问的成员函数，不要过度使用<font color=red><code>protected</code></font>关键字。注意，数据成员都必须是<a href="">私有的</a>。</p>
<p>对于重载的虚函数或析构函数，使用<font color=red><code>override</code></font>，或<font color=red><code>final</code></font>关键字显示地进行标记。较早的代码可能使用<font color=red><code>virtual</code></font>关键字作为不得已的选项。因此，在声明重载时，请使用<font color=red><code>override</code></font>、<font color=red><code>final</code></font>、<font color=red><code>virtual</code></font>中其中之一进行标记。标记为<font color=red><code>override</code></font>或<font color=red><code>final</code></font>的析构函数如果不是对基类虚函数的重载的话，编译会报错。这有助于捕获常见的错误。这些标记起到了文档的作用，因为如果省略这些关键字，代码阅读者不得不检查所有父类，以判断该杉树是否是虚函数。</p>
<h4 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h4><h5 id="总述-5"><a href="#总述-5" class="headerlink" title="总述"></a>总述</h5><p>真正需要到多重实现继承的情况少之又少。只在一下情况下才允许多重继承：最多只有一个基类是非抽象类；其他基类都是以<font color=red><code>Interface</code></font>后缀的<a href="">纯接口类</a>。</p>
<h5 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h5><p>多重继承允许子类拥有多个基类。要将作为<em>纯接口</em>的基类和具有<em>实现</em>的基类区别开来。</p>
<h5 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h5><p>相比单继承，多重实现继承可以复用更多的代码。</p>
<h5 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h5><p>真正需要用到多重<em>实现</em>继承的情况少之又少。有时多重实现继承看上去是不错的解决方案，但这是你通常可以找到一个更明确、更清晰的不同解决方案。</p>
<h5 id="结论-4"><a href="#结论-4" class="headerlink" title="结论"></a>结论</h5><p>只有当所有父类除第一个外都是<a href="">纯接口类</a>时，才允许使用多重继承。为确保它们是纯接口，这些类必须以<font color=red><code>Interface</code></font>为后缀。</p>
<p><strong>注意</strong></p>
<p>关于该规则，Windows下有个<a href="">特例</a>。</p>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><h5 id="总述-6"><a href="#总述-6" class="headerlink" title="总述"></a>总述</h5><p>接口是指满足特定条件的类，这些类以<font color=red><code>Interface</code></font>为后缀（不强制）。</p>
<h5 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h5><p>当一个类满足以下要求时，称之为纯接口：</p>
<ul>
<li>只有纯虚函数（“<font color=red><code>=0</code></font>”）和静态函数（除了析构函数）。</li>
<li>没有非静态数据成员。</li>
<li>没有定义任何构造函数。如果有，也不能带有参数，并且必须为<font color=red><code>protected</code></font>。</li>
<li>如果它是一个子类，也只能从满足上述条件并以<font color=red><code>Interface</code></font>为后缀的类继承。</li>
</ul>
<p>接口类不能直接被实例化，因为它声明了纯虚函数。为确保接口类的所有实现可被正确销毁，必须为之声明析构函数。</p>
<h5 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h5><p>以<font color=red><code>Interface</code></font>为后缀可以提醒其他人不要为该接口类增加杉树实现或非静态数据成员。这一点对于<a href="">多重继承</a>尤其重要。另外。对于Java程序员来说，接口的概念已是深入人心。</p>
<h5 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h5><p><code>Interface</code>后缀增加了类名长度，为阅读和理解带来不便。同时，接口属性作为实现细节不应暴露给用户。</p>
<h5 id="结论-5"><a href="#结论-5" class="headerlink" title="结论"></a>结论</h5><p>只有在满足上述条件时，类才以<font color=red><code>Interface</code></font>结尾，但反过来，满足上述需要类未必一定以<font color=red><code>Interface</code></font>结尾。</p>
<h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><h5 id="总述-7"><a href="#总述-7" class="headerlink" title="总述"></a>总述</h5><p>除少数特定环境外，不要重载运算符。也不要创建用户定义字面量。</p>
<h5 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h5><p>C++允许用户通过使用<font color=red><code>operator</code></font>关键字<a href="">对内建运算符进行重新定义</a>，只要其中一个参数是用户定义的类型。<font color=red><code>operator</code></font>关键字还允许用户使用<font color=red><code>operator&quot;&quot;</code></font>定义新的字面运算符，并且定义类型转换函数，例如<font color=red><code>operator bool()</code></font>。</p>
<h5 id="优点-6"><a href="#优点-6" class="headerlink" title="优点"></a>优点</h5><p>重载运算符可以让代码更简洁易懂，也使得用户定义的类型和内建类型拥有相似的行为。重载运算符对于某些运算来说是符合符合语言习惯的名称(例如<font color=red><code>==</code></font>、<font color=red><code>&lt;</code></font>, <font color=red><code>=</code></font>, <font color=red><code>&lt;&lt;</code></font>)，遵循这些语言约定可以让用户定义的类型更易读，也能更好地和需要这些重载运算符的函数库进行交互操作。</p>
<p>对于创建用户定义的类型的对象来说，用户定义字面量是一种非常简洁的标记。</p>
<h5 id="缺点-6"><a href="#缺点-6" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>要提供正确、一致，不出现异常行为的操作符运算需要花费不少精力，而且如果达不到这些要求的话，会导致令人迷惑的bug。</li>
<li>过度使用运算符会带来难以理解的代码，尤其是在重载的操作符的语义与通常的约定不符合时。</li>
<li>函数重载有多少弊端，运算符重载就至少有多少。</li>
<li>运算符重载会混淆试，让你误以为一些好使的操作和操作内建类型一样轻巧。</li>
<li>对重载运算符的调用点的查找需要的可就不仅仅是像grep那样的程序了，这时需要能够理解C++ 语法的搜索工具。</li>
<li>对重载运算符的参数参数写错，此时得到的可能是一个完全不同的重载而非编译错误。例如：<br><font color=red><code>foo &lt; bar</code></font>执行的是一个行为，而<font color=red><code>&amp;foo &lt; &amp;bar</code></font>执行的就是完全不同的另一个行为了。</li>
<li>重载某些运算符本身就是有害的。例如，重载一元运算符<font color=red><code>&amp;</code></font>会导致同样的代码有完全不同的含义，这取决于重载的声明对某段代码而言是否是可见的。重载诸如<font color=red><code>&amp;&amp;</code></font>, <font color=red><code>||</code></font>和<font color=red><code>，</code></font>会导致运算顺序和内建运算的顺序不一致。</li>
<li>运算符从通常定义在类的外部，所以对于同一运算，可能出现不同的文件引入了不同的定义的风险。如果两种定义都链接到同一二进制文件，就会导致未定义的行为，有可能表现为难以发现的运行时错误。</li>
<li>用户定义字面量所创建的语义形式对于某些有经验的 C++ 程序员来说都是很陌生的。</li>
</ul>
<h5 id="结论-6"><a href="#结论-6" class="headerlink" title="结论"></a>结论</h5><p>只有在意义明显，不会出现奇怪的行为并且与对应的内建运算符的行为一致时才定义重载运算符。例如，<font color=red><code>|</code></font>要作为位或或逻辑或来使用，而不是作为shell中的管道。</p>
<p>只有对用户自己定义的类型重载运算符。更准确地说，将它们和它们所操作的类型定义在同一个头文件中，<font color=red><code>.cc</code></font>中和命名空间中。这样做无论类型在哪里都能够使用定义的运算符，并且最大程度上避免了多重定义的风险。如果可能的话，请避免将运算符定义为模板，因为此时它们必须对任何模板参数都能够作用。如果你定义了一个运算符，请将其相关且有意义的运算符都进行定义，并且保证这些定义的语义是一致的。例如，如果你重载了<font color=red><code>&lt;</code></font>，那么请将所有的比较运算符都进行重载，并且保证对于同一组参数，<font color=red><code>&lt;</code></font>和<font color=red><code>&gt;</code></font>不会同时返回<font color=red><code>true</code></font>。</p>
<p>建议不要将不进行修改的二元运算符定义为成员函数。如果一个二元运算符被定义为类成员，这时隐式转换会作用域右侧的参数却不会作用于左侧。这时会出现<font color=red><code>a &lt; b</code></font> 能够通过编译而<font color=red><code>b &lt; a</code></font>不能的情况，这是很让人迷惑的。</p>
<p>不要为了避免重载操作符而走极端。比如说，应当定义 <font color=red><code>==</code></font>, <font color=red><code>=</code></font>, 和<font color=red><code>&lt;&lt;</code></font>而不是<font color=red><code>Equals()</code></font>， <font color=red><code>CopyFrom()</code></font>和<font color=red><code>PrintTo()</code></font>。反过来说，不要只是为了满足函数库需要而去定义运算符重载。比如说，如果你的类型没有自然顺序，而你要将它们存入<font color=red><code>std::set</code></font>中，最好还是定义一个自定义的比较运算符而不是重载 <font color=red><code>&lt;</code></font>。</p>
<p>不要重载<font color=red><code>&amp;&amp;</code></font>, <font color=red><code>||</code></font>，<font color=red><code>,</code></font> 或一元运算符<font color=red><code>&amp;</code></font>。不要重载 <font color=red><code>operator&quot;&quot;</code></font>，也就是说，不要引入用户定义字面量。</p>
<p>类型转换运算符在<a href="">隐式类型转换</a>一节有提及。<font color=red><code>=</code></font>运算符在<a href="">可拷贝类型和可移动类型</a>一节有提及。 运算符<font color=red><code>&lt;&lt;</code></font>在<a href="">流</a>一节有提及。同时请参见<a href="">函数重载</a>一节，其中提到的的规则对运算符重载同样适用。</p>
<h4 id="存取控制"><a href="#存取控制" class="headerlink" title="存取控制"></a>存取控制</h4><h5 id="总述-8"><a href="#总述-8" class="headerlink" title="总述"></a>总述</h5><p>将<em>所有</em>数据成员声明为<font color=red><code>private</code></font>，除非是<font color=red><code>static const</code></font>类型成员（遵循<a href="">常量命名规则</a>）。处于技术上的原因，在使用<a href="https://github.com/google/googletest">Google Test</a>时我们允许测试固件类中的数据成员为<font color=red><code>protected</code></font>。</p>
<h4 id="声明顺序"><a href="#声明顺序" class="headerlink" title="声明顺序"></a>声明顺序</h4><p>将相似的声明放在一起，将<font color=red><code>public</code></font>部分放在最前。</p>
<h5 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h5><p>类定义一般应在<font color=red><code>public：</code></font>开始，后跟<font color=red><code>protected：</code></font>，最后是<font color=red><code>private：</code></font>。省略空部分。</p>
<p>在各个部分中，建议将类似的声明放在一起，并且建议以如下顺序：类型（包括<font color=red><code>typedef</code></font>、<font color=red><code>using</code></font>和嵌套的结构体与类），常量，工厂函数、构造函数、赋值运算符、析构函数、其他函数，数据成员。</p>
<p>不要将大段的函数定义内联在类定义中。通常，只有那些普通的，或性能关键且短小的函数可以内联在类定义中。参考<a href="">内联函数</a>一节。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="参数顺序"><a href="#参数顺序" class="headerlink" title="参数顺序"></a>参数顺序</h4><h5 id="总述-9"><a href="#总述-9" class="headerlink" title="总述"></a>总述</h5><p>函数的参数顺序为：输入参数在先，后跟输出参数。</p>
<h5 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h5><p>C/C++中的函数参数或者函数的输入，或者是函数的输出，或兼而有之。输入参数通常是值参或<font color=red><code>const</code></font>引用，输出参数或者输入/输出参数则一般为非<font color=red><code>const</code></font>指针。在排列参数顺序时，将所有的输入参数置于输出参数之前。特别注意，在加入新参数时不要因它们是新参数就置于参数列表最后，是仍要按照前述的规则，即将新的输入参数也置于输出参数之前。</p>
<p>这并非一个硬性规定。输入/输出参数（通常是类或结构体）让这个问题变得复杂，并且，有时候为了其他函数保持一致，你可能不得不有所变通。</p>
<h4 id="编写简短函数"><a href="#编写简短函数" class="headerlink" title="编写简短函数"></a>编写简短函数</h4><h5 id="总述-10"><a href="#总述-10" class="headerlink" title="总述"></a>总述</h5><p>我们倾向于编写简短、凝练的函数。</p>
<h5 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h5><p>我们承认长函数有时是合理的，因此并不硬性限制函数的长度。如果函数超过40行，可以思索一下能不能在不影响程序结构的前提下对其进行分割。</p>
<p>即使一个长函数现在工作的非常好，一旦有人对其修改，有可能出现新的问题，甚至导致难以发现的 bug。使函数尽量简短，以便于他人阅读和修改代码。</p>
<p>在处理代码时，你可能会发现复杂的长函数。不要害怕修改现有代码：如果证实这些代码使用/调试起来很困难，或者你只需要使用其中的一小段代码，考虑将其分割为更加简短并易于管理的若干函数。</p>
<h4 id="引用参数"><a href="#引用参数" class="headerlink" title="引用参数"></a>引用参数</h4><h5 id="总述-11"><a href="#总述-11" class="headerlink" title="总述"></a>总述</h5><p>所有按引用传递的参数必须加上<font color=red><code>const</code></font>。</p>
<h5 id="定义-8"><a href="#定义-8" class="headerlink" title="定义"></a>定义</h5><p>在C语言中，如果函数需要修改变量的值，参数必须为指针，如<font color=red><code>int foo(int *pval)</code></font>。在C++中，函数还可以声明为引用参数：<font color=red><code>int foo(Interface &amp;val)</code></font>。</p>
<h5 id="优点-7"><a href="#优点-7" class="headerlink" title="优点"></a>优点</h5><p>定义引用参数可以防止出现<font color=red><code>(*pval)++</code></font>这样丑陋的代码。引用参数对于拷贝构造函数这样的应用也是需要的。同时也更明确地不接受空指针。</p>
<h5 id="缺点-7"><a href="#缺点-7" class="headerlink" title="缺点"></a>缺点</h5><p>容易引起误解，因为引用在语法上是值变量却拥有指针的语义。</p>
<h5 id="结论-7"><a href="#结论-7" class="headerlink" title="结论"></a>结论</h5><p>函数参数列表中，所有引用参数都必须是<font color=red><code>const</code></font>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;in, <span class="built_in">string</span> *out)</span></span>;</span><br></pre></td></tr></table></figure>
<p>事实上这在Google Code是一个硬性约定：输入参数是值参或<font color=red><code>const</code></font>引用，输出参数为指针。输入参数可以是<font color=red><code>const</code></font>指针，但绝不能是非<font color=red><code>const</code></font>的引用参数，除非特殊要求，比如<font color=red><code>swap</code></font>。</p>
<p>有时候，在输入形参中用<font color=red><code>const T*</code></font>指针比<font color=red><code>const T&amp;</code></font>更明智。比如：</p>
<ul>
<li>可能会传递空指针。</li>
<li>函数要把指针或地址的引用赋值给输入形参。</li>
</ul>
<p>总而言之，大多时候输入形参往往是<font color=red><code>const T&amp;</code></font>。若用<font color=red><code>const T*</code></font>则说明输入另有处理。所以若要使用<font color=red><code>const T*</code></font>，则应给出相应的理由，否则会使得读者感到迷惑。</p>
<h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><h5 id="总述-12"><a href="#总述-12" class="headerlink" title="总述"></a>总述</h5><p>若要使用函数重载，则必须能让读一看调用点就胸有成竹，而不用花心思猜测调用的重载函数到底是哪一种，这样一规则也适用于构造函数。</p>
<h5 id="定义-9"><a href="#定义-9" class="headerlink" title="定义"></a>定义</h5><p>你可以编写一个参数类型为<font color=red><code>const string&amp;</code></font>的函数，然后用另一个参数类型为<font color=red><code>const char*</code></font>的函数对齐进行重载：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Analyze</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;text)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Analyze</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* text, <span class="keyword">size_t</span> textlen)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="优点-8"><a href="#优点-8" class="headerlink" title="优点"></a>优点</h5><p>通过重载参数不同的同名参数，可以令代码更加直观，模版化代码需要重载，这同时也能为使用这带来便利。</p>
<h5 id="缺点-8"><a href="#缺点-8" class="headerlink" title="缺点"></a>缺点</h5><p>如果函数单靠不同的参数类型而重载，读者就得十分熟悉C++五花八门的匹配规则，以了解匹配过程具体到底如何。另外，如果派生类只重载了某个函数的部分变体，继承语义的容易令人困惑。</p>
<h5 id="结论-8"><a href="#结论-8" class="headerlink" title="结论"></a>结论</h5><p>如果打算重载一个函数，可以试试改在函数名里加上参数信息。例如，用<font color=red><code>AppendString()</code></font>和<font color=red><code>AppendInt</code></font>等, 而不是一口气重载多个<font color=red><code>Append()</code></font>。如果重载函数的目的是为了支持不同数量的同一类型参数，则优先考虑使用<font color=red><code>std::vector</code></font>以便使用者可以用<a href="">列表初始化</a>指定参数。</p>
<h4 id="缺省参数"><a href="#缺省参数" class="headerlink" title="缺省参数"></a>缺省参数</h4><h5 id="总述-13"><a href="#总述-13" class="headerlink" title="总述"></a>总述</h5><p>只允许在非虚函数中使用缺省参数，且必须保证缺省参数的值始终一致。缺省参数与<a href="">函数重载</a>遵循同样的规则。一般情况下建议使用函数重载，尤其是在缺省函数带来的可读性提升不能弥补下文中所提到的缺点的情况下。</p>
<h5 id="优点-9"><a href="#优点-9" class="headerlink" title="优点"></a>优点</h5><p>有些函数一般情况下使用默认参数，但有时需要又使用非默认的参数。缺省参数为这样的情形提供了便利，使程序员不需要为了极少的例外情况编写大量的函数。和函数重载相比，缺省参数的语法更简洁明了，减少了大量的样板代码，也更好地区别了“必要参数”和“可选参数”。</p>
<h5 id="缺点-9"><a href="#缺点-9" class="headerlink" title="缺点"></a>缺点</h5><p>缺省参数实际上是函数重载语义的另一种实现方式，因此所有<a href="">不应当使用函数重载的理由</a>也都适用于缺省参数。</p>
<p>虚函数调用的缺省参数取决于目标对象的静态类型，此时无法保证给定函数的所有重载声明的都是同样的缺省参数。</p>
<p>缺省参数是在每个调用点都要进行重新求值的，这会造成生成的代码迅速膨胀。作为读者，一般来说也更希望缺省的参数在声明时就已经被固定了，而不是在每次调用时都可能会有不同的取值。</p>
<p>缺省参数会干扰函数指针，导致函数签名与调用点的签名不一致。而函数重载不会导致这样的问题。</p>
<h5 id="结论-9"><a href="#结论-9" class="headerlink" title="结论"></a>结论</h5><p>对于虚函数，不允许使用缺省参数，因为在虚函数中缺省参数不一定能正常工作。如果在每个调用点缺省参数的值都有可能不同，在这种情况下缺省函数也不允许使用。(例如，不要写像<font color=red>void f(int n = counter++);</font>这样的代码。)</p>
<p>在其他情况下，如果缺省参数对可读性的提升远远超过了以上提及的缺点的话，可以使用缺省参数。 如果仍有疑惑，就使用函数重载。</p>
<h4 id="函数返回类型后置语法"><a href="#函数返回类型后置语法" class="headerlink" title="函数返回类型后置语法"></a>函数返回类型后置语法</h4><h5 id="总述-14"><a href="#总述-14" class="headerlink" title="总述"></a>总述</h5><p>只有在常规写法 (返回类型前置) 不便于书写或不便于阅读时使用返回类型后置语法。</p>
<h5 id="定义-10"><a href="#定义-10" class="headerlink" title="定义"></a>定义</h5><p>C++现在允许两种不同的函数声明方式。以往的写法是将返回类型置于函数名之前。例如:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<p>C++11引入了这一新的形式. 现在可以在函数名前使用<font color=red><code>auto</code></font>关键字, 在参数列表之后后置返回类型. 例如:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">auto foo(int x) -&gt; int;</span><br></pre></td></tr></table></figure>
<p>后置返回类型为函数作用域。对于像<font color=red><code>int</code></font>这样简单的类型，两种写法没有区别。但对于复杂的情况，例如类域中的类型声明或者以函数参数的形式书写的类型，写法的不同会造成区别。</p>
<h5 id="优点-10"><a href="#优点-10" class="headerlink" title="优点"></a>优点</h5><p>后置返回类型是显式地指定<a href="">Lambda表达式</a>的返回值的唯一方式。某些情况下，编译器可以自动推导出Lambda表达式的返回类型，但并不是在所有的情况下都能实现。即使编译器能够自动推导，显式地指定返回类型也能让读者更明了。</p>
<p>有时在已经出现了的函数参数列表之后指定返回类型，能够让书写更简单，也更易读，尤其是在返回类型依赖于模板参数时。例如:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">template &lt;class T, class U&gt; auto add(T t, U u) -&gt; decltype(t + u);</span><br></pre></td></tr></table></figure>
<p>对比下面的例子:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">U</span>&gt;</span> <span class="keyword">decltype</span>(declval&lt;T&amp;&gt;() + declval&lt;U&amp;&gt;()) add(T t, U u);</span><br></pre></td></tr></table></figure>
<h5 id="缺点-10"><a href="#缺点-10" class="headerlink" title="缺点"></a>缺点</h5><p>后置返回类型相对来说是非常新的语法，而且在C和Java中都没有相似的写法，因此可能对读者来说比较陌生。</p>
<p>在已有的代码中有大量的函数声明，你不可能把它们都用新的语法重写一遍。因此实际的做法只能是使用旧的语法或者新旧混用。在这种情况下，只使用一种版本是相对来说更规整的形式。</p>
<h5 id="结论-10"><a href="#结论-10" class="headerlink" title="结论"></a>结论</h5><p>在大部分情况下，应当继续使用以往的函数声明写法，即将返回类型置于函数名前。只有在必需的时候(如Lambda表达式)或者使用后置语法能够简化书写并且提高易读性的时候才使用新的返回类型后置语法。但是后一种情况一般来说是很少见的，大部分时候都出现在相当复杂的模板代码中，而多数情况下不鼓励写这样<a href="">复杂的模板代码</a>。</p>
<h3 id="其他C-特性"><a href="#其他C-特性" class="headerlink" title="其他C++特性"></a>其他C++特性</h3><h3 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h3><p>最重要的一致性规则是命名管理。命名的风格能让我们在不需要去查找类型声明的条件下快速地了解某个名字代表的含义：类型、变量、函数、常量、宏等等，甚至，我们大脑中的模式匹配引擎非常依赖这些命名规则。</p>
<p>命名规则具有一定随意性。但相比按个人喜好命名，一致性更重要，所以无论你认为它们是否重要，规则总是规则。</p>
<h4 id="通用命名规则"><a href="#通用命名规则" class="headerlink" title="通用命名规则"></a>通用命名规则</h4><h5 id="总述-15"><a href="#总述-15" class="headerlink" title="总述"></a>总述</h5><p>函数命名、变量命名，文件命名要有描述性；少用缩写。</p>
<h5 id="说明-4"><a href="#说明-4" class="headerlink" title="说明"></a>说明</h5><p>尽可能使用描述性的命名，别心疼空间，毕竟相比之下代码易于新读者理解更重要。不要用只有项目开发者能理解的缩写，也不要通过砍掉一个字母来缩写单词。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> price_count_reader;    <span class="comment">// 无缩写</span></span><br><span class="line"><span class="keyword">int</span> num_errors;            <span class="comment">// &quot;num&quot; 是一个常见的写法</span></span><br><span class="line"><span class="keyword">int</span> num_dns_connections;   <span class="comment">// 人人都知道 &quot;DNS&quot; 是什么</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n;                     <span class="comment">// 毫无意义.</span></span><br><span class="line"><span class="keyword">int</span> nerr;                  <span class="comment">// 含糊不清的缩写.</span></span><br><span class="line"><span class="keyword">int</span> n_comp_conns;          <span class="comment">// 含糊不清的缩写.</span></span><br><span class="line"><span class="keyword">int</span> wgc_connections;       <span class="comment">// 只有贵团队知道是什么意思.</span></span><br><span class="line"><span class="keyword">int</span> pc_reader;             <span class="comment">// &quot;pc&quot; 有太多可能的解释了.</span></span><br><span class="line"><span class="keyword">int</span> cstmr_id;              <span class="comment">// 删减了若干字母.</span></span><br></pre></td></tr></table></figure>
<p>注意，一些特定的广为人知的缩写是允许的，例如用<font color=red><code>i</code></font>和用<font color=red><code>T</code></font>表示模版参数。</p>
<p>模板参数的命名应当遵循对应的分类：类型模板参数应当遵循<a href="">类型命名</a>的规则，而非类型模板应当遵循<a href="">变量命名</a>的规则。</p>
<h4 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h4><h5 id="总述-16"><a href="#总述-16" class="headerlink" title="总述"></a>总述</h5><p>文件名要全部小写，可以包含下划线（<font color=red><code>_</code></font>）和连字符（<font color=red><code>-</code></font>），依照项目约定，如果没有约定，那么“<font color=red><code>_</code></font>”更好。</p>
<h5 id="说明-5"><a href="#说明-5" class="headerlink" title="说明"></a>说明</h5><p>可接受的文件命名实例：</p>
<ul>
<li><font color=red><code>my_userful_class.cc</code></font></li>
<li><font color=red><code>my-userful-class.cc</code></font></li>
<li><font color=red><code>myuserfulclass.cc</code></font></li>
<li><font color=red><code>myuserfulclass_test.cc</code></font> // <font color=red><code>_unittest.cc</code></font> 和<font color=red><code>_regtest.cc</code></font>以弃用。</li>
</ul>
<p>C++文件要以<font color=red><code>.cc</code></font>结尾，头文件以<font color=red><code>.h</code></font>结尾。专门插入文本的文件则以<font color=red><code>.inc</code></font> 结尾，参见<a href="">头文件自足</a>。</p>
<p>不要使用已经存在于<font color=red><code>/usr/include</code></font>下的文件名。如：<font color=red><code>db.h</code></font></p>
<p>通常应尽量让文件名更加明确。<font color=red><code>http_servr.h</code></font>就比<font color=red><code>logs.h</code></font>要好。定义类时文件名一般成对出现，如：<font color=red><code>foo_bar.h</code></font>和<font color=red><code>foo_bar.cc</code></font>，对应于类<br><code>FooBar</code>。</p>
<p>内联函数必须放在<font color=red><code>.h</code></font>文件中，如果内联函数比较短，就直接放在<font color=red><code>.h</code></font>。</p>
<h4 id="类型命名"><a href="#类型命名" class="headerlink" title="类型命名"></a>类型命名</h4><h5 id="总述-17"><a href="#总述-17" class="headerlink" title="总述"></a>总述</h5><p>类型名称的每个单词首字母均大写，不包好下划线：<font color=red><code>MyExcitingClass</code></font>，<font color=red><code>MyExcitingEnum</code></font>。</p>
<h5 id="说明-6"><a href="#说明-6" class="headerlink" title="说明"></a>说明</h5><p>所有类型命名——类、结构体、类型定义（<font color=red><code>typedef</code></font>）、枚举、类型模板参数——均使用相同约定，即以大写字母开始，每个单词首字母均大写，不包含下划线。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类和结构体</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UrlTable</span> &#123;</span> ...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UrlTableTester</span> &#123;</span> ...</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UrlTableProperties</span> &#123;</span> ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型定义</span></span><br><span class="line"><span class="keyword">typedef</span> hash_map&lt;UrlTableProperties *, <span class="built_in">string</span>&gt; PropertiesMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// using 别名</span></span><br><span class="line"><span class="keyword">using</span> PropertiesMap = hash_map&lt;UrlTableProperties *, <span class="built_in">string</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UrlTableErrors</span> &#123;</span> ...</span><br></pre></td></tr></table></figure>
<h4 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h4><h5 id="总述-18"><a href="#总述-18" class="headerlink" title="总述"></a>总述</h5><p>变量（包含函数参数）和数据成员名一律小写，单词之间用下划线连接。类的成员变量以下划线结尾，但结构体就不用。比如：<font color=red><code>a_local_variable</code></font>，<font color=red><code>a_struct_data_member</code></font>，<font color=red><code>a_class_data_member</code></font>。</p>
<h5 id="说明-7"><a href="#说明-7" class="headerlink" title="说明"></a>说明</h5><p><strong>普通变量命名</strong><br>举例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> table_name;  <span class="comment">// 好 - 用下划线.</span></span><br><span class="line"><span class="built_in">string</span> tablename;   <span class="comment">// 好 - 全小写.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> tableName;  <span class="comment">// 差 - 混合大小写</span></span><br></pre></td></tr></table></figure>
<p><strong>类数据成员</strong><br>不管是静态的还是非静态的，类数据成员都可以和普通变量一样，但要接下划线。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableInfo</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">string</span> table_name_;  <span class="comment">// 好 - 后加下划线.</span></span><br><span class="line">  <span class="built_in">string</span> tablename_;   <span class="comment">// 好.</span></span><br><span class="line">  <span class="keyword">static</span> Pool&lt;TableInfo&gt;* pool_;  <span class="comment">// 好.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>结构体变量</strong><br>不管是静态的还是非静态的，结构体数据成员都可以和普通变量一样，不要像类那样接下划线。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UrlTableProperties</span> &#123;</span></span><br><span class="line">  <span class="built_in">string</span> name;</span><br><span class="line">  <span class="keyword">int</span> num_entries;</span><br><span class="line">  <span class="keyword">static</span> Pool&lt;UrlTableProperties&gt;* pool;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结构体与类的使用讨论，参考<a href="">结构体和类</a>。</p>
<h4 id="常量命名"><a href="#常量命名" class="headerlink" title="常量命名"></a>常量命名</h4><h5 id="总述-19"><a href="#总述-19" class="headerlink" title="总述"></a>总述</h5><p>声明为<font color=red><code>constexpr</code></font>或<font color=red><code>const</code></font>的变量，或在程序运行期间其值始终保持不变的，命名时以“K”开头，大小写混合。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kDaysInAWeek = <span class="number">7</span>;</span><br></pre></td></tr></table></figure>
<h5 id="说明-8"><a href="#说明-8" class="headerlink" title="说明"></a>说明</h5><p>所有具有静态存储类型的变量(例如静态变量或全局变量，参见<a href="">存储类型</a>) 都应当以此方式命名。对于其他存储类型的变量，如自动变量等，这条规则是可选的。如果不采用这条规则，就按照一般的变量命名规则。</p>
<h4 id="函数命名"><a href="#函数命名" class="headerlink" title="函数命名"></a>函数命名</h4><h5 id="总述-20"><a href="#总述-20" class="headerlink" title="总述"></a>总述</h5><p>常规函数使用大小写混合，取值和设值函数则要求与变量名匹配:<font color=red><code>MyExcitingFunction()</code></font>，<font color=red><code>MyExcitingMethod()</code></font>， <font color=red><code>my_exciting_member_variable()</code></font>， <font color=red><code>set_my_exciting_member_variable()</code></font>。</p>
<h5 id="说明-9"><a href="#说明-9" class="headerlink" title="说明"></a>说明</h5><p>一般来说，函数名的每个单词首字母大写(即“驼峰变量名”或“帕斯卡变量名”)，没有下划线。对于首字母缩写的单词，更倾向于将它们视作一个单词进行首字母大写（例如，写作<font color=red><code>StartRpc()</code></font>而非<font color=red><code>StartRPC()</code></font>）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">AddTableEntry()</span><br><span class="line">DeleteUrl()</span><br><span class="line">OpenFileOrDie()</span><br></pre></td></tr></table></figure>
<p>(同样的命名规则同时适用于类作用域与命名空间作用域的常量，因为它们是作为API的一部分暴露对外的，因此应当让它们看起来像是一个函数，因为在这时，它们实际上是一个对象而非函数的这一事实对外不过是一个无关紧要的实现细节。)</p>
<p>取值和设值函数的命名与变量一致。一般来说它们的名称与实际的成员变量对应，但并不强制要求.。例如<font color=red><code>sint count()</code></font>与<font color=red><code>void set_count(int count)</code></font>。</p>
<h4 id="命名空间命名"><a href="#命名空间命名" class="headerlink" title="命名空间命名"></a>命名空间命名</h4><h5 id="总述-21"><a href="#总述-21" class="headerlink" title="总述"></a>总述</h5><p>命名空间以小写字母命名。最高级命名空间的名字取决于项目名称。要注意避免嵌套命名空间的名字之间和行间的顶级命名空间的名字之间发生的冲突。</p>
<p>顶级命名空间的名称应当是项目名称或是该命名空间中的代码所属的团队的名字。命名空间中的代码，应该存放于和命名空间的名字匹配的文件夹或其子文件夹中。</p>
<p>注意<a href="">不使用缩写作为名称</a>的规则同样适用于命名空间。命名空间中的代码极少需要设计命名空间的名称，因为没有必要在命名空间中使用缩写。</p>
<p>要避免嵌套的命名空间与常见的顶级命名空间发生名称冲突。由于名称查找规则的存在，命名空间之间的冲突完全有可能导致编译失败。尤其是，不要创建嵌套的<font color=red><code>std</code></font>m命名空间。建议使用更独特的项目标识符（<font color=red><code>websearch::index</code></font>、<font color=red><code>websearch::index_util</code></font>），而非常见的极易发生冲突的名名称（比如：<font color=red><code>websearch::util</code></font>）。</p>
<p>对于<font color=red><code>internal</code></font>命名空间，要当心加入到同一<font color=red><code>internal</code></font>命名空间的代码之间发生冲突（由于内部维护人员通常来自于同一个团队，因此常有可能导致冲突）。在这样的情况下，请使用文件名以使得内部名称独一无二（例如对于<font color=red><code>frobber.h</code></font>，使用<font color=red><code>websearch::index::frobber_internal</code></font>）。</p>
<h4 id="枚举命名"><a href="#枚举命名" class="headerlink" title="枚举命名"></a>枚举命名</h4><h5 id="总述-22"><a href="#总述-22" class="headerlink" title="总述"></a>总述</h5><p>枚举的命名应当和<a href="">常量</a>或<a href="">宏</a>一致：<font color=red><code>kEnumName</code></font>或是<font color=red><code>ENUM_NAME</code></font>。</p>
<h5 id="说明-10"><a href="#说明-10" class="headerlink" title="说明"></a>说明</h5><p>单独的枚举值应该优先采用<a href="">常量</a>的命名方式。但<a href="">宏</a>方式的命名也可以接受，枚举名<font color=red><code>UrlTableErrors</code></font>（以及<font color=red><code>AlternateUrlTableErrors</code></font>）是类型，所以要用大小写混合的方式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UrlTableErrors</span> &#123;</span></span><br><span class="line">    kOK = <span class="number">0</span>,</span><br><span class="line">    kErrorOutOfMemory,</span><br><span class="line">    kErrorMalformedInput,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">AlternateUrlTableErrors</span> &#123;</span></span><br><span class="line">    OK = <span class="number">0</span>,</span><br><span class="line">    OUT_OF_MEMORY = <span class="number">1</span>,</span><br><span class="line">    MALFORMED_INPUT = <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>2009年1月之前，我们一直建议采用<a href="">宏</a>的方式命名枚举值。由于枚举值和宏之间的命名冲突，直接导致了很多问题。由此，这里改为优先选择常量风格的命名方式。新代码应该尽可能优先使用常量风格。但是老代码没必要切换到常量风格，除非宏风格确实会产生编译期问题。</p>
<h4 id="宏命名"><a href="#宏命名" class="headerlink" title="宏命名"></a>宏命名</h4><h5 id="总述-23"><a href="#总述-23" class="headerlink" title="总述"></a>总述</h5><p>你并不打算[使用宏]，对吧？如果你一定要用，就像这样命名：<font color=red><code>MY_MACRO_THAT_SCARES_SMALL_CHILDREN</code></font>。</p>
<h5 id="说明-11"><a href="#说明-11" class="headerlink" title="说明"></a>说明</h5><p>参考<a href="">预处理宏</a>；通常，<em>不应该</em>使用宏，如果不得不用，其命名像枚举命名一样全部大写，使用下划线：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROUND(x) ...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI_ROUNDED 3.0</span></span><br></pre></td></tr></table></figure>
<h4 id="命名规则特例"><a href="#命名规则特例" class="headerlink" title="命名规则特例"></a>命名规则特例</h4><h5 id="总述-24"><a href="#总述-24" class="headerlink" title="总述"></a>总述</h5><p>如果你命名的实体与已有C/C++实体相似，可参考现有命名策略。<br><font color=red><code>bigopen()</code></font>:函数名，参照<font color=red><code>open()</code></font>的形式。<br><font color=red><code>uint</code></font>：<font color=red><code>typedef</code></font><br><font color=red><code>bigpos</code></font>：<font color=red><code>struct</code></font>或<font color=red><code>class</code></font>，参照<font color=red><code>pos</code></font>的形式。<br><font color=red><code>sparse_hash_map</code></font>：STL型实体；参照STL命名约定。<br><font color=red><code>UrlTableErrors</code></font>常量，如同<font color=red><code>INT_MAX</code></font></p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>注释虽然写起来很痛苦，但对保证代码可读性至关重要。下面的规则描述了如何注释以及在哪儿注释。当然也要记住：注释固然很重要，但最好的代码应当本身就是文档。有意义的类型名和变量名，要远胜过要用注释解释的含糊不清的名字。</p>
<p>你写的注释是给代码读者看的，也就是下一个需要理解你的代码的人。所以慷慨些吧，下一个读者可能就是你!</p>
<h4 id="注释风格"><a href="#注释风格" class="headerlink" title="注释风格"></a>注释风格</h4><h5 id="总述-25"><a href="#总述-25" class="headerlink" title="总述"></a>总述</h5><p>使用<font color=red><code>//</code></font>或<font color=red><code>/* */</code></font>，统一就好。</p>
<h5 id="说明-12"><a href="#说明-12" class="headerlink" title="说明"></a>说明</h5><p>虽然<font color=red><code>//</code></font>或<font color=red><code>/* */</code></font>都可以，但<font color=red><code>//</code></font>更常用。更在如何注释以及注释风格上确保统一。</p>
<h4 id="文件注释"><a href="#文件注释" class="headerlink" title="文件注释"></a>文件注释</h4><h5 id="总述-26"><a href="#总述-26" class="headerlink" title="总述"></a>总述</h5><p>在每一个文件开头加入版权公告。</p>
<p>文件注释描述了该文件的内容。如果一个文件只声明，或实现，或测试了一个对象，并且这个对象已经在它的声明处进行了详细的注释，那么就没必要再加上文件注释。除此之外的其他文件都需要文件注释。</p>
<h5 id="说明-13"><a href="#说明-13" class="headerlink" title="说明"></a>说明</h5><p><font size=5><strong>法律公告和作者信息</strong></font></p>
<p>每个文件都应该包含许可证引用。为项目选择合适的许可证版本。(比如，Apache 2.0、BSD、LGPL,、GPL)。</p>
<p>如果你对原始作者的文件做了重大修改。请考虑删除原作者信息。</p>
<p><font size=5><strong>文件内容</strong></font></p>
<p>如果一个<font color=red><code>.h</code></font>文件声明了多个概念，则文件注释应当对文件的内容做一个大致的说明，同时说明各概念之间的联系。一个一到两行的文件注释就足够了，对于每个概念的详细文档应当放在各个概念中，而不是文件注释中。</p>
<p>不要在<font color=red><code>.h</code></font>和<font color=red><code>.cc</code></font>之间复制注释，这样的注释偏离了注释的实际意义.</p>
<h4 id="类注释"><a href="#类注释" class="headerlink" title="类注释"></a>类注释</h4><h5 id="总述-27"><a href="#总述-27" class="headerlink" title="总述"></a>总述</h5><p>每个类的定义都要附带一份注释，描述类的功能和用法，除非它的功能相当明显。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Iterates over the contents of a GargantuanTable.</span></span><br><span class="line"><span class="comment">// Example:</span></span><br><span class="line"><span class="comment">//    GargantuanTableIterator* iter = table-&gt;NewIterator();</span></span><br><span class="line"><span class="comment">//    for (iter-&gt;Seek(&quot;foo&quot;); !iter-&gt;done(); iter-&gt;Next()) &#123;</span></span><br><span class="line"><span class="comment">//      process(iter-&gt;key(), iter-&gt;value());</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    delete iter;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GargantuanTableIterator</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="说明-14"><a href="#说明-14" class="headerlink" title="说明"></a>说明</h5><p>类注释应当为读者理解如何使用与何时使用类提供足够的信息，同时应当提醒读者在正确使用此类时应当考虑的因素。如果类有任何同步前提，请用文档说明。如果该类的实例可被多线程访问，要特别注意文档说明多线程环境下相关的规则和常量使用。</p>
<p>如果你想用一小段代码演示这个类的基本用法或通常用法，放在类注释里也非常合适。</p>
<p>如果类的声明和定义分开了(例如分别放在了<font color=red><code>.h</code></font>和<font color=red><code>.cc</code></font>文件中)，此时，描述类用法的注释应当和接口定义放在一起，描述类的操作和实现的注释应当和实现放在一起。</p>
<h4 id="函数注释"><a href="#函数注释" class="headerlink" title="函数注释"></a>函数注释</h4><h5 id="总述-28"><a href="#总述-28" class="headerlink" title="总述"></a>总述</h5><p>函数声明处的注释描述函数功能；定义处的注释描述函数实现。</p>
<h5 id="说明-15"><a href="#说明-15" class="headerlink" title="说明"></a>说明</h5><p><font size=5>函数声明</font></p>
<p>基本上每个函数声明处前都应当加上注释，描述函数的功能和用途。只有在函数的功能简单而明显时才能省略这些注释(例如，简单的取值和设值函数)。注释使用叙述式(“Opens the file”)而非指令式 (“Open the file”)；注释只是为了描述函数，而不是命令函数做什么。通常，注释不会描述函数如何工作。那是函数定义部分的事情。</p>
<p>函数声明处注释的内容：</p>
<ul>
<li>函数的输入输出。</li>
<li>对类成员函数而言：函数调用期间对象是否需要保持引用参数，是否会释放这些参数。</li>
<li>函数是否分配了必须由调用者释放的空间。</li>
<li>参数是否可以为空指针。</li>
<li>是否存在函数使用上的性能隐患。</li>
<li>如果函数是可重入的，其同步前提是什么？</li>
</ul>
<p>举例如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns an iterator for this table.  It is the client&#x27;s</span></span><br><span class="line"><span class="comment">// responsibility to delete the iterator when it is done with it,</span></span><br><span class="line"><span class="comment">// and it must not use the iterator once the GargantuanTable object</span></span><br><span class="line"><span class="comment">// on which the iterator was created has been deleted.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The iterator is initially positioned at the beginning of the table.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This method is equivalent to:</span></span><br><span class="line"><span class="comment">//    Iterator* iter = table-&gt;NewIterator();</span></span><br><span class="line"><span class="comment">//    iter-&gt;Seek(&quot;&quot;);</span></span><br><span class="line"><span class="comment">//    return iter;</span></span><br><span class="line"><span class="comment">// If you are going to immediately seek to another place in the</span></span><br><span class="line"><span class="comment">// returned iterator, it will be faster to use NewIterator()</span></span><br><span class="line"><span class="comment">// and avoid the extra seek.</span></span><br><span class="line"><span class="function">Iterator* <span class="title">GetIterator</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>但也要避免罗罗嗦嗦，或者对显而易见的内容进行说明。下面的注释就没有必要加上“否则返回 false”, 因为已经暗含其中了:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns true if the table cannot hold any more entries.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsTableFull</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>注释函数重载时，注释的重点应该是函数中被重载的部分，而不是简单的重复被重载的函数的注释。多数情况下，函数重载不需要额外的文档，因此也没有必要加上注释。</p>
<p>注释构造/析构函数时，切记读代码的人知道构造/析构函数的功能，所以“销毁这一对象”这样的注释是没有意义的。你应当注明的是注明构造函数对参数做了什么(例如，是否取得指针所有权)以及析构函数清理了什么。如果都是些无关紧要的内容，直接省掉注释。析构函数前没有注释是很正常的。</p>
<p>不要从<font color=red><code>.h</code></font>文件或其他地方的函数声明处直接复制注释。简要重述函数功能是可以的，但注释重点要放在如何实现上。</p>
<h4 id="变量注释"><a href="#变量注释" class="headerlink" title="变量注释"></a>变量注释</h4><h5 id="总述-29"><a href="#总述-29" class="headerlink" title="总述"></a>总述</h5><p>通常变量名本身足以很好说明变量用途。某些情况下，也需要额外的注释说明。</p>
<h5 id="说明-16"><a href="#说明-16" class="headerlink" title="说明"></a>说明</h5><p><font size=5>类数据成员</font></p>
<p>每个类数据成员(也叫实例变量或成员变量)都应该用注释说明用途。如果有非变量的参数(例如特殊值，数据成员之间的关系、生命周期等)不能够用类型与变量名明确表达，则应当加上注释。然而，如果变量类型与变量名已经足以描述一个变量，那么就不再需要加上注释。</p>
<p>特别地，如果变量可以接受<font color=red><code>NULL</code></font>或<font color=red><code>-1</code></font>等警戒值，须加以说明。比如:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="comment">// Used to bounds-check table accesses. -1 means</span></span><br><span class="line"> <span class="comment">// that we don&#x27;t yet know how many entries the table has.</span></span><br><span class="line"> <span class="keyword">int</span> num_total_entries_;</span><br></pre></td></tr></table></figure>
<p><font size=5>全局变量</font></p>
<p>和数据成员一样，所有全局变量也要注释说明含义及用途，以及作为全局变量的原因。比如:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The total number of tests cases that we run through in this regression test.</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kNumTestCases = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>
<h4 id="实现注释"><a href="#实现注释" class="headerlink" title="实现注释"></a>实现注释</h4><h5 id="总述-30"><a href="#总述-30" class="headerlink" title="总述"></a>总述</h5><p>对于代码中巧妙的，晦涩的，有趣的，重要的地方加以注释。</p>
<h5 id="说明-17"><a href="#说明-17" class="headerlink" title="说明"></a>说明</h5><p><font size=5>代码前注释</font></p>
<p>巧妙或复杂的代码段前要加注释。比如:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Divide result by two, taking into account that x</span></span><br><span class="line"><span class="comment">// contains the carry from the add.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result-&gt;size(); i++) &#123;</span><br><span class="line">  x = (x &lt;&lt; <span class="number">8</span>) + (*result)[i];</span><br><span class="line">  (*result)[i] = x &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  x &amp;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font size=5>行注释</font></p>
<p>比较隐晦的地方要在行尾加入注释。在行尾空两格进行注释。比如:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// If we have enough memory, mmap the data portion too.</span></span><br><span class="line">mmap_budget = max&lt;int64&gt;(<span class="number">0</span>, mmap_budget - index_-&gt;length());</span><br><span class="line"><span class="keyword">if</span> (mmap_budget &gt;= data_size_ &amp;&amp; !MmapData(mmap_chunk_bytes, mlock))</span><br><span class="line">  <span class="keyword">return</span>;  <span class="comment">// Error already logged.</span></span><br></pre></td></tr></table></figure>
<p>注意，这里用了两段注释分别描述这段代码的作用，和提示函数返回时错误已经被记入日志。</p>
<p>如果你需要连续进行多行注释，可以使之对齐获得更好的可读性：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">DoSomething();                  <span class="comment">// Comment here so the comments line up.</span></span><br><span class="line">DoSomethingElseThatIsLonger();  <span class="comment">// Two spaces between the code and the comment.</span></span><br><span class="line">&#123; <span class="comment">// One space before comment when opening a new scope is allowed,</span></span><br><span class="line">  <span class="comment">// thus the comment lines up with the following comments and code.</span></span><br><span class="line">  DoSomethingElse();  <span class="comment">// Two spaces before line comments normally.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="built_in">list</span>&#123;</span><br><span class="line">                    <span class="comment">// Comments in braced lists describe the next element...</span></span><br><span class="line">                    <span class="string">&quot;First item&quot;</span>,</span><br><span class="line">                    <span class="comment">// .. and should be aligned appropriately.</span></span><br><span class="line"><span class="string">&quot;Second item&quot;</span>&#125;;</span><br><span class="line">DoSomething(); <span class="comment">/* For trailing block comments, one space is fine. */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><font size=5>函数参数注释</font></p>
<p>如果函数参数的意义不明显，考虑用下面的方式进行弥补:</p>
<ul>
<li>如果参数是一个字面常量，并且这一常量在多处函数调用中被使用，用以推断它们一致，你应当用一个常量名让这一约定变得更明显，并且保证这一约定不会被打破。</li>
<li>考虑更改函数的签名，让某个<font color=red><code>bool</code></font>类型的参数变为<font color=red><code>enum</code></font>类型，这样可以让这个参数的值表达其意义。</li>
<li>如果某个函数有多个配置选项，你可以考虑定义一个类或结构体以保存所有的选项，并传入类或结构体的实例。这样的方法有许多优点，例如这样的选项可以在调用处用变量名引用，这样就能清晰地表明其意义。同时也减少了函数参数的数量，使得函数调用更易读也易写。除此之外，以这样的方式，如果你使用其他的选项，就无需对调用点进行更改。</li>
<li>用具名变量代替大段而复杂的嵌套表达式。</li>
<li>万不得已时, 才考虑在调用点用注释阐明参数的意义.</li>
</ul>
<p>比如下面的示例的对比:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// What are these arguments?</span></span><br><span class="line"><span class="keyword">const</span> DecimalNumber product = CalculateProduct(values, <span class="number">7</span>, <span class="literal">false</span>, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ProductOptions options;</span><br><span class="line">options.set_precision_decimals(<span class="number">7</span>);</span><br><span class="line">options.set_use_cache(ProductOptions::kDontUseCache);</span><br><span class="line"><span class="keyword">const</span> DecimalNumber product =</span><br><span class="line">    CalculateProduct(values, options, <span class="comment">/*completion_callback=*/</span><span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure>
<p>哪个更清晰一目了然。</p>
<p><font size=5>不允许的行为</font></p>
<p>不要描述显而易见的现象，<em>永远不要</em>用自然语言翻译代码作为注释，除非即使对深入理解C++的读者来说代码的行为都是不明显的。要假设读代码的人C++水平比你高，即便他/她可能不知道你的用意:</p>
<p>你所提供的注释应当解释代码<em>为什么</em>要这么做和代码的目的，或者最好是让代码自文档化。</p>
<p>比较这样的注释:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Find the element in the vector.  &lt;-- 差: 这太明显了!</span></span><br><span class="line"><span class="keyword">auto</span> iter = <span class="built_in">std</span>::find(v.begin(), v.end(), element);</span><br><span class="line"><span class="keyword">if</span> (iter != v.end()) &#123;</span><br><span class="line">  Process(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和这样的注释：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Process &quot;element&quot; unless it was already processed.</span></span><br><span class="line"><span class="keyword">auto</span> iter = <span class="built_in">std</span>::find(v.begin(), v.end(), element);</span><br><span class="line"><span class="keyword">if</span> (iter != v.end()) &#123;</span><br><span class="line">  Process(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自文档化的代码根本就不需要注释。上面例子中的注释对下面的代码来说就是毫无必要的:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!IsAlreadyProcessed(element)) &#123;</span><br><span class="line">  Process(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="标点、拼写和语法"><a href="#标点、拼写和语法" class="headerlink" title="标点、拼写和语法"></a>标点、拼写和语法</h4><h5 id="总述-31"><a href="#总述-31" class="headerlink" title="总述"></a>总述</h5><p>注意标点，拼写和语法；写的好的注释比差的要易读的多。</p>
<h5 id="说明-18"><a href="#说明-18" class="headerlink" title="说明"></a>说明</h5><p>注释的通常写法是包含正确大小写和结尾句号的完整叙述性语句。大多数情况下，完整的句子比句子片段可读性更高。短一点的注释，比如代码行尾注释，可以随意点。但依然要注意风格的一致性.</p>
<p>虽然被别人指出该用分号时却用了逗号多少有些尴尬，但清晰易读的代码还是很重要的。正确的标点、拼写和语法对此会有很大帮助。</p>
<h4 id="TODO注释"><a href="#TODO注释" class="headerlink" title="TODO注释"></a>TODO注释</h4><h5 id="总述-32"><a href="#总述-32" class="headerlink" title="总述"></a>总述</h5><p>对那些临时的、短期的解决方案，或已经够好但仍不完美的代码使用<font color=red><code>TODO</code></font>注释。</p>
<h5 id="说明-19"><a href="#说明-19" class="headerlink" title="说明"></a>说明</h5><p><font color=red><code>TODO</code></font>注释要使用全大写的字符串<font color=red><code>TODO</code></font>，在随后的圆括号里写上你的名字、邮件地址、bug ID或其它身份标识和与这一<font color=red><code>TODO</code></font>相关的issue。主要目的是让添加注释的人(也是可以请求提供更多细节的人)可根据规范的<font color=red><code>TODO</code></font>格式进行查找。添加<font color=red><code>TODO</code></font>注释并不意味着你要自己来修正，因此当你加上带有姓名的<font color=red><code>TODO</code></font>时，一般都是写上自己的名字。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TODO(kl@gmail.com): Use a &quot;*&quot; here for concatenation operator.</span></span><br><span class="line"><span class="comment">// TODO(Zeke) change this to use relations.</span></span><br><span class="line"><span class="comment">// TODO(bug 12345): remove the &quot;Last visitors&quot; feature</span></span><br></pre></td></tr></table></figure>
<p>如果加<font color=red><code>TODO</code></font>为了在“将来某一天做某事”，可以附上一个非常明确的时间 “Fix by November 2005”)，或者一个明确的事项(“Remove this code when all clients can handle XML responses.”)。</p>
<h4 id="弃用注释"><a href="#弃用注释" class="headerlink" title="弃用注释"></a>弃用注释</h4><h5 id="总述-33"><a href="#总述-33" class="headerlink" title="总述"></a>总述</h5><p>通过弃用注释（<font color=red>DEPRECATED</font> comments）以标记某接口点已弃用。</p>
<p>您可以写上包含全大写的<font color=red>DEPRECATED</font>的注释，以标记某接口为弃用状态。 注释可以放在接口声明前或者同一行。</p>
<p>在<font color=red>DEPRECATED</font>一词后，在括号中留下您的名字，邮箱地址以及其他身份标识。</p>
<p>弃用注释应当包涵简短而清晰的指引，以帮助其他人修复其调用点。在 C++ 中，你可以将一个弃用函数改造成一个内联函数，这一函数将调用新的接口。</p>
<p>仅仅标记接口为<font color=red>DEPRECATED</font>并不会让大家不约而同地弃用，您还得亲自主动修正调用点（callsites）或是找个帮手。</p>
<p>修正好的代码应该不会再涉及弃用接口点了，着实改用新接口点。如果您不知从何下手，可以找标记弃用注释的当事人一起商量。</p>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>每个人都可能有自己的代码风格和格式，但如果一个项目中的所有人都遵循同一风格的话，这个项目就能更顺利地进行。每个人未必能同意下述的每一处格式规则，而且其中的不少规则需要一定时间的适应，但整个项目服从统一的编程风格是很重要的，只有这样才能让所有人轻松地阅读和理解代码。</p>
<p>为了帮助你正确的格式化代码，我们写了一个<a href="https://raw.githubusercontent.com/google/styleguide/gh-pages/google-c-style.el">emacs配置文件</a>。</p>
<h4 id="行长度"><a href="#行长度" class="headerlink" title="行长度"></a>行长度</h4><h5 id="总述-34"><a href="#总述-34" class="headerlink" title="总述"></a>总述</h5><p>每一行代码字符数不超过80。</p>
<p>我们也认识到这条规则是有争议的，但很多已有代码都遵照这一规则，因此我们感觉一致性更重要。</p>
<h5 id="优点-11"><a href="#优点-11" class="headerlink" title="优点"></a>优点</h5><p>提倡该原则的人认为强迫他们调整编辑器窗口大小是很野蛮的行为。很多人同时并排开几个代码窗口，根本没有多余的空间拉伸窗口。大家都把窗口最大尺寸加以限定并且80列宽是传统标准。那么为什么要改变呢?</p>
<h5 id="缺点-11"><a href="#缺点-11" class="headerlink" title="缺点"></a>缺点</h5><p>反对该原则的人则认为更宽的代码行更易阅读。80列的限制是上个世纪60年代的大型机的古板缺陷；现代设备具有更宽的显示屏，可以很轻松地显示更多代码。</p>
<h5 id="结论-11"><a href="#结论-11" class="headerlink" title="结论"></a>结论</h5><p>如果无法在不伤害易读性的条件下进行断行，那么注释行可以超过80个字符，这样可以方便复制粘贴。例如，带有命令示例或URL的行可以超过80个字符。</p>
<p>包含长路径的<font color=red><code>#include</code></font>语句可以超出80列。</p>
<p><font color=blue><code>头文件保护</code></font>可以无视该原则.</p>
<h4 id="非ASCII字符"><a href="#非ASCII字符" class="headerlink" title="非ASCII字符"></a>非ASCII字符</h4><h5 id="总述-35"><a href="#总述-35" class="headerlink" title="总述"></a>总述</h5><p>尽量不使用非ASCII字符，使用时必须使用UTF-8编码。</p>
<h5 id="说明-20"><a href="#说明-20" class="headerlink" title="说明"></a>说明</h5><p>即使是英文，也不应将用户界面的文本硬编码到源代码中，因此非ASCII字符应当很少被用到。特殊情况下可以适当包含此类字符。例如，代码分析外部数据文件时，可以适当硬编码数据文件中作为分隔符的非 ASCII字符串；更常见的是(不需要本地化的)单元测试代码可能包含非ASCII字符串。此类情况下，应使用UTF-8编码，因为很多工具都可以理解和处理UTF-8编码。</p>
<p>十六进制编码也可以，能增强可读性的情况下尤其鼓励 —— 比如<font color=red><code>&quot;\xEF\xBB\xBF&quot;</code></font>，或者更简洁地写作<font color=red><code>u8&quot;\uFEFF&quot;</code></font>，在Unicode中是<em>零宽度 无间断</em>的间隔符号，如果不用十六进制直接放在UTF-8格式的源文件中，是看不到的。</p>
<p>使用<font color=red>u8</font>前缀把带<font color=red><code>uXXXX</code></font>转义序列的字符串字面值编码成UTF-8。不要用在本身就带UTF-8字符的字符串字面值上，因为如果编译器不把源代码识别成UTF-8，输出就会出错。</p>
<p>别用C++11的<font color=red><code>char16_t</code></font>和<font color=red><code>char32_t</code></font>，它们和UTF-8文本没有关系，<font color=red><code>wchar_t</code></font>同理，除非你写的代码要调用Windows API，后者广泛使用了<font color=red><code>wchar_t</code></font>。</p>
<h4 id="空格还是制表符"><a href="#空格还是制表符" class="headerlink" title="空格还是制表符"></a>空格还是制表符</h4><h5 id="总述-36"><a href="#总述-36" class="headerlink" title="总述"></a>总述</h5><p>只使用空格，每次缩进2个空格。</p>
<h5 id="说明-21"><a href="#说明-21" class="headerlink" title="说明"></a>说明</h5><p>我们使用空格缩，不要在代码中使用制表符。你应该设置编辑器将制表符转为空格。</p>
<h4 id="函数声明和定义"><a href="#函数声明和定义" class="headerlink" title="函数声明和定义"></a>函数声明和定义</h4><h5 id="总述-37"><a href="#总述-37" class="headerlink" title="总述"></a>总述</h5><p>返回类型和函数名在同一行，参数也尽量放在同一行，如果放不下就对形参分行，分行方式与<a href="">函数调用</a>一致。</p>
<h5 id="说明-22"><a href="#说明-22" class="headerlink" title="说明"></a>说明</h5><p>函数看上去像这样:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ReturnType <span class="title">ClassName::FunctionName</span><span class="params">(Type par_name1, Type par_name2)</span> </span>&#123;</span><br><span class="line">  DoSomething();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果同一行文本太多，放不下所有参数:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ReturnType <span class="title">ClassName::ReallyLongFunctionName</span><span class="params">(Type par_name1, Type par_name2,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             Type par_name3)</span> </span>&#123;</span><br><span class="line">  DoSomething();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>甚至连第一个参数都放不下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ReturnType <span class="title">LongClassName::ReallyReallyReallyLongFunctionName</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Type par_name1,  <span class="comment">// 4 space indent</span></span></span></span><br><span class="line"><span class="function"><span class="params">    Type par_name2,</span></span></span><br><span class="line"><span class="function"><span class="params">    Type par_name3)</span> </span>&#123;</span><br><span class="line">  DoSomething();  <span class="comment">// 2 space indent</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意以下几点:</p>
<ul>
<li>使用好的参数名。</li>
<li>只有在参数违背使用或者其用途非常明显时，才能省略参数名。</li>
<li>如果返回类型和函数名在一行放不下，分行。</li>
<li>如果返回类型与函数声明或定义分行了，不要缩进。</li>
<li>左圆括号总是和函数名在同一行。</li>
<li>函数名和左圆括号间永远没有空格。</li>
<li>圆括号与参数间没有空格。</li>
<li>左大括号总在最后一个参数同一行的末尾处，不另起新行。</li>
<li>右大括号总是单独位于函数最后一行，或者与左大括号同一行。</li>
<li>右圆括号和左大括号间总是有一个空格。</li>
<li>所有形参应尽可能对齐。</li>
<li>缺省缩进为2个空格。</li>
<li>换行后的参数保持4个空格的缩进。</li>
</ul>
<p>未被使用的参数，或者根据上下文很容易看出其用途的参数，可以省略参数名:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Foo(Foo&amp;&amp;);</span><br><span class="line">  Foo(<span class="keyword">const</span> Foo&amp;);</span><br><span class="line">  Foo&amp; <span class="keyword">operator</span>=(Foo&amp;&amp;);</span><br><span class="line">  Foo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Foo&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>未被使用的参数如果其用途不明显的话，在函数定义处将参数名注释起来:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Rotate</span><span class="params">(<span class="keyword">double</span> radians)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Shape &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Rotate</span><span class="params">(<span class="keyword">double</span> radians)</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Circle::Rotate</span><span class="params">(<span class="keyword">double</span> <span class="comment">/*radians*/</span>)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">/ 差 - 如果将来有人要实现, 很难猜出变量的作用.</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Circle::Rotate</span><span class="params">(<span class="keyword">double</span>)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>属性和展开为属性的宏，写在函数声明或定义的最前面，即返回类型之前:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">MUST_USE_RESULT <span class="keyword">bool</span> <span class="title">IsOK</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><h5 id="总述-38"><a href="#总述-38" class="headerlink" title="总述"></a>总述</h5><p>Lambda表达式对形参和函数体的格式化和其他函数一致；捕获列表同理，表项用逗号隔开。</p>
<h5 id="说明-23"><a href="#说明-23" class="headerlink" title="说明"></a>说明</h5><p>若用引用捕获，在变量名和<font color=red><code>&amp;</code></font>之间不留空格。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> add_to_x = [&amp;x](<span class="keyword">int</span> n) &#123; x += n; &#125;;</span><br></pre></td></tr></table></figure>
<p>短lambda就写得和内联函数一样。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; blacklist = &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; digits = &#123;<span class="number">3</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>&#125;;</span><br><span class="line">digits.erase(<span class="built_in">std</span>::remove_if(digits.begin(), digits.end(), [&amp;blacklist](<span class="keyword">int</span> i) &#123;</span><br><span class="line">               <span class="keyword">return</span> blacklist.find(i) != blacklist.end();</span><br><span class="line">             &#125;),</span><br><span class="line">             digits.end());</span><br></pre></td></tr></table></figure>
<h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><h5 id="总述-39"><a href="#总述-39" class="headerlink" title="总述"></a>总述</h5><p>要么一行写完函数调用，要么在圆括号里对参数分行，要么参数另起一行且缩进四格。如果没有其它顾虑的话，尽可能精简行数，比如把多个参数适当地放在同一行里。</p>
<h5 id="说明-24"><a href="#说明-24" class="headerlink" title="说明"></a>说明</h5><p>函数调用遵循如下形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> retval = DoSomething(argument1, argument2, argument3);</span><br></pre></td></tr></table></figure>
<p>如果同一行放不下，可断为多行，后面每一行都和第一个实参对齐，左圆括号后和右圆括号前不要留空格：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> retval = DoSomething(averyveryveryverylongargument1,</span><br><span class="line">                          argument2, argument3);</span><br></pre></td></tr></table></figure>
<p>参数也可以放在次行，缩进四格：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (...) &#123;</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (...) &#123;</span><br><span class="line">    DoSomething(</span><br><span class="line">        argument1, argument2,  <span class="comment">// 4 空格缩进</span></span><br><span class="line">        argument3, argument4);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>把多个参数放在同一行以减少函数调用所需的行数，除非影响到可读性。有人认为把每个参数都独立成行，不仅更好读而且方便编辑参数。不过，比起所谓的参数编辑，我们更看重可读性，且后者比较好办。</p>
<p>如果一些参数本身就是略复杂的表达式，且降低了可读性，那么可以直接创建临时变量描述该表达式，并传递给函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> my_heuristic = scores[x] * y + bases[x];</span><br><span class="line"><span class="keyword">bool</span> retval = DoSomething(my_heuristic, x, y, z);</span><br></pre></td></tr></table></figure>
<p>或者放着不管，补充上注释：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> retval = DoSomething(scores[x] * y + bases[x],  <span class="comment">// Score heuristic.</span></span><br><span class="line">                          x, y, z);</span><br></pre></td></tr></table></figure>
<p>如果某参数独立成行，对可读性更有帮助的话，那也可以如此做。参数的格式处理应当以可读性而非其他作为最重要的原则。</p>
<p>此外，如果一系列参数本身就有一定的结构，可以酌情地按其结构来决定参数格式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 3x3 矩阵转换 widget.</span></span><br><span class="line">my_widget.Transform(x1, x2, x3,</span><br><span class="line">                    y1, y2, y3,</span><br><span class="line">                    z1, z2, z3);</span><br></pre></td></tr></table></figure>
<h4 id="列表初始化格式"><a href="#列表初始化格式" class="headerlink" title="列表初始化格式"></a>列表初始化格式</h4><h5 id="总述-40"><a href="#总述-40" class="headerlink" title="总述"></a>总述</h5><p>您平时怎么格式化函数调用，就怎么格式化<a href="">列表初始化</a>。</p>
<h5 id="说明-25"><a href="#说明-25" class="headerlink" title="说明"></a>说明</h5><p>如果列表初始化伴随着名字，比如类型或变量名，格式化时将将名字视作函数调用名，*{}*视作函数调用的括号。如果没有名字，就视作名字长度为零。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一行列表初始化示范.</span></span><br><span class="line"><span class="keyword">return</span> &#123;foo, bar&#125;;</span><br><span class="line">functioncall(&#123;foo, bar&#125;);</span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p&#123;foo, bar&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当不得不断行时.</span></span><br><span class="line">SomeFunction(</span><br><span class="line">    &#123;<span class="string">&quot;assume a zero-length name before &#123;&quot;</span>&#125;,  <span class="comment">// 假设在 &#123; 前有长度为零的名字.</span></span><br><span class="line">    some_other_function_parameter);</span><br><span class="line">SomeType variable&#123;</span><br><span class="line">    some, other, values,</span><br><span class="line">    &#123;<span class="string">&quot;assume a zero-length name before &#123;&quot;</span>&#125;,  <span class="comment">// 假设在 &#123; 前有长度为零的名字.</span></span><br><span class="line">    SomeOtherType&#123;</span><br><span class="line">        <span class="string">&quot;Very long string requiring the surrounding breaks.&quot;</span>,  <span class="comment">// 非常长的字符串, 前后都需要断行.</span></span><br><span class="line">        some, other values&#125;,</span><br><span class="line">    SomeOtherType&#123;<span class="string">&quot;Slightly shorter string&quot;</span>,  <span class="comment">// 稍短的字符串.</span></span><br><span class="line">                  some, other, values&#125;&#125;;</span><br><span class="line">SomeType variable&#123;</span><br><span class="line">    <span class="string">&quot;This is too long to fit all in one line&quot;</span>&#125;;  <span class="comment">// 字符串过长, 因此无法放在同一行.</span></span><br><span class="line">MyType m = &#123;  <span class="comment">// 注意了, 您可以在 &#123; 前断行.</span></span><br><span class="line">    superlongvariablename1,</span><br><span class="line">    superlongvariablename2,</span><br><span class="line">    &#123;<span class="keyword">short</span>, interior, <span class="built_in">list</span>&#125;,</span><br><span class="line">    &#123;interiorwrappinglist,</span><br><span class="line">     interiorwrappinglist2&#125;&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><h5 id="总述-41"><a href="#总述-41" class="headerlink" title="总述"></a>总述</h5><p>倾向于不在圆括号内使用空格。关键字<font color=red><code>if</code></font>和<font color=red><code>else</code></font>另起一行。</p>
<h5 id="说明-26"><a href="#说明-26" class="headerlink" title="说明"></a>说明</h5><p>对基本条件语句有两种可以接受的格式。一种在圆括号和条件之间有空格，另一种没有。</p>
<p>最常见的是没有空格的格式，哪一种都可以，最重要的是<em>保持一致</em>，如果你是在修改一个文件，参考当前已有格式。如果是写新的代码，参考目录下或项目中其它文件。还在犹豫的话，就不要加空格了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;  <span class="comment">// 圆括号里没有空格.</span></span><br><span class="line">  ...  <span class="comment">// 2 空格缩进.</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (...) &#123;  <span class="comment">// else 与 if 的右括号同一行.</span></span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你更喜欢在圆括号内部加空格:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( condition ) &#123;  <span class="comment">// 圆括号与空格紧邻 - 不常见</span></span><br><span class="line">  ...  <span class="comment">// 2 空格缩进.</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  <span class="comment">// else 与 if 的右括号同一行.</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意所有情况下<font color=red><code>if</code></font>和左圆括号间都有个空格。右圆括号和左大括号之间也要有个空格:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition)     <span class="comment">// 差 - IF 后面没空格.</span></span><br><span class="line"><span class="keyword">if</span> (condition)&#123;   <span class="comment">// 差 - &#123; 前面没空格.</span></span><br><span class="line"><span class="keyword">if</span>(condition)&#123;    <span class="comment">// 变本加厉地差.</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;  <span class="comment">// 好 - IF 和 &#123; 都与空格紧邻.</span></span><br></pre></td></tr></table></figure>
<p>如果能增强可读性，简短的条件语句允许写在同一行。只有当语句简单并且没有使用<font color=red><code>else</code></font>子句时使用:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x == kFoo) <span class="keyword">return</span> <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="keyword">if</span> (x == kBar) <span class="keyword">return</span> <span class="keyword">new</span> Bar();</span><br></pre></td></tr></table></figure>
<p>如果语句有<font color=red><code>else</code></font>分支则不允许:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不允许 - 当有 ELSE 分支时 IF 块却写在同一行</span></span><br><span class="line"><span class="keyword">if</span> (x) DoThis();</span><br><span class="line"><span class="keyword">else</span> DoThat();</span><br></pre></td></tr></table></figure>
<p>通常，单行语句不需要使用大括号，如果你喜欢用也没问题；复杂的条件或循环语句用大括号可读性会更好。也有一些项目要求<font color=red><code>if</code></font>必须总是使用大括号:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">  DoSomething();  <span class="comment">// 2 空格缩进.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  DoSomething();  <span class="comment">// 2 空格缩进.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但如果语句中某个<font color=red><code>if-else</code></font>分支使用了大括号的话，其它分支也必须使用:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不可以这样子 - IF 有大括号 ELSE 却没有.</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  foo;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">  bar;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可以这样子 - ELSE 有大括号 IF 却没有.</span></span><br><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">  foo;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  bar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只要其中一个分支用了大括号, 两个分支都要用上大括号.</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  foo;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  bar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="循环和开关选择语句"><a href="#循环和开关选择语句" class="headerlink" title="循环和开关选择语句"></a>循环和开关选择语句</h4><h5 id="总述-42"><a href="#总述-42" class="headerlink" title="总述"></a>总述</h5><p><font color=red><code>switch</code></font>语句可以使用大括号分段，以表明font color=red&gt;<code>case</code></font>之间不是连在一起的。在单语句循环里，括号可用可不用。空循环体应使用font color=red&gt;<code>&#123;&#125;</code></font>或font color=red&gt;<code>switch</code></font>。</p>
<h5 id="说明-27"><a href="#说明-27" class="headerlink" title="说明"></a>说明</h5><p><font color=red><code>switch</code></font>语句中的<font color=red><code>case</code></font>块可以使用大括号也可以不用，取决于你的个人喜好。如果用的话，要按照下文所述的方法。</p>
<p>如果有不满足<font color=red><code>case</code></font>条件的枚举值，<font color=red><code>switch</code></font>应该总是包含一个<font color=red><code>default</code></font>匹配(如果有输入值没有<font color=red><code>case</code></font>去处理，编译器将给出warning)。如果<font color=red><code>default</code></font>应该永远执行不到，简单的加条<font color=red><code>assert</code></font>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (var) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>: &#123;  <span class="comment">// 2 空格缩进</span></span><br><span class="line">    ...      <span class="comment">// 4 空格缩进</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">default</span>: &#123;</span><br><span class="line">    assert(<span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在单语句循环里，括号可用可不用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; kSomeNumber; ++i)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;I love you\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; kSomeNumber; ++i) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;I take it back\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>空循环体应使用<font color=red><code>&#123;&#125;</code></font>或<font color=red><code>continue</code></font>，而不是一个简单的分号。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition) &#123;</span><br><span class="line">  <span class="comment">// 反复循环直到条件失效.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; kSomeNumber; ++i) &#123;&#125;  <span class="comment">// 可 - 空循环体.</span></span><br><span class="line"><span class="keyword">while</span> (condition) <span class="keyword">continue</span>;  <span class="comment">// 可 - contunue 表明没有逻辑.</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition);  <span class="comment">// 差 - 看起来仅仅只是 while/loop 的部分之一.</span></span><br></pre></td></tr></table></figure>
<h4 id="指针和引用表达式"><a href="#指针和引用表达式" class="headerlink" title="指针和引用表达式"></a>指针和引用表达式</h4><h5 id="总述-43"><a href="#总述-43" class="headerlink" title="总述"></a>总述</h5><p>句点或箭头前后不要有空格。指针/地址操作符(<font color=red><code>*，&amp;</code></font>)之后不能有空格。</p>
<h5 id="说明-28"><a href="#说明-28" class="headerlink" title="说明"></a>说明</h5><p>下面是指针和引用表达式的正确使用范例:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">x = *p;</span><br><span class="line">p = &amp;x;</span><br><span class="line">x = r.y;</span><br><span class="line">x = r-&gt;y;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>在访问成员时，句点或箭头前后没有空格。</li>
<li>指针操作符<font color=red><code>*</code></font>或<font color=red><code>&amp;</code></font>后没有空格.</li>
</ul>
<p>在声明指针变量或参数时，星号与类型或变量名紧挨都可以:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 好, 空格前置.</span></span><br><span class="line"><span class="keyword">char</span> *c;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> &amp;str;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好, 空格后置.</span></span><br><span class="line"><span class="keyword">char</span>* c;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span>&amp; str;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x, *y;  <span class="comment">// 不允许 - 在多重声明中不能使用 &amp; 或 *</span></span><br><span class="line"><span class="keyword">char</span> * c;  <span class="comment">// 差 - * 两边都有空格</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> &amp; str;  <span class="comment">// 差 - &amp; 两边都有空格.</span></span><br></pre></td></tr></table></figure>
<p>在单个文件内要保持风格一致，所以，如果是修改现有文件，要遵照该文件的风格。</p>
<h4 id="布尔表达式"><a href="#布尔表达式" class="headerlink" title="布尔表达式"></a>布尔表达式</h4><h5 id="总述-44"><a href="#总述-44" class="headerlink" title="总述"></a>总述</h5><p>如果一个布尔表达式超过<a href="">标准行宽</a>，断行方式要统一一下。</p>
<h5 id="说明-29"><a href="#说明-29" class="headerlink" title="说明"></a>说明</h5><p>下例中，逻辑与(<font color=red><code>&amp;&amp;</code></font>)操作符总位于行尾:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (this_one_thing &gt; this_other_thing &amp;&amp;</span><br><span class="line">    a_third_thing == a_fourth_thing &amp;&amp;</span><br><span class="line">    yet_another &amp;&amp; last_one) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，上例的逻辑与(<font color=red><code>&amp;&amp;</code></font>)操作符均位于行尾。这个格式在Google里很常见，虽然把所有操作符放在开头也可以。可以考虑额外插入圆括号，合理使用的话对增强可读性是很有帮助的。此外，直接用符号形式的操作符，比如<font color=red><code>&amp;&amp;</code></font>和<font color=red><code>～</code></font>，不要用词语形式的<font color=red><code>and</code></font>和<font color=red><code>compl</code></font>。</p>
<h4 id="函数返回类型"><a href="#函数返回类型" class="headerlink" title="函数返回类型"></a>函数返回类型</h4><h5 id="总述-45"><a href="#总述-45" class="headerlink" title="总述"></a>总述</h5><p>不要在<font color=red><code>return</code></font>表达式里加上非必须的圆括号。</p>
<h5 id="说明-30"><a href="#说明-30" class="headerlink" title="说明"></a>说明</h5><p>只有在写<font color=red><code>x = expr</code></font>要加上括号的时候才在<font color=red><code>return expr;</code></font>里使用括号。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> result;                  <span class="comment">// 返回值很简单, 没有圆括号.</span></span><br><span class="line"><span class="comment">// 可以用圆括号把复杂表达式圈起来, 改善可读性.</span></span><br><span class="line"><span class="keyword">return</span> (some_long_condition &amp;&amp;</span><br><span class="line">        another_condition);</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> (value);                <span class="comment">// 毕竟您从来不会写 var = (value);</span></span><br><span class="line"><span class="keyword">return</span>(result);                <span class="comment">// return 可不是函数！</span></span><br></pre></td></tr></table></figure>
<h4 id="变量及数组初始化"><a href="#变量及数组初始化" class="headerlink" title="变量及数组初始化"></a>变量及数组初始化</h4><h5 id="总述-46"><a href="#总述-46" class="headerlink" title="总述"></a>总述</h5><p>用<font color=red><code>=</code></font>，<font color=red><code>()</code></font>和<font color=red><code>&#123;&#125;</code></font>均可。</p>
<h5 id="说明-31"><a href="#说明-31" class="headerlink" title="说明"></a>说明</h5><p>您可以用<font color=red><code>=</code></font>，<font color=red><code>()</code></font>和<font color=red><code>&#123;&#125;</code></font>，以下的例子都是正确的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">x</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> x&#123;<span class="number">3</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">name</span><span class="params">(<span class="string">&quot;Some Name&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">string</span> name = <span class="string">&quot;Some Name&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> name&#123;<span class="string">&quot;Some Name&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>请务必小心列表初始化<font color=red><code>&#123;...&#125;</code></font>用<font color=red><code>std::initializer_list</code></font>构造函数初始化出的类型。非空列表初始化就会优先调用<font color=red><code>std::initializer_list</code></font>，不过空列表初始化除外，后者原则上会调用默认构造函数。为了强制禁用<font color=red><code>std::initializer_list</code></font>构造函数，请改用括号。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">100</span>, <span class="number">1</span>)</span></span>;  <span class="comment">// 内容为 100 个 1 的向量.</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">100</span>, <span class="number">1</span>&#125;;  <span class="comment">// 内容为 100 和 1 的向量.</span></span><br></pre></td></tr></table></figure>
<p>此外，列表初始化不允许整型类型的四舍五入，这可以用来避免一些类型上的编程失误。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pi</span><span class="params">(<span class="number">3.14</span>)</span></span>;  <span class="comment">// 好 - pi == 3.</span></span><br><span class="line"><span class="keyword">int</span> pi&#123;<span class="number">3.14</span>&#125;;  <span class="comment">// 编译错误: 缩窄转换.</span></span><br></pre></td></tr></table></figure>
<h4 id="预处理指令"><a href="#预处理指令" class="headerlink" title="预处理指令"></a>预处理指令</h4><h5 id="总述-47"><a href="#总述-47" class="headerlink" title="总述"></a>总述</h5><p>预处理指令不要缩进，从行首开始。</p>
<h5 id="说明-32"><a href="#说明-32" class="headerlink" title="说明"></a>说明</h5><p>即使预处理指令位于缩进代码块中，指令也应从行首开始。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 好 - 指令从行首开始</span></span><br><span class="line">  <span class="keyword">if</span> (lopsided_score) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISASTER_PENDING      <span class="comment">// 正确 - 从行首开始</span></span></span><br><span class="line">    DropEverything();</span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> NOTIFY               <span class="comment">// 非必要 - # 后跟空格</span></span></span><br><span class="line">    NotifyClient();</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    BackToNormal();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 差 - 指令缩进</span></span><br><span class="line">  <span class="keyword">if</span> (lopsided_score) &#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> DISASTER_PENDING  <span class="comment">// 差 - &quot;#if&quot; 应该放在行开头</span></span></span><br><span class="line">    DropEverything();</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span>                <span class="comment">// 差 - ”#endif“不要缩进</span></span></span><br><span class="line">    BackToNormal();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="类格式"><a href="#类格式" class="headerlink" title="类格式"></a>类格式</h4><h5 id="总述-48"><a href="#总述-48" class="headerlink" title="总述"></a>总述</h5><p>访问控制块的声明依次序是<font color=red>public:</font>，<font color=red>protected:</font>，<font color=red>private:</font>，每个都缩进 1 个空格。</p>
<h5 id="说明-33"><a href="#说明-33" class="headerlink" title="说明"></a>说明</h5><p>类声明(下面的代码中缺少注释，参考<a href="">类注释</a>)的基本格式如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> :</span> <span class="keyword">public</span> OtherClass &#123;</span><br><span class="line"> <span class="keyword">public</span>:      <span class="comment">// 注意有一个空格的缩进</span></span><br><span class="line">  MyClass();  <span class="comment">// 标准的两空格缩进</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="keyword">int</span> var)</span></span>;</span><br><span class="line">  ~MyClass() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SomeFunction</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SomeFunctionThatDoesNothing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_some_var</span><span class="params">(<span class="keyword">int</span> var)</span> </span>&#123; some_var_ = var; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">some_var</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> some_var_; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">SomeInternalFunction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> some_var_;</span><br><span class="line">  <span class="keyword">int</span> some_other_var_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<ul>
<li>所有基类名应在80列限制下尽量与子类名放在同一行。</li>
<li>关键词<font color=red>public:</font>，<font color=red>protected:</font>，<font color=red>private:</font>要缩进1个空格。</li>
<li>除第一个关键词(一般是<font color=red>public:</font>)外，其他关键词前要空一行。如果类比较小的话也可以不空。</li>
<li><font color=red>public:</font>放在最前面，然后是<font color=red>protected:</font>，最后是<font color=red>private:</font>。</li>
<li>关于声明顺序的规则请参考<a href="">声明顺序</a>一节。</li>
</ul>
<h4 id="构造函数初始化列表"><a href="#构造函数初始化列表" class="headerlink" title="构造函数初始化列表"></a>构造函数初始化列表</h4><h5 id="总述-49"><a href="#总述-49" class="headerlink" title="总述"></a>总述</h5><p>构造函数初始化列表放在同一行或按四格缩进并排多行。</p>
<h5 id="说明-34"><a href="#说明-34" class="headerlink" title="说明"></a>说明</h5><p>下面两种初始值列表方式都可以接受:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果所有变量能放在同一行:</span></span><br><span class="line">MyClass::MyClass(<span class="keyword">int</span> var) : some_var_(var) &#123;</span><br><span class="line">  DoSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不能放在同一行,</span></span><br><span class="line"><span class="comment">// 必须置于冒号后, 并缩进 4 个空格</span></span><br><span class="line">MyClass::MyClass(<span class="keyword">int</span> var)</span><br><span class="line">    : some_var_(var), some_other_var_(var + <span class="number">1</span>) &#123;</span><br><span class="line">  DoSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果初始化列表需要置于多行, 将每一个成员放在单独的一行</span></span><br><span class="line"><span class="comment">// 并逐行对齐</span></span><br><span class="line">MyClass::MyClass(<span class="keyword">int</span> var)</span><br><span class="line">    : some_var_(var),             <span class="comment">// 4 space indent</span></span><br><span class="line">      some_other_var_(var + <span class="number">1</span>) &#123;  <span class="comment">// lined up</span></span><br><span class="line">  DoSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右大括号 &#125; 可以和左大括号 &#123; 放在同一行</span></span><br><span class="line"><span class="comment">// 如果这样做合适的话</span></span><br><span class="line">MyClass::MyClass(<span class="keyword">int</span> var)</span><br><span class="line">    : some_var_(var) &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="命名空间格式化"><a href="#命名空间格式化" class="headerlink" title="命名空间格式化"></a>命名空间格式化</h4><h5 id="总述-50"><a href="#总述-50" class="headerlink" title="总述"></a>总述</h5><p>命名空间内容不缩进。</p>
<h5 id="说明-35"><a href="#说明-35" class="headerlink" title="说明"></a>说明</h5><p><a href="">命名空间</a>不要增加额外的缩进层次，例如:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;  <span class="comment">// 正确. 命名空间内没有额外的缩进.</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace</span></span><br></pre></td></tr></table></figure>
<p>不要在命名空间内缩进:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 错, 缩进多余了.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace</span></span><br></pre></td></tr></table></figure>
<p>声明嵌套命名空间时，每个命名空间都独立成行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> foo &#123;</span><br><span class="line"><span class="keyword">namespace</span> bar &#123;</span><br></pre></td></tr></table></figure>
<h4 id="水平留白"><a href="#水平留白" class="headerlink" title="水平留白"></a>水平留白</h4><h5 id="总述-51"><a href="#总述-51" class="headerlink" title="总述"></a>总述</h5><p>水平留白的使用根据在代码中的位置决定，永远不要在行尾添加没意义的留白。</p>
<h5 id="说明-36"><a href="#说明-36" class="headerlink" title="说明"></a>说明</h5><p><strong>通用</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">bool</span> b)</span> </span>&#123;  <span class="comment">// 左大括号前总是有空格.</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;  <span class="comment">// 分号前不加空格.</span></span><br><span class="line"><span class="comment">// 列表初始化中大括号内的空格是可选的.</span></span><br><span class="line"><span class="comment">// 如果加了空格, 那么两边都要加上.</span></span><br><span class="line"><span class="keyword">int</span> x[] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> x[] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承与初始化列表中的冒号前后恒有空格.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> :</span> <span class="keyword">public</span> Bar &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 对于单行函数的实现, 在大括号内加上空格</span></span><br><span class="line">  <span class="comment">// 然后是函数实现</span></span><br><span class="line">  Foo(<span class="keyword">int</span> b) : Bar(), baz_(b) &#123;&#125;  <span class="comment">// 大括号里面是空的话, 不加空格.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Reset</span><span class="params">()</span> </span>&#123; baz_ = <span class="number">0</span>; &#125;  <span class="comment">// 用括号把大括号与实现分开.</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>添加冗余的留白会给其他人编辑时造成额外负担。因此，行尾不要留空格。如果确定一行代码已经修改完毕，将多余的空格去掉；或者在专门清理空格时去掉（尤其是在没有其他人在处理这件事的时候)。</p>
<p><strong>循环和条件语句</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (b) &#123;          <span class="comment">// if 条件语句和循环语句关键字后均有空格.</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;          <span class="comment">// else 前后有空格.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (test) &#123;&#125;   <span class="comment">// 圆括号内部不紧邻空格.</span></span><br><span class="line"><span class="keyword">switch</span> (i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line"><span class="keyword">switch</span> ( i ) &#123;    <span class="comment">// 循环和条件语句的圆括号里可以与空格紧邻.</span></span><br><span class="line"><span class="keyword">if</span> ( test ) &#123;     <span class="comment">// 圆括号, 但这很少见. 总之要一致.</span></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i ) &#123;</span><br><span class="line"><span class="keyword">for</span> ( ; i &lt; <span class="number">5</span> ; ++i) &#123;  <span class="comment">// 循环里内 ; 后恒有空格, ;  前可以加个空格.</span></span><br><span class="line"><span class="keyword">switch</span> (i) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:         <span class="comment">// switch case 的冒号前无空格.</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">break</span>;  <span class="comment">// 如果冒号有代码, 加个空格.</span></span><br></pre></td></tr></table></figure>
<p><strong>操作符</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 赋值运算符前后总是有空格.</span></span><br><span class="line">x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其它二元操作符也前后恒有空格, 不过对于表达式的子式可以不加空格.</span></span><br><span class="line"><span class="comment">// 圆括号内部没有紧邻空格.</span></span><br><span class="line">v = w * x + y / z;</span><br><span class="line">v = w*x + y/z;</span><br><span class="line">v = w * (x + z);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在参数和一元操作符之间不加空格.</span></span><br><span class="line">x = <span class="number">-5</span>;</span><br><span class="line">++x;</span><br><span class="line"><span class="keyword">if</span> (x &amp;&amp; !y)</span><br></pre></td></tr></table></figure>
<p><strong>模板和转换</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 尖括号(&lt; and &gt;) 不与空格紧邻, &lt; 前没有空格, &gt; 和 ( 之间也没有.</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; x;</span><br><span class="line">y = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在类型与指针操作符之间留空格也可以, 但要保持一致.</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">char</span> *&gt; x;</span><br></pre></td></tr></table></figure>
<h4 id="垂直留白"><a href="#垂直留白" class="headerlink" title="垂直留白"></a>垂直留白</h4><h5 id="总述-52"><a href="#总述-52" class="headerlink" title="总述"></a>总述</h5><p>垂直留白越少越好.</p>
<h5 id="说明-37"><a href="#说明-37" class="headerlink" title="说明"></a>说明</h5><p>这不仅仅是规则而是原则问题了：不在万不得已，不要使用空行。尤其是: 两个函数定义之间的空行不要超过2行，函数体首尾不要留空行，函数体中也不要随意添加空行。</p>
<p>基本原则是: 同一屏可以显示的代码越多，越容易理解程序的控制流。当然，过于密集的代码块和过于疏松的代码块同样难看，这取决于你的判断。但通常是垂直留白越少越好。</p>
<p>下面的规则可以让加入的空行更有效:</p>
<ul>
<li>函数体内开头或结尾的空行可读性微乎其微。</li>
<li>在多重if-else块里加空行或许有点可读性。</li>
</ul>
<h3 id="规则特例"><a href="#规则特例" class="headerlink" title="规则特例"></a>规则特例</h3><p>前面说明的编程习惯基本都是强制性的。但所有优秀的规则都允许例外，这里就是探讨这些特例。</p>
<h4 id="现有不合规范代码"><a href="#现有不合规范代码" class="headerlink" title="现有不合规范代码"></a>现有不合规范代码</h4><h5 id="总述-53"><a href="#总述-53" class="headerlink" title="总述"></a>总述</h5><p>对于现有不符合既定编程风格的代码可以网开一面。</p>
<h5 id="说明-38"><a href="#说明-38" class="headerlink" title="说明"></a>说明</h5><p>当你修改使用其他风格的代码时，为了与代码原有风格保持一致可以不使用本指南约定。如果不放心， 可以与代码原作者或现在的负责人员商讨。记住，<em>一致性</em>也包括原有的一致性。</p>
<h4 id="Windows代码"><a href="#Windows代码" class="headerlink" title="Windows代码"></a>Windows代码</h4><h5 id="总述-54"><a href="#总述-54" class="headerlink" title="总述"></a>总述</h5><p>Windows程序员有自己的编程习惯，主要源于Windows头文件和其它Microsoft代码。我们希望任何人都可以顺利读懂你的代码，所以针对所有平台的C++编程只给出一个单独的指南。</p>
<h5 id="说明-39"><a href="#说明-39" class="headerlink" title="说明"></a>说明</h5><p>如果你习惯使用Windows编码风格，这儿有必要重申一下某些你可能会忘记的指南:</p>
<ul>
<li>不要使用匈牙利命名法(比如把整型变量命名成<font color=red><code>iNum</code></font>)。使用 Google命名约定，包括对源文件使用<font color=red><code>.cc</code></font>扩展名。</li>
<li>Windows定义了很多原生类型的同义词，如<font color=red><code>DWORD</code></font>、<font color=red><code>HANDLE</code></font>等等。在调用Windows API时这是完全可以接受甚至鼓励的。即使如此，还是尽量使用原有的C++类型，例如使用<font color=red><code>const TCHAR *</code></font>而不是 <font color=red><code>LPCSTR</code></font>。</li>
<li>使用Microsoft Visual C++进行编译时，将警告级别设置为3或更高，并将所有警告(warnings)当作错误(errors)处理.</li>
<li>不要使用<font color=red><code>#pragma once</code></font>；而应该使用Google的头文件保护规则。 头文件保护的路径应该相对于项目根目录。</li>
<li>除非万不得已，不要使用任何非标准的扩展，如<font color=red><code>#program</code></font>和<font color=red><code>__declspec</code></font>。使用<font color=red><code>__declspec(dllimport)</code></font>和<font color=red><code>__declspec(dllxeport)</code></font>是允许的，但必须通过宏来使用，比如 <font color=red><code>DLLIMPORT</code></font>和<font color=red><code>DLLEXPORT</code></font> ，这样其他人在分享使用这些代码时可以很容易地禁用这些扩展。</li>
</ul>
<p>然而，在Windows上仍然有一些我们偶尔需要违反的规则:</p>
<ul>
<li>通常我们<a href="">禁止使用多重继承</a>，但在使用COM和ATL/WTL类时可以使用多重继承。为了实现COM或 ATL/WTL类/接口，你可能不得不使用多重实现继承。</li>
<li>虽然代码中不应该使用异常，但是在ATL和部分STL（包括Visual C++的STL)中异常被广泛使用。使用ATL时，应定义<font color=red><code>_ATL_NO_EXCEPTIONS</code></font> 以禁用异常。你需要研究一下是否能够禁用STL的异常，如果无法禁用，可以启用编译器异常。(注意这只是为了编译STL，自己的代码里仍然不应当包含异常处理)。</li>
<li>通常为了利用头文件预编译，每个每个源文件的开头都会包含一个名为<font color=red><code>StdAfx.h</code></font>或<font color=red><code>precompile.h</code></font>的文件。为了使代码方便与其他项目共享，请避免显式包含此文件(除了在<font color=red><code>precompile.cc</code></font>中)，使用<font color=red><code>/FI</code></font>编译器选项以自动包含该文件.</li>
<li>资源头文件通常命名为<font color=red><code>resource.h</code></font>且只包含宏，这一文件不需要遵守本风格指南。</li>
</ul>
<h3 id="来自Google的奇特（Cpplint）"><a href="#来自Google的奇特（Cpplint）" class="headerlink" title="来自Google的奇特（Cpplint）"></a>来自Google的奇特（Cpplint）</h3><p>Google用了很多自己实现的技巧/工具使C++代码更加健壮，我们使用C++的方式可能和你在其它地方见到的有所不同。</p>
<h4 id="所有权与智能指针"><a href="#所有权与智能指针" class="headerlink" title="所有权与智能指针"></a>所有权与智能指针</h4><h5 id="gt-总述"><a href="#gt-总述" class="headerlink" title="&gt; 总述"></a>&gt; 总述</h5><p>动态分配出的对象最好有单一且固定的所有主，并通过智能指针传递所有权。</p>
<h5 id="gt-定义"><a href="#gt-定义" class="headerlink" title="&gt; 定义"></a>&gt; 定义</h5><p>所有权是一种登记／管理动态内存和其它资源的技术。动态分配对象的所有主是一个对象或函数，后者负责确保当前者无用时就自动销毁前者。所有权有时可以共享，此时就由最后一个所有主来负责销毁它。甚至也可以不用共享，在代码中直接把所有权传递给其它对象。</p>
<p>智能指针是一个通过重载<font color=red><code>*</code></font>和<font color=red><code>-&gt;</code></font>运算符以表现得如指针一样的类。智能指针类型被用来自动化所有权的登记工作，来确保执行销毁义务到位。<a href="http://en.cppreference.com/w/cpp/memory/unique_ptr">std::unique_ptr</a>是C++11新推出的一种智能指针类型，用来表示动态分配出的对象的独一无二的所有权；当<a href="http://en.cppreference.com/w/cpp/memory/unique_ptr">std::unique_ptr</a>离开作用域时，对象就会被销毁。<font color=red><code>std::unique_ptr</code></font>不能被复制，但可以把它移动（move）给新所有主。std::unique_ptr](<a href="http://en.cppreference.com/w/cpp/memory/unique_ptr)%E5%90%8C%E6%A0%B7%E8%A1%A8%E7%A4%BA%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%8C%E4%BD%86%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%85%B1%E4%BA%AB%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%A4%8D%E5%88%B6%EF%BC%9B%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83%E7%94%B1%E6%89%80%E6%9C%89%E5%A4%8D%E5%88%B6%E8%80%85%E5%85%B1%E5%90%8C%E6%8B%A5%E6%9C%89%EF%BC%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%A4%8D%E5%88%B6%E8%80%85%E8%A2%AB%E9%94%80%E6%AF%81%E6%97%B6%EF%BC%8C%E5%AF%B9%E8%B1%A1%E4%B9%9F%E4%BC%9A%E9%9A%8F%E7%9D%80%E8%A2%AB%E9%94%80%E6%AF%81%E3%80%82">http://en.cppreference.com/w/cpp/memory/unique_ptr)同样表示动态分配对象的所有权，但可以被共享，也可以被复制；对象的所有权由所有复制者共同拥有，最后一个复制者被销毁时，对象也会随着被销毁。</a></p>
<h5 id="gt-优点"><a href="#gt-优点" class="headerlink" title="&gt; 优点"></a>&gt; 优点</h5><ul>
<li>如果没有清晰、逻辑条理的所有权安排，不可能管理好动态分配的内存。</li>
<li>传递对象的所有权，开销比复制来得小，如果可以复制的话。</li>
<li>传递所有权也比”借用”指针或引用来得简单，毕竟它大大省去了两个用户一起协调对象生命周期的工作。</li>
<li>如果所有权逻辑条理，有文档且不紊乱的话，可读性会有很大提升。</li>
<li>可以不用手动完成所有权的登记工作，大大简化了代码，也免去了一大波错误之恼。</li>
<li>对于const对象来说，智能指针简单易用，也比深度复制高效。</li>
</ul>
<h5 id="gt-缺点"><a href="#gt-缺点" class="headerlink" title="&gt; 缺点"></a>&gt; 缺点</h5><ul>
<li>不得不用指针（不管是智能的还是原生的）来表示和传递所有权。指针语义可要比值语义复杂得许多了，特别是在API里：这时不光要操心所有权，还要顾及别名、生命周期、可变性以及其它大大小小的问题。</li>
<li>其实值语义的开销经常被高估，所以所有权传递带来的性能提升不一定能弥补可读性和复杂度的损失。</li>
<li>如果API依赖所有权的传递，就会害得客户端不得不用单一的内存管理模型。</li>
<li>如果使用智能指针，那么资源释放发生的位置就会变得不那么明显。</li>
<li><font color=red><code>std::unique_ptr</code></font>的所有权传递原理是C++11的move语法，后者毕竟是刚刚推出的，容易迷惑程序员。</li>
<li>如果原本的所有权设计已经够完善了，那么若要引入所有权共享机制，可能不得不重构整个系统。</li>
<li>所有权共享机制的登记工作在运行时进行，开销可能相当大。</li>
<li>某些极端情况下 (例如循环引用)，所有权被共享的对象永远不会被销毁。</li>
<li>智能指针并不能够完全代替原生指针。</li>
</ul>
<h5 id="gt-结论"><a href="#gt-结论" class="headerlink" title="&gt; 结论"></a>&gt; 结论</h5><p>如果必须使用动态分配，那么更倾向于将所有权保持在分配者手中。如果其他地方要使用这个对象，最好传递它的拷贝，或者传递一个不用改变所有权的指针或引用。倾向于使用<font color=red><code>std::unique_ptr</code></font>来明确所有权传递，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Foo&gt; <span class="title">FooFactory</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FooConsumer</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Foo&gt; ptr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果没有很好的理由，则不要使用共享所有权。这里的理由可以是为了避免开销昂贵的拷贝操作，但是只有当性能提升非常明显，并且操作的对象是不可变的（比如说<font color=red><code>std::shared_ptr&lt;const Foo&gt;</code></font>）时候，才能这么做。如果确实要使用共享所有权, 建议于使用<font color=red><code>std::shared_ptr</code></font>.</p>
<p>不要使用<font color=red><code>std::auto_ptr</code></font>，使用<font color=red><code>std::unique_ptr</code></font>代替它.</p>
<h4 id="Cpplint"><a href="#Cpplint" class="headerlink" title="Cpplint"></a>Cpplint</h4><h5 id="gt-总述-1"><a href="#gt-总述-1" class="headerlink" title="&gt; 总述"></a>&gt; 总述</h5><p>使用<font color=red><code>cpplint.py</code></font>检查风格错误。</p>
<h5 id="gt-说明"><a href="#gt-说明" class="headerlink" title="&gt; 说明"></a>&gt; 说明</h5><p><font color=red><code>cpplint.py</code></font>是一个用来分析源文件，能检查出多种风格错误的工具，它不并完美，甚至还会漏报和误报，但它仍然是一个非常有用的工具。在行尾加<font color=red><code>//NOLINT</code></font>或在上一行加<font color=red><code>// NOLINTNEXTLINE</code></font>，可以忽略报错。</p>
<p>某些项目会指导你如何使用他们的项目工具运行 <font color=red><code>cpplint.py</code></font>。如果你参与的项目没有提供，你可以单独下载<a href="https://github.com/google/styleguide/blob/gh-pages/cpplint/cpplint.py">cpplint.py</a>。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Python Style of Google</title>
    <url>/python/python_style_of_google/</url>
    <content><![CDATA[<h2 id="Python风格指南-Google版"><a href="#Python风格指南-Google版" class="headerlink" title="Python风格指南(Google版)"></a>Python风格指南(Google版)</h2><p>Python 是 Google主要的脚本语言。这本风格指南主要包含的是针对python的编程准则。使得Python代码编写更加规范、优美。</p>
<h3 id="Python语言规范"><a href="#Python语言规范" class="headerlink" title="Python语言规范"></a>Python语言规范</h3><h4 id="Lint"><a href="#Lint" class="headerlink" title="Lint"></a>Lint</h4><p>对你的代码允许pylint</p>
<h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h5><p>pylint是一个在Python源代码中查找bug的工具。对于C和C++这样的不那么动态的语言，这些bug通常由编译器来捕获。由于Python的动态特性，有些警告可能不对。不过伪告警应该很少。</p>
<h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><p>可以捕获容易忽视的错误，例如输入错误、使用未赋值的变量等。</p>
<h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><p>pylint并不不完美。要利用其优势，我们有时侯需要:</p>
<ul>
<li>围绕着它来写代码</li>
<li>抑制其告警</li>
<li>改进它</li>
<li>忽略它</li>
</ul>
<h5 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h5><p>确保对你的代码运行pylint。抑制不准确的警告，以便能够将其他警告暴露出来。</p>
<p>你可以通过设置一个行注释来抑制告警。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dict</span> = <span class="string">&#x27;something awful&#x27;</span>  <span class="comment"># Bad Idea... pylint: disable=redefined-builtin</span></span><br></pre></td></tr></table></figure>
<p>pylint警告是以一个数字编号(如<font color=red size=4><code>C0112</code></font>)和一个符号名(如<font color=red size=4><code>empty-docstring</code></font>)来标识的。在编写新代码或更新已有代码时对告警进行抑制，推荐使用符号名来标识。</p>
<p>如果警告的符号名不够见名知意，那么请对其增加一个详细解释。</p>
<p>采用这种抑制方式的好处是我们可以轻松查找抑制并回顾它们。</p>
<p>你可以使用命令<font color=red size=4><code>pylint --list-msgs</code></font>来获取pylint告警列表. 你可以使用命令<font color=red size=4><code>pylint --help-msg=C6409</code></font>，以获取关于特定消息的更多信息。</p>
<p>相比较于之前使用的<font color=red size=4><code>pylint: disable-msg</code></font>，本文推荐使用<font color=red size=4><code>pylint: disable</code></font>。</p>
<p>要抑制”参数未使用”告警，你可以用”_”作为参数标识符, 或者在参数名前加”unused_”。遇到不能改变参数名的情况，你可以通过在函数开头”提到”它们来消除告警。例如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">a, unused_b, unused_c, d=<span class="literal">None</span>, e=<span class="literal">None</span></span>):</span></span><br><span class="line">    _ = d, e</span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><p>仅对包和模块使用导入</p>
<h5 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h5><p>模块间共享代码的重用机制。</p>
<h5 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h5><p>命名空间管理约定十分简单。每个标识符的源都用一种一致的方式指示。x.Obj表示Obj对象定义在模块X中。</p>
<h5 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h5><p>模块名仍有可能冲突。有些模块名太长，不太方便。</p>
<h5 id="结论：-1"><a href="#结论：-1" class="headerlink" title="结论："></a>结论：</h5><ol>
<li>使用<font color=red size=4><code>import x</code></font>来导入包和模块。</li>
<li>使用<font color=red size=4><code>from x import y</code></font>，其中x是包前缀，y是不带前缀的模块名。</li>
<li>使用<font color=red size=4><code>from x import y as z</code></font>，如果两个要导入的模块都叫做y或者有太长了。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sound.effects <span class="keyword">import</span> echo</span><br><span class="line">...</span><br><span class="line">echo.EchoFilter(<span class="built_in">input</span>, output, delay=<span class="number">0.7</span>, atten=<span class="number">4</span>)</span><br></pre></td></tr></table></figure></li>
<li>导入时不要使用相对名称。即使模块在同一个包中，也要使用完整包名。这能帮助你避免无意间导入一个包两次。</li>
</ol>
<h4 id="包"><a href="#包" class="headerlink" title="包"></a>包</h4><p>使用模块的全路径名来导入每个模块。</p>
<h5 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h5><p>避免模块名冲突。查找包更容易。</p>
<h5 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h5><p>部署代码变难，因为你必须复制包层次。</p>
<h5 id="结论：-2"><a href="#结论：-2" class="headerlink" title="结论："></a>结论：</h5><p>所用的新代码都应该用完整包名来导入每个模块。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Reference in code with complete name.</span></span><br><span class="line"><span class="keyword">import</span> sound.effects.echo</span><br><span class="line"></span><br><span class="line"><span class="comment"># Reference in code with just module name (preferred).</span></span><br><span class="line"><span class="keyword">from</span> sound.effects <span class="keyword">import</span> echo</span><br></pre></td></tr></table></figure>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p>允许使用异常，但必须小心。</p>
<h5 id="定义：-2"><a href="#定义：-2" class="headerlink" title="定义："></a>定义：</h5><p>异常是一种跳出代码块的正常控制流程来处理错误或者其他异常条件的方式。</p>
<h5 id="优点：-3"><a href="#优点：-3" class="headerlink" title="优点："></a>优点：</h5><p>正常操作代码的控制流不会和错误处理代码混在一起。当某种条件发生时，它也允许控制流跳过多个框架。例如，一步跳出N个嵌套的函数，而不必继续执行错误的代码。</p>
<h5 id="缺点：-3"><a href="#缺点：-3" class="headerlink" title="缺点："></a>缺点：</h5><p>可能会导致让人困惑的控制流。调用库时容易错过错误情况。</p>
<h5 id="结论：-3"><a href="#结论：-3" class="headerlink" title="结论："></a>结论：</h5><p>异常必须遵守特定条件：</p>
<ol>
<li>像这样触发异常:<font color=red size=4><code>raise MyException(&quot;Error message&quot;)</code></font>或者<font color=red size=4><code>raise MyException</code></font>。不要使用两个参数的形式(<font color=red size=4><code>raise MyException，&quot;Error message&quot;</code></font>)或者过时的字符串异常( <font color=red size=4><code>raise &quot;Error message&quot;)</code></font>。</li>
<li>模块或包应该定义自己的特定域的异常基类，这个基类应该从内建的Exception类继承。模块的异常基类应该叫做”Error”。</li>
<li>永远不要使用<font color=red size=4><code>except:</code></font>语句来捕获所有异常，也不要捕获<font color=red size=4><code>Exception</code></font>或者<font color=red size=4><code>StandardError</code></font>，除非你打算重新触发该异常，或者你已经在当前线程的最外层(记得还是要打印一条错误消息)。在异常这方面，Python非常宽容，<font color=red size=4><code>except:</code></font>真的会捕获包括Python语法错误在内的任何错误。使用 <font color=red size=4><code>except:</code></font>很容易隐藏真正的bug。</li>
<li>尽量减少try/except块中的代码量。try块的体积越大，期望之外的异常就越容易被触发。这种情况下，try/except块将隐藏真正的错误。</li>
<li>使用finally子句来执行那些无论try块中有没有异常都应该被执行的代码。这对于清理资源常常很有用，例如关闭文件。</li>
<li>当捕获异常时, 使用<font color=red size=4><code>as</code></font>而不要用逗号。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> Error</span><br><span class="line"><span class="keyword">except</span> Error <span class="keyword">as</span> error:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4>避免全局变量<h5 id="定义：-3"><a href="#定义：-3" class="headerlink" title="定义："></a>定义：</h5>定义模块级的变量。<h5 id="优点：-4"><a href="#优点：-4" class="headerlink" title="优点："></a>优点：</h5>偶尔使用。<h5 id="缺点：-4"><a href="#缺点：-4" class="headerlink" title="缺点："></a>缺点：</h5>导入时可能改变模块行为，因为导入模块时会对模块级变量赋值。<h5 id="结论：-4"><a href="#结论：-4" class="headerlink" title="结论："></a>结论：</h5>避免使用全局变量，用类变量来代替。但有一些例外：</li>
<li>脚本的默认选项。</li>
<li>模块级常量。</li>
<li>有时候用全局变量来缓存值或者作为函数返回值很有用。</li>
<li>如果需要，全局变量应该仅在模块内部作用，并通过模块级的公共函数来访问。</li>
</ol>
<h4 id="嵌套、局部、内部类或函数"><a href="#嵌套、局部、内部类或函数" class="headerlink" title="嵌套、局部、内部类或函数"></a>嵌套、局部、内部类或函数</h4><p>鼓励使用嵌套、本地、内部类或函数</p>
<h5 id="定义：-4"><a href="#定义：-4" class="headerlink" title="定义："></a>定义：</h5><p>类可以定在方法、函数或者类中。函数可以定义在方法或函数中，封闭区间中定义的变量对嵌套函数是只读的。</p>
<h5 id="优点：-5"><a href="#优点：-5" class="headerlink" title="优点："></a>优点：</h5><p>允许定义仅用于有效函数的工具类和函数。</p>
<h5 id="缺点：-5"><a href="#缺点：-5" class="headerlink" title="缺点："></a>缺点：</h5><p>嵌套类或局部类的实例不能序列化（picked）。</p>
<h5 id="结论：-5"><a href="#结论：-5" class="headerlink" title="结论："></a>结论：</h5><p>推荐使用。</p>
<h4 id="列表推导（List-Comprehensions）"><a href="#列表推导（List-Comprehensions）" class="headerlink" title="列表推导（List Comprehensions）"></a>列表推导（List Comprehensions）</h4><p>可以在简单情况下使用。</p>
<h5 id="定义：-5"><a href="#定义：-5" class="headerlink" title="定义："></a>定义：</h5><p>列表推导(list comprehensions)与生成器表达式(generator expression)提供了一种简洁高效的方式来创建列表和迭代器，而不必借助map()，filter()，或者lambda。</p>
<h5 id="优点：-6"><a href="#优点：-6" class="headerlink" title="优点："></a>优点：</h5><p>简单的列表推导可以比其它的列表创建方法更加清晰简单。生成器表达式可以十分高效，因为它们避免了创建整个列表。</p>
<h5 id="缺点：-6"><a href="#缺点：-6" class="headerlink" title="缺点："></a>缺点：</h5><p>复杂的列表推导或者生成器表达式可能难以阅读。</p>
<h5 id="结论：-6"><a href="#结论：-6" class="headerlink" title="结论："></a>结论：</h5><p>适用于简单情况。每个部分应该单独置于一行: 映射表达式，for语句，过滤器表达式。禁止多重for语句或过滤器表达式。复杂情况下还是使用循环。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = []</span><br><span class="line">  <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">      <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">          <span class="keyword">if</span> x * y &gt; <span class="number">10</span>:</span><br><span class="line">              result.append((x, y))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">5</span>):</span><br><span class="line">      <span class="keyword">for</span> y <span class="keyword">in</span> xrange(<span class="number">5</span>):</span><br><span class="line">          <span class="keyword">if</span> x != y:</span><br><span class="line">              <span class="keyword">for</span> z <span class="keyword">in</span> xrange(<span class="number">5</span>):</span><br><span class="line">                  <span class="keyword">if</span> y != z:</span><br><span class="line">                      <span class="keyword">yield</span> (x, y, z)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ((x, complicated_transform(x))</span><br><span class="line">          <span class="keyword">for</span> x <span class="keyword">in</span> long_generator_function(parameter)</span><br><span class="line">          <span class="keyword">if</span> x <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">  squares = [x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line">  eat(jelly_bean <span class="keyword">for</span> jelly_bean <span class="keyword">in</span> jelly_beans</span><br><span class="line">      <span class="keyword">if</span> jelly_bean.color == <span class="string">&#x27;black&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="默认迭代器和操作符"><a href="#默认迭代器和操作符" class="headerlink" title="默认迭代器和操作符"></a>默认迭代器和操作符</h4><p>如果类型支持,就使用默认迭代器和操作符.比如列表、字典及文件等。</p>
<h5 id="定义：-6"><a href="#定义：-6" class="headerlink" title="定义："></a>定义：</h5><p>容器类型，像字典和列表，定义了默认的迭代器和关系测试操作符(in和not in)。</p>
<h5 id="优点：-7"><a href="#优点：-7" class="headerlink" title="优点："></a>优点：</h5><p>默认操作符和迭代器简单高效，它们直接表达了操作，没有额外的方法调用。使用默认操作符的函数是通用的。它可以用于支持该操作的任何类型。</p>
<h5 id="缺点：-7"><a href="#缺点：-7" class="headerlink" title="缺点："></a>缺点：</h5><p>没法通过阅读方法名来区分对象的类型(例如has_key()意味着字典)。不过这也是优点。</p>
<h5 id="结论：-7"><a href="#结论：-7" class="headerlink" title="结论："></a>结论：</h5><p>如果类型支持，就使用默认迭代器和操作符，例如列表、字典和文件。内建类型也定义了迭代器方法。优先考虑这些方法，而不是那些返回列表的方法。当然，这样遍历容器时，你将不能修改容器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> adict: ...</span><br><span class="line"><span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> adict: ...</span><br><span class="line"><span class="keyword">if</span> obj <span class="keyword">in</span> alist: ...</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> afile: ...</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">dict</span>.iteritems(): ...</span><br></pre></td></tr></table></figure>
<h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><p>按需使用生成器.</p>
<h5 id="定义：-7"><a href="#定义：-7" class="headerlink" title="定义："></a>定义：</h5><p>所谓生成器函数，就是每当它执行一次生成(yield)语句，它就返回一个迭代器，这个迭代器生成一个值。生成值后，生成器函数的运行状态将被挂起，直到下一次生成。</p>
<h5 id="优点：-8"><a href="#优点：-8" class="headerlink" title="优点："></a>优点：</h5><p>简化代码，因为每次调用时，局部变量和控制流的状态都会被保存。比起一次创建一系列值的函数， 生成器使用的内存更少。</p>
<h5 id="缺点：-8"><a href="#缺点：-8" class="headerlink" title="缺点："></a>缺点：</h5><p>没有。</p>
<h5 id="结论：-8"><a href="#结论：-8" class="headerlink" title="结论："></a>结论：</h5><p>鼓励使用。注意在生成器函数的文档字符串中使用”Yields:”而不是”Returns:”。</p>
<h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><p>适用于单行函数</p>
<h5 id="定义：-8"><a href="#定义：-8" class="headerlink" title="定义："></a>定义：</h5><p>与语句相反，lambda在一个表达式中定义匿名函数。常用于为&lt;/font color=red&gt;<code>map()</code></font>和&lt;/font color=red&gt;<code>filter()</code></font>之类的高阶函数定义回调函数或者操作符。</p>
<h5 id="优点：-9"><a href="#优点：-9" class="headerlink" title="优点："></a>优点：</h5><p>方便。</p>
<h5 id="缺点：-9"><a href="#缺点：-9" class="headerlink" title="缺点："></a>缺点：</h5><p>比本地函数更难阅读和调试。没有函数名意味着堆栈跟踪更难理解。由于lambda函数通常只包含一个表达式，因此其表达能力有限。</p>
<h5 id="结论：-9"><a href="#结论：-9" class="headerlink" title="结论："></a>结论：</h5><p>适用于单行函数。如果代码超过60-80个字符，最好还是定义成常规(嵌套)函数。</p>
<p>对于常见的操作符，例如乘法操作符，使用<font color=red><code>operator</code></font>模块中的函数以代替lambda函数. 例如, 推荐使用<font color=red><code>operator.mul</code></font>, 而不是<font color=red><code>lambda x, y: x * y</code></font>.</p>
<h4 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h4><p>适用于单行函数。</p>
<h5 id="定义：-9"><a href="#定义：-9" class="headerlink" title="定义："></a>定义：</h5><p>条件表达式是对于if语句的一种更为简短的句法规则。例如:<font color=red><code>x = 1 if cond else 2</code></font>。</p>
<h5 id="优点：-10"><a href="#优点：-10" class="headerlink" title="优点："></a>优点：</h5><p>比if语句更加简短和方便。</p>
<h5 id="缺点：-10"><a href="#缺点：-10" class="headerlink" title="缺点："></a>缺点：</h5><p>比if语句难于阅读。如果表达式很长，难于定位条件。</p>
<h5 id="结论：-10"><a href="#结论：-10" class="headerlink" title="结论："></a>结论：</h5><p>适用于单行函数。在其他情况下，推荐使用完整的if语句。</p>
<h4 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h4><p>适用于大部分情况。</p>
<h5 id="定义：-10"><a href="#定义：-10" class="headerlink" title="定义："></a>定义：</h5><p>你可以在函数参数列表的最后指定变量的值，例如<font color=red>def foo(a, b = 0):</font>。如果调用foo时只带一个参数，则b被设为0。如果带两个参数，则b的值等于第二个参数。</p>
<h5 id="优点：-11"><a href="#优点：-11" class="headerlink" title="优点："></a>优点：</h5><p>你经常会碰到一些使用大量默认值的函数，但偶尔(比较少见)你想要覆盖这些默认值。默认参数值提供了一种简单的方法来完成这件事，你不需要为这些罕见的例外定义大量函数。同时，Python也不支持重载方法和函数，默认参数是一种”仿造”重载行为的简单方式。</p>
<h5 id="缺点：-11"><a href="#缺点：-11" class="headerlink" title="缺点："></a>缺点：</h5><p>默认参数只在模块加载时求值一次。如果参数是列表或字典之类的可变类型，这可能会导致问题。如果函数修改了对象(例如向列表追加项)，默认值就被修改了。</p>
<h5 id="结论：-11"><a href="#结论：-11" class="headerlink" title="结论："></a>结论：</h5><p>鼓励使用。不过有如下注意事项:</p>
<p>不要在函数或方法定义中使用可变对象作为默认值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">a, b=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> b <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        b = []</span><br></pre></td></tr></table></figure>
<h4 id="属性（properties）"><a href="#属性（properties）" class="headerlink" title="属性（properties）"></a>属性（properties）</h4><p>访问和设置数据成员时，你通常会使用简单，轻量级的访问和设置函数。建议用属性（properties）来代替它们。</p>
<h5 id="定义：-11"><a href="#定义：-11" class="headerlink" title="定义："></a>定义：</h5><p>一种用于包装方法调用的方式。当运算量不大，它是获取和设置属性(attribute)的标准方式。</p>
<h5 id="优点：-12"><a href="#优点：-12" class="headerlink" title="优点："></a>优点：</h5><p>通过消除简单的属性(attribute)访问时显式的get和set方法调用，可读性提高了。允许懒惰的计算。用Pythonic的方式来维护类的接口。就性能而言，当直接访问变量是合理的，添加访问方法就显得琐碎而无意义。使用属性(properties)可以绕过这个问题。将来也可以在不破坏接口的情况下将访问方法加上。</p>
<h5 id="缺点：-12"><a href="#缺点：-12" class="headerlink" title="缺点："></a>缺点：</h5><p>属性(properties)是在get和set方法声明后指定，这需要使用者在接下来的代码中注意:set和get是用于属性(properties)的(除了用<font color=red><code>property</code></font>装饰器创建的只读属性)。必须继承自object类。可能隐藏比如操作符重载之类的副作用.。继承时可能会让人困惑。</p>
<h5 id="结论：-12"><a href="#结论：-12" class="headerlink" title="结论："></a>结论：</h5><p>你通常习惯于使用访问或设置方法来访问或设置数据，它们简单而轻量。不过我们建议你在新的代码中使用属性。只读属性应该用<font color=red><code>property</code></font>装饰器来创建。</p>
<p>如果子类没有覆盖属性，那么属性的继承可能看上去不明显。因此使用者必须确保访问方法间接被调用，以保证子类中的重载方法被属性调用(使用模板方法设计模式)。</p>
<h4 id="Ture、False的求值"><a href="#Ture、False的求值" class="headerlink" title="Ture、False的求值"></a>Ture、False的求值</h4><p>尽可能使用隐式false。</p>
<h5 id="定义：-12"><a href="#定义：-12" class="headerlink" title="定义："></a>定义：</h5><p>Python在布尔上下文中会将某些值求值为false。按简单的直觉来讲，就是所有的”空”值都被认为是false。因此0，None，[]，{}，“” 都被认为是false。</p>
<h5 id="优点：-13"><a href="#优点：-13" class="headerlink" title="优点："></a>优点：</h5><p>使用Python布尔值的条件语句更易读也更不易犯错。大部分情况下，也更快。</p>
<h5 id="缺点：-13"><a href="#缺点：-13" class="headerlink" title="缺点："></a>缺点：</h5><p>对C/C++开发人员来说。可能看起来有点怪。</p>
<h5 id="结论：-13"><a href="#结论：-13" class="headerlink" title="结论："></a>结论：</h5><p>尽可能使用隐式的false，例如:使用<font color=red><code>if foo:</code></font>而不是<font color=red><code>if foo != []:</code></font>。不过还是有一些注意事项需要你铭记在心:</p>
<ol>
<li><p>永远不要用==或者!=来比较单件，比如None。使用is或者is not。</p>
</li>
<li><p>当你写下<font color=red><code>if x:</code></font>时，你其实表示的是<font color=red><code>if x is not None</code></font>。例如:当你要测试一个默认值是None的变量或参数是否被设为其它值。这个值在布尔语义下可能是false!</p>
</li>
<li><p>永远不要用==将一个布尔量与false相比较。使用<font color=red><code>if not x:</code></font>代替。如果你需要区分false和None，你应该用像<font color=red><code>if not x and x is not None:</code></font>这样的语句。</p>
</li>
<li><p>对于序列(字符串、列表、元组)，要注意空序列是false。因此<font color=red><code>if not seq:</code></font>或者<font color=red><code>if seq:</code></font>比<font color=red><code>if len(seq):</code></font>或<font color=red><code>if not len(seq):</code></font> 要更好。</p>
</li>
<li><p>处理整数时，使用隐式false可能会得不偿失(即不小心将None当做0来处理)。你可以将一个已知是整型(且不是len()的返回结果)的值与0比较。</p>
</li>
<li><p>注意‘0’(字符串)会被当做true。</p>
</li>
</ol>
<h4 id="过时的语言特性"><a href="#过时的语言特性" class="headerlink" title="过时的语言特性"></a>过时的语言特性</h4><p>尽可能使用字符串方法取代字符串模块。使用函数调用语法取代apply()。使用列表推导，for循环取代filter()，map()以及reduce()。</p>
<h5 id="定义：-13"><a href="#定义：-13" class="headerlink" title="定义："></a>定义：</h5><p>当前版本的Python提供了大家通常更喜欢的替代品。</p>
<h5 id="结论：-14"><a href="#结论：-14" class="headerlink" title="结论："></a>结论：</h5><p>我们不使用不支持这些特性的Python版本，所以没理由不用新的方式。</p>
<h4 id="此法作用域（Lexical-Scoping）"><a href="#此法作用域（Lexical-Scoping）" class="headerlink" title="此法作用域（Lexical Scoping）"></a>此法作用域（Lexical Scoping）</h4><p>推荐使用。</p>
<h5 id="定义：-14"><a href="#定义：-14" class="headerlink" title="定义："></a>定义：</h5><p>嵌套的Python函数可以引用外层函数中定义的变量，但是不能够对它们赋值。变量绑定的解析是使用词法作用域，也就是基于静态的程序文本。对一个块中的某个名称的任何赋值都会导致Python将对该名称的全部引用当做局部变量，甚至是赋值前的处理。如果碰到global声明，该名称就会被视作全局变量。</p>
<h5 id="优点：-14"><a href="#优点：-14" class="headerlink" title="优点："></a>优点：</h5><p>通常可以带来更加清晰，优雅的代码。尤其会让有经验的Lisp和Scheme(还有Haskell、ML等)程序员感到欣慰。</p>
<h5 id="缺点：-14"><a href="#缺点：-14" class="headerlink" title="缺点："></a>缺点：</h5><p>可能导致让人迷惑的bug。</p>
<h5 id="结论：-15"><a href="#结论：-15" class="headerlink" title="结论："></a>结论：</h5><p>鼓励使用。</p>
<h4 id="函数与方法装饰器"><a href="#函数与方法装饰器" class="headerlink" title="函数与方法装饰器"></a>函数与方法装饰器</h4><p>如果好处很显然, 就明智而谨慎的使用装饰器</p>
<h5 id="定义：-15"><a href="#定义：-15" class="headerlink" title="定义："></a>定义：</h5><p>用于函数及方法的装饰器(也就是@标记)。最常见的装饰器是@classmethod 和@staticmethod，用于将常规函数转换成类方法或静态方法。不过，装饰器语法也允许用户自定义装饰器。特别地，对于某个函数<font color=red><code>my_decorator</code></font>,下面的两段代码是等效的:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"><span class="meta">   @my_decorator</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">method</span>(<span class="params">self</span>):</span></span><br><span class="line">       <span class="comment"># method body ...</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># method body ...</span></span><br><span class="line">    method = my_decorator(method)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="优点：-15"><a href="#优点：-15" class="headerlink" title="优点："></a>优点：</h5><p>优雅的在函数上指定一些转换。该转换可能减少一些重复代码，保持已有函数不变(enforce invariants)等.</p>
<h5 id="缺点：-15"><a href="#缺点：-15" class="headerlink" title="缺点："></a>缺点：</h5><p>装饰器可以在函数的参数或返回值上执行任何操作，这可能导致让人惊异的隐藏行为。而且，装饰器在导入时执行。从装饰器代码的失败中恢复更加不可能。</p>
<h5 id="结论：-16"><a href="#结论：-16" class="headerlink" title="结论："></a>结论：</h5><p>如果好处很显然，就明智而谨慎的使用装饰器。装饰器应该遵守和函数一样的导入和命名规则。装饰器的python文档应该清晰的说明该函数是一个装饰器。请为装饰器编写单元测试。</p>
<p>避免装饰器自身对外界的依赖(即不要依赖于文件、socket、数据库连接等)，因为装饰器运行时这些资源可能不可用(由<font color=red>pydoc</font>或其它工具导入)。应该保证一个用有效参数调用的装饰器在所有情况下都是成功的。</p>
<p>装饰器是一种特殊形式的”顶级代码”。</p>
<h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>不要依赖内建类型的原子性。</p>
<p>虽然Python的内建类型例如字典看上去拥有原子操作，但是在某些情形下它们仍然不是原子的(即: 如果__hash__或__eq__被实现为Python方法)且它们的原子性是靠不住的。你也不能指望原子变量赋值(因为这个反过来依赖字典)。</p>
<p>优先使用Queue模块的<font color=red><code>Queue</code></font>数据类型作为线程间的数据通信方式.。另外，使用threading模块及其锁原语(locking primitives)。了解条件变量的合适使用方式，这样你就可以使用&lt;/font color=red&gt;<code>threading.Condition</code></font>来取代低级别的锁了。</p>
<h4 id="威力过大的特性"><a href="#威力过大的特性" class="headerlink" title="威力过大的特性"></a>威力过大的特性</h4><p>避免使用这些特性。</p>
<h5 id="定义：-16"><a href="#定义：-16" class="headerlink" title="定义："></a>定义：</h5><p>Python是一种异常灵活的语言，它为你提供了很多花哨的特性，诸如元类(metaclasses)，字节码访问，任意编译(on-the-fly compilation)，动态继承，对象父类重定义(object reparenting)，导入黑客(import hacks)，反射、系统内修改(modification of system internals)等等。</p>
<h5 id="优点：-16"><a href="#优点：-16" class="headerlink" title="优点："></a>优点：</h5><p>强大的语言特性，能让你的代码更紧凑。</p>
<h5 id="缺点：-16"><a href="#缺点：-16" class="headerlink" title="缺点："></a>缺点：</h5><p>使用这些很”酷”的特性十分诱人，但不是绝对必要。使用奇技淫巧的代码将更加难以阅读和调试。开始可能还好(对原作者而言)，但当你回顾代码，它们可能会比那些稍长一点但是很直接的代码更加难以理解。</p>
<h5 id="结论：-17"><a href="#结论：-17" class="headerlink" title="结论："></a>结论：</h5><p>在你的代码中避免这些特性。</p>
<p>标准的模版库和类在内部使用这些功能都还可以使用(列如：<font color=red><code>abc.ABCMeta</code></font>、<font color=red><code>collections.namedtuple</code></font>和<font color=red><code>enum</code></font>)。</p>
<h4 id="现代Python：Python-3和from-future-import-modern-python"><a href="#现代Python：Python-3和from-future-import-modern-python" class="headerlink" title="现代Python：Python 3和from __future__import (#modern-python)"></a>现代Python：Python 3和from __future__import (#modern-python)</h4><p>Python3的时代。虽然不是每个项目都准备好但使用它，但是所有的代码应该面向未来的眼光来写。</p>
<h5 id="定义：-17"><a href="#定义：-17" class="headerlink" title="定义："></a>定义：</h5><p>Python 3 是一个很重要的改变在Python语言中，虽然现有的代码通常是以2.7的形式编写的，但为了使代码更明确地表达其意图，需要做一些简单的事情，从而更好地准备好在Python 3下使用而无需进行修改。</p>
<h5 id="优点：-17"><a href="#优点：-17" class="headerlink" title="优点："></a>优点：</h5><p>使用Python 3编写的代码在您的项目的所有依赖项都准备就绪后，会更加明确，并且更容易在Python 3下运行。</p>
<h5 id="缺点：-17"><a href="#缺点：-17" class="headerlink" title="缺点："></a>缺点：</h5><p>有些人觉得额外的样例很丑。 其他人说，“但我不在这个文件中使用该功能”，并希望清理。 请不要。 在所有文件中始终保留未来的导入效果会更好，以便在稍后进行编辑时，在有人开始使用此功能时不会忘记它们。</p>
<h5 id="结论：-18"><a href="#结论：-18" class="headerlink" title="结论："></a>结论：</h5><p><strong>from__future__import</strong></p>
<p>鼓励使用from <strong>future</strong> import语句。所有新代码应包含以下内容，并且应尽可能更新现有代码以使其兼容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import</span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br></pre></td></tr></table></figure>
<p>还有其他<code>from__future__</code>语句。 如果您认为合适，请使用它们。 我们不建议使用<code>unicode_literals</code>，因为它在Python 2.7中的许多地方引入了隐式默认编解码器转换后果，因此它不是一个明显的胜利。 大多数代码在显式使用<code>b&#39;&#39;</code>和<code>u&#39;&#39;</code>字节和必要的unicode字符串文字时效果更好。</p>
<p><strong>The six、future or past libraries.</strong></p>
<p>当项目需要在Python 2和Python 3下积极支持使用时，在合适的情况下，鼓励使用这些库。 它们的存在是为了让您的代码更简洁，更轻松。</p>
<h4 id="类型标注的代码"><a href="#类型标注的代码" class="headerlink" title="类型标注的代码"></a>类型标注的代码</h4><p>你可以通过<a href="https://www.python.org/dev/peps/pep-0484/">PEP-484</a>标准注释Python 3的类型提示，并且在构建时使用类型检查工具（比如<a href="https://github.com/google/pytype">pytype</a>）检查代码。</p>
<p>类型注释可以在源代码或<a href="https://www.python.org/dev/peps/pep-0484/#stub-files">stub pyi file</a>中。 只要有可能，注释应该在源代码中。 为第三方或扩展模块使用pyi文件。</p>
<h5 id="定义：-18"><a href="#定义：-18" class="headerlink" title="定义："></a>定义：</h5><p>类型注释（或者“类型提示”）用于函数或方法参数和返回值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">a: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br></pre></td></tr></table></figure>
<p>你还可以使用特殊注释声明变量的类型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = SomeFunc()  <span class="comment"># type: SomeType</span></span><br></pre></td></tr></table></figure>
<h5 id="优点：-18"><a href="#优点：-18" class="headerlink" title="优点："></a>优点：</h5><p>类型注释提高了代码的可读性和可维护性。类型检查器会将许多运行时错误转换为构建时错误，并降低你使用强大特性的能力。</p>
<h5 id="缺点：-18"><a href="#缺点：-18" class="headerlink" title="缺点："></a>缺点：</h5><p>你将不得不保持类型声明是最新的。你有可能会看到你认为是有效代码的类型错误的。用<a href="https://github.com/google/pytype">代码检查器</a>可以降低你使用强大特性的的能力。</p>
<h5 id="结论：-19"><a href="#结论：-19" class="headerlink" title="结论："></a>结论：</h5><p>这很大程度上取决于您项目的复杂程度。 试一试。</p>
<h3 id="Python风格规范"><a href="#Python风格规范" class="headerlink" title="Python风格规范"></a>Python风格规范</h3><h4 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h4><p>不要在行尾加分号，也不要用分号将两条命令放在同一行。</p>
<h4 id="行长度"><a href="#行长度" class="headerlink" title="行长度"></a>行长度</h4><p>每行长度不超过80字符。包括长的导入模块语句、注释里的URL等。<br>不要使用反斜杆连接行。Python会将<font color=blue size=4ß><code>圆括号、中括号和花括号中的行隐式连接起来</code></font>，可以利用这个特点，如果需要连接可以在表达式外围增加一对额外的圆括号。<br><strong>注：</strong>如果有必要，将长的URL可以放在一行。</p>
<h4 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h4><p>宁缺毋滥的使用括号。</p>
<p>除非是在使用实现行连接，否则不要在返回语句或条件语句中使用括号。不过在元组两边是可以的。</p>
<h4 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h4><p>用四个空格来缩进代码。</p>
<p>绝对不要用Tab，也不要用tab和空格混用。对于行连接的情况，要么垂直对其换行的元素，或者使用4空格的悬挂式缩进。</p>
<h4 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h4><p>顶级定义之间空两行，方法定义之间空一行。</p>
<p>顶级定义之间空两行,比如函数或者类定义。方法定义,类定义与第一个方法之间,都应该空一行. 函数或方法中,某些地方要是你觉得合适，就空一行。</p>
<h4 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h4><p>按照标准的排版规范来使用标点两边的空格。</p>
<ul>
<li>括号内不要使用空格。</li>
<li>不要在逗号、分号、冒号前面加空格，但应该在它们后面加（除了行尾）。</li>
<li>参数列表、索引或切片的做括号前不应该加空格。</li>
<li>在二元操作符两边都应该加上一个空格，至于算术操作符两边的空格该如何使用，需要你自己好好判断。不过两侧务必要保持一致。</li>
<li>当’=’用于指示关键字或参数默认值时，不要在其两侧使用空格。</li>
<li>不要用空格来处置对齐多行简的标记。</li>
</ul>
<h4 id="Shebang"><a href="#Shebang" class="headerlink" title="Shebang"></a>Shebang</h4><p>大部分.py文件不必以#!作为文件的开始。但是程序的main文件应该以 #!/usr/bin/python2或者#!/usr/bin/python3开始。</p>
<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>确保对模块、函数，方法和行内注释使用正确的风格。</p>
<h5 id="文档字符串"><a href="#文档字符串" class="headerlink" title="文档字符串"></a>文档字符串</h5><p>Python有一种独一无二的注释方式：使用文档字符串。文档字符串是包、模块，类或函数的一个语句。这些字符串可以通过对象的<code>__doc__</code>成员被自动提取，并用被pydoc所用。对文档字符串的惯例是使用三重双引号”””。<br>一个文档字符串应该这样组织：</p>
<ul>
<li>首先是一行以问号、句号和感叹号结尾的概述。</li>
<li>接着是一个空行。</li>
<li>接着是文档字符串剩下的部分，它应该与文档字符串的第一行的第一个引号对齐。</li>
</ul>
<h5 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h5><p>每个文件应该包含一个许可样板，根据项目使用许可(例如：Apache 2.0、BSD、LGPL、GPL)，选择合适的样板。</p>
<h5 id="函数和方法"><a href="#函数和方法" class="headerlink" title="函数和方法"></a>函数和方法</h5><p>下文所指的函数包括函数、方法以及生成器。</p>
<p>一个函数必须要有文档字符串，除非它满足以下条件：</p>
<ol>
<li>外部不可见</li>
<li>非常短小</li>
<li>简单明了<br>文档字符串应该包含函数做什么，以及输入和输出的详细描述。通常，不应该描述“怎么做”，除非是一些复杂的算法，文档字符串应该提供足够的信息，当别人编写代码调用该函数时，他不需要看一行代码，只要看文档字符串就可以了，对于复杂的代码，在代码旁边加注释会比使用文档字符串更有意义。</li>
</ol>
<p>关于函数的几个方面应该在特定的小节中进行描述记录，这几个方面如下文所述。每节应该以一个标题行开始。标题行以冒号结尾。除标题行外、节的其他内容应被缩进2个空格。</p>
<p><strong>Args：</strong><br>列出每个参数的名字，并在名字后使用一个冒号和一个空格，分隔对该参数的描述。如果描述太长超过了单行80字符，使用2或者4个空格的悬挂缩进(与文件其他部分保持一致)。描述应该包括所需的类型和含义。如果一个函数接受<em>foo(可变长度参数列表)或者**bar(任意关键字参数)，应该详细列出</em>foo和<strong>bar。<br>**Returns(或者Yield：用于生成器)：</strong><br>描述返回值的类型和语义。如果函数返回None，这一部分可以省略。<br><strong>Raises：</strong><br>列出与接口有关的所有异常。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch_bigtable_rows</span>(<span class="params">big_table，keys，other_silly_variable=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Fetches rows from a Bigtable.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Retrieves rows pertaining to the given keys from the Table instance</span></span><br><span class="line"><span class="string">    represented by big_table.  Silly things may happen if</span></span><br><span class="line"><span class="string">    other_silly_variable is not None.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        big_table: An open Bigtable Table instance.</span></span><br><span class="line"><span class="string">        keys: A sequence of strings representing the key of each table row</span></span><br><span class="line"><span class="string">            to fetch.</span></span><br><span class="line"><span class="string">        other_silly_variable: Another optional variable，that has a much</span></span><br><span class="line"><span class="string">            longer name than the other args，and which does nothing.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        A dict mapping keys to the corresponding table row data</span></span><br><span class="line"><span class="string">        fetched. Each row is represented as a tuple of strings. For</span></span><br><span class="line"><span class="string">        example:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &#123;&#x27;Serak&#x27;: (&#x27;Rigel VII&#x27;，&#x27;Preparer&#x27;),</span></span><br><span class="line"><span class="string">         &#x27;Zim&#x27;: (&#x27;Irk&#x27;，&#x27;Invader&#x27;),</span></span><br><span class="line"><span class="string">         &#x27;Lrrr&#x27;: (&#x27;Omicron Persei 8&#x27;，&#x27;Emperor&#x27;)&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        If a key from the keys argument is missing from the dictionary,</span></span><br><span class="line"><span class="string">        then that row was not found in the table.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Raises:</span></span><br><span class="line"><span class="string">        IOError: An error occurred accessing the bigtable.Table object.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h5 id="类"><a href="#类" class="headerlink" title="类"></a>类</h5><p>类应该在其定义下有一个用于描述该类的文档字符串。如果你的类有公共属性(Attributes)，那么文档中应该有一个属性(Attributes)段。并且应该遵守和函数参数相同的格式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SampleClass</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Summary of class here.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Longer class information....</span></span><br><span class="line"><span class="string">    Longer class information....</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Attributes:</span></span><br><span class="line"><span class="string">        likes_spam: A boolean indicating if we like SPAM or not.</span></span><br><span class="line"><span class="string">        eggs: An integer count of the eggs we have laid.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self，likes_spam=<span class="literal">False</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Inits SampleClass with blah.&quot;&quot;&quot;</span></span><br><span class="line">        self.likes_spam = likes_spam</span><br><span class="line">        self.eggs = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">public_method</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Performs operation blah.&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="块注释和行注释"><a href="#块注释和行注释" class="headerlink" title="块注释和行注释"></a>块注释和行注释</h5><p>最需要写注释的是代码中那些技巧性的部分。如果你在下次<font color=blue size=4><code>代码审查</code></font>的时候必须解释一下，那么你应该现在就给它写注释。对于复杂的操作，应该在其操作开始前写上若干行注释。对于不是一目了然的代码，应在其行尾添加注释。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># We use a weighted dictionary search to find out where i is in</span></span><br><span class="line"><span class="comment"># the array.  We extrapolate position based on the largest num</span></span><br><span class="line"><span class="comment"># in the array and the array size and then do binary search to</span></span><br><span class="line"><span class="comment"># get the exact number.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i &amp; (i-<span class="number">1</span>) == <span class="number">0</span>:        <span class="comment"># true iff i is a power of 2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>为了提高可读性，注释应该至少离开代码2个空格。</li>
<li>另一方面，绝不要描述代码。假设阅读代码的人比你更懂Python，他只是不知道你的代码要做什么。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># BAD COMMENT: Now go through the b array and make sure whenever i occurs</span></span><br><span class="line"><span class="comment"># the next element is i+1</span></span><br></pre></td></tr></table></figure>
<h4 id="类-1"><a href="#类-1" class="headerlink" title="类"></a>类</h4><p>如果一个类不继承自其它类，就显式的从object继承，嵌套类也一样。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SampleClass</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">         <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">             <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildClass</span>(<span class="params">ParentClass</span>):</span></span><br><span class="line">         <span class="string">&quot;&quot;&quot;Explicitly inherits from another class already.&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>继承自<font color=red size=4><code>object</code></font>是为了使属性(properties)正常工作并且这样可以保护你的代码，使其不受PEP-3000的一个特殊的潜在不兼容性影响。这样做也定义了一些特殊的方法，这些方法实现了对象的默认语义。包括<font color=red size=4><code>__new__，__init__， __delattr__，__getattribute__，__setattr__，__hash__，__repr__and __str__</code></font></p>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>即使参数都是字符串，使用%操作符或者格式化方法格式化字符串。不过也不能一概而论，你需要在+和%之间好好判定。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = a + b</span><br><span class="line">x = <span class="string">&#x27;%s，%s!&#x27;</span> % (imperative，expletive)</span><br><span class="line">x = <span class="string">&#x27;&#123;&#125;，&#123;&#125;!&#x27;</span>.<span class="built_in">format</span>(imperative，expletive)</span><br><span class="line">x = <span class="string">&#x27;name: %s; score: %d&#x27;</span> % (name，n)</span><br><span class="line">x = <span class="string">&#x27;name: &#123;&#125;; score: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(name，n)</span><br></pre></td></tr></table></figure>
<p>避免在循环中用+和+=操作符来累加字符串。由于字符串是不可变的，这样做会创建不必要的临时对象，并且导致二次方而不是线性的运行时间。作为替代方案，你可以将每个子串加入列表，然后在循环结束后用<font color=red size=4><code>.join</code></font>连接列表。(也可以将每个子串写入一个 <font color=red size=4><code>.cStringIO.StringIO</code></font>缓存中。)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">items = [<span class="string">&#x27;&lt;table&gt;&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> last_name，first_name <span class="keyword">in</span> employee_list:</span><br><span class="line">    items.append(<span class="string">&#x27;&lt;tr&gt;&lt;td&gt;%s，%s&lt;/td&gt;&lt;/tr&gt;&#x27;</span> % (last_name，first_name))</span><br><span class="line">    items.append(<span class="string">&#x27;&lt;/table&gt;&#x27;</span>)</span><br><span class="line">    employee_table = <span class="string">&#x27;&#x27;</span>.join(items)</span><br></pre></td></tr></table></figure>
<p>在同一个文件中，保持使用字符串引号的一致性。使用单引号’或者双引号”之一用以引用字符串，并在同一文件中沿用。在字符串内可以使用另外一种引号，以避免在字符串中使用。PyLint已经加入了这一检查。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Python(<span class="string">&#x27;Why are you hiding your eyes?&#x27;</span>)</span><br><span class="line">Gollum(<span class="string">&quot;I&#x27;m scared of lint errors.&quot;</span>)</span><br><span class="line">Narrator(<span class="string">&#x27;&quot;Good!&quot; thought a happy Python reviewer.&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>为多行字符串使用三重双引号”””而非三重单引号’’’。当且仅当项目中使用单引号’来引用字符串时,，才可能会使用三重’’’为非文档字符串的多行字符串来标识引用。文档字符串必须使用三重双引号”””。不过要注意，通常用隐式行连接更清晰，因为多行字符串与程序其他部分的缩进方式不一致。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> (<span class="string">&quot;This is much nicer.\n&quot;</span></span><br><span class="line">       <span class="string">&quot;Do it this way.\n&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="文件和sockets"><a href="#文件和sockets" class="headerlink" title="文件和sockets"></a>文件和sockets</h4><p>在文件和sockets结束时，显式的关闭它。</p>
<p>除文件外，sockets或其他类似文件的对象在没有必要的情况下打开，会有许多副作用，例如:</p>
<ol>
<li>它们可能会消耗有限的系统资源,如文件描述符。如果这些资源在使用后没有及时归还系统，那么用于处理这些对象的代码会将资源消耗殆尽。</li>
<li>持有文件将会阻止对于文件的其他诸如移动、删除之类的操作。</li>
<li>仅仅是从逻辑上关闭文件和sockets，那么它们仍然可能会被其共享的程序在无意中进行读或者写操作。只有当它们真正被关闭后，对于它们尝试进行读或者写操作将会抛出异常，并使得问题快速显现出来。</li>
</ol>
<p>而且，幻想当文件对象析构时，文件和sockets会自动关闭，试图将文件对象的生命周期和文件的状态绑定在一起的想法，都是不现实的。因为有如下原因:</p>
<ol>
<li>没有任何方法可以确保运行环境会真正的执行文件的析构。不同的Python实现采用不同的内存管理技术，如延时垃圾处理机制。延时垃圾处理机制可能会导致对象生命周期被任意无限制的延长。</li>
<li>对于文件意外的引用，会导致对于文件的持有时间超出预期(比如对于异常的跟踪，包含有全局变量等)。<br>推荐使用<font color=blue size=5><code>&quot;with&quot;语句</code></font>以管理文件:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;hello.txt&quot;</span>) <span class="keyword">as</span> hello_file:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> hello_file:</span><br><span class="line">        <span class="built_in">print</span> line</span><br></pre></td></tr></table></figure>
对于不支持使用”with”语句的类似文件的对象，使用<code>contextlib.closing()</code>:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> contextlib</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> contextlib.closing(urllib.urlopen(<span class="string">&quot;http://www.python.org/&quot;</span>)) <span class="keyword">as</span> front_page:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> front_page:</span><br><span class="line">        <span class="built_in">print</span> line</span><br></pre></td></tr></table></figure>
<h4 id="TODO注释"><a href="#TODO注释" class="headerlink" title="TODO注释"></a>TODO注释</h4>为临时代码使用TODO注释，它是一种短期解决方案。不算完美，但够好了。</li>
</ol>
<p>TODO注释应该在所有开头处包含”TODO”字符串，紧跟着是用括号括起来的你的名字，email地址或其它标识符。然后是一个可选的冒号，接着必须有一行注释，解释要做什么。主要目的是为了有一个统一的TODO格式。这样添加注释的人就可以搜索到(并可以按需提供更多细节)。写了TODO注释并不保证写的人会亲自解决问题。当你写了一个TODO，请注上你的名字。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># TODO(xujavy@gmail.com): Use a &quot;*&quot; here for string repetition.</span></span><br><span class="line"><span class="comment"># TODO(Javy) Change this to use relations.</span></span><br></pre></td></tr></table></figure>
<p>如果你的TODO是”将来做某事”的形式，那么请确保你包含了一个指定的日期(“2018年3月解决”)或者一个特定的事件(“等到所有的客户都可以处理XML请求就移除这些代码”)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#### 导入格式</span><br><span class="line">每个导入应该独占一行。</span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">import os</span><br><span class="line">import sys</span><br></pre></td></tr></table></figure>
<p>导入总应该放在文件顶部，位于模块注释和文档字符串之后，模块全局变量和常量之前。导入应该按照从最通用到最不通用的顺序分组:</p>
<ol>
<li>标准库导入</li>
<li>第三方库导入</li>
<li>应用程序指定导入<br>每种分组中，应该根据每个模块的完整包路径按字典序排序，忽略大小写。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> foo</span><br><span class="line"><span class="keyword">from</span> foo <span class="keyword">import</span> bar</span><br><span class="line"><span class="keyword">from</span> foo.bar <span class="keyword">import</span> baz</span><br><span class="line"><span class="keyword">from</span> foo.bar <span class="keyword">import</span> Quux</span><br><span class="line"><span class="keyword">from</span> Foob <span class="keyword">import</span> ar</span><br></pre></td></tr></table></figure>
<h4 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h4>通常每个语句应该独占一行。</li>
</ol>
<p>不过，如果测试结果与测试语句在一行放得下，你也可以将它们放在同一行。如果是if语句，只有在没有else时才能这样做。特别地，绝不要对<font color=red size=4>y/except</font>这样做，因为try和except不能放在同一行。</p>
<h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h4><p>在Python中，对于琐碎又不太重要的访问函数，你应该直接使用公有变量来取代它们，这样可以避免额外的函数调用开销。当添加更多功能时，你可以用属性(property)来保持语法的一致性。</p>
<p>另一方面，如果访问更复杂，或者变量的访问开销很显著，那么你应该使用像<font color=red size=4><code>get_foo()</code></font>和<font color=red size=4><code>set_foo()</code></font>这样的函数调用。如果之前的代码行为允许通过属性(property)访问，那么就不要将新的访问函数与属性绑定。这样，任何试图通过老方法访问变量的代码就没法运行，使用者也就会意识到复杂性发生了变化。</p>
<h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><p>module_name，package_name，ClassName，method_name，ExceptionName，function_name，GLOBAL_VAR_NAME，instance_var_name，function_parameter_name，local_var_name。</p>
<h5 id="应该避免的名字"><a href="#应该避免的名字" class="headerlink" title="应该避免的名字"></a>应该避免的名字</h5><ol>
<li>单字符名称, 除了计数器和迭代器。</li>
<li>包/模块名中的连字符(-)。</li>
<li>双下划线开头并结尾的名称(Python保留，例如<strong>init</strong>)。<h5 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h5></li>
<li>所谓”内部(Internal)”表示仅模块内可用，或者在类内是保护或私有的。</li>
<li>用单下划线(_)开头表示模块变量或函数是protected的(使用import * from时不会包含)。</li>
<li>用双下划线(__)开头的实例变量或方法表示类内私有。</li>
<li>将相关的类和顶级函数放在同一个模块里。不像Java，没必要限制一个类一个模块。</li>
<li>对类名使用大写字母开头的单词(如CapWords, 即Pascal风格)，但是模块名应该用小写加下划线的方式(如lower_with_under.py)。尽管已经有很多现存的模块使用类似于CapWords.py这样的命名，但现在已经不鼓励这样做，因为如果模块名碰巧和类名一致，这会让人困扰。</li>
</ol>
<h5 id="Python之父Guido推荐的规范"><a href="#Python之父Guido推荐的规范" class="headerlink" title="Python之父Guido推荐的规范"></a>Python之父Guido推荐的规范</h5><table>
<thead>
<tr>
<th align="left">Type</th>
<th align="left">Public</th>
<th align="left">Internal</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Modules</td>
<td align="left">lower_with_under</td>
<td align="left">_lower_with_under</td>
</tr>
<tr>
<td align="left">Packages</td>
<td align="left">lower_with_under</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Classes</td>
<td align="left">CapWords</td>
<td align="left">_CapWords</td>
</tr>
<tr>
<td align="left">Exceptions</td>
<td align="left">CapWords</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Functions</td>
<td align="left">lower_with_under()</td>
<td align="left">_lower_with_under()</td>
</tr>
<tr>
<td align="left">Global/Class Constants</td>
<td align="left">CAPS_WITH_UNDER</td>
<td align="left">_CAPS_WITH_UNDER</td>
</tr>
<tr>
<td align="left">Global/Class Variables</td>
<td align="left">lower_with_under</td>
<td align="left">_lower_with_under</td>
</tr>
<tr>
<td align="left">Instance Variables</td>
<td align="left">lower_with_under</td>
<td align="left">_lower_with_under (protected) or __lower_with_under (private)</td>
</tr>
<tr>
<td align="left">Method Names</td>
<td align="left">lower_with_under()</td>
<td align="left">_lower_with_under() (protected) or __lower_with_under() (private)</td>
</tr>
<tr>
<td align="left">Function/Method</td>
<td align="left">Parameters</td>
<td align="left">lower_with_under</td>
</tr>
<tr>
<td align="left">Local Variables</td>
<td align="left">lower_with_under</td>
<td align="left"></td>
</tr>
</tbody></table>
<h4 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h4><p>即使是一个打算被用作脚本的文件，也应该是可导入的。并且简单的导入不应该导致这个脚本的主功能(main functionality)被执行，这是一种副作用。主功能应该放在一个main()函数中。</p>
<p>在Python中，pydoc以及单元测试要求模块必须是可导入的。你的代码应该在执行主程序前总是检查<font color=red size=4><code>if __name__ == &#39;__main__&#39;</code></font>，这样当模块被导入时主程序就不会被执行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>所有的顶级代码在模块导入时都会被执行。要小心不要去调用函数，创建对象，或者执行那些不应该在使用pydoc时执行的操作。</p>
<h4 id="函数长度"><a href="#函数长度" class="headerlink" title="函数长度"></a>函数长度</h4><p>喜欢小而专注的函数。</p>
<p>我们知道长函数有时是合适的，所以对函数长度没有硬性限制。 如果功能超过40行，请考虑是否可以在不影响程序结构的情况下将其分解。</p>
<p>即使长函数依然可以正常工作，但有人在几个月内修改它可能会增加新的行为。这可能会导致很难找到的错误。保持你函数的简短，使其他人更容易阅读和修改你的代码。</p>
<p>使用某些代码时，可能会发现长而复杂的函数。不要被修改现有代码而吓倒：如果使用这样的函数证明是困难的，你会发现错误是很难调试发现的，或者你想在几个不同的上下文中使用它的一部分，考虑把函数分解成更小的、更易于管理的函数。</p>
<h4 id="类型注释"><a href="#类型注释" class="headerlink" title="类型注释"></a>类型注释</h4><h5 id="普通规则"><a href="#普通规则" class="headerlink" title="普通规则"></a>普通规则</h5><ul>
<li>熟悉<a href="">PEP-484</a>.</li>
<li>在方法中，永远不要注释self或cls。</li>
<li>如果不应表达任何其他变量或返回类型，请使用Any。</li>
<li>你不需要注释模块中的所有功能。<ul>
<li>至少注释你的公共API。</li>
<li>使用判断力一方面可以在安全性和清晰度之间取得良好的平衡，另一方面可以灵活应对。</li>
<li>注释容易出现类型相关错误的代码（以前的错误或复杂性）。</li>
<li>注释难以理解的代码。</li>
<li>注释代码从类型角度来看变得稳定。在很多情况下，你可以在成熟代码中注释所有功能，而不会失去太多的灵活性。</li>
</ul>
</li>
</ul>
<h5 id="断行"><a href="#断行" class="headerlink" title="断行"></a>断行</h5><p>尝试遵循现有的缩进规则。 总是喜欢在各种变量之间断开。</p>
<p>注释后，许多功能将成为“每行一个参数”。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_method</span>(<span class="params">self,</span></span></span><br><span class="line"><span class="function"><span class="params">              first_var: <span class="built_in">int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">              second_var: Foo,</span></span></span><br><span class="line"><span class="function"><span class="params">              third_var: Optional[Bar]</span>) -&gt; int:</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>但是，如果所有东西都放在一行，那也是合适的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_method</span>(<span class="params">self, first_var: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>如果函数名称，最后一个参数和返回类型的组合太长，则在新行中缩进4。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def my_method(</span><br><span class="line">    self, first_var: int) -&gt; Tuple[MyLongType1, MyLongType1]:</span><br></pre></td></tr></table></figure>
<p>当返回类型与最后一个参数不在同一行时，首选方法是将参数缩进4行，并将右括号与def对齐。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_method</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    self, **kw_args: Optional[MyLongType]</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) -&gt; Dict[OtherLongType, MyLongType]:</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p><code>pylint</code>允许你将右括号移动到一个新的行并与开头的对齐，但这是可读较差,如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_method</span>(<span class="params">self,</span></span></span><br><span class="line"><span class="function"><span class="params">              **kw_args: Optional[MyLongType]</span></span></span><br><span class="line"><span class="function"><span class="params">             </span>) -&gt; Dict[OtherLongType, MyLongType]:</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>正如在上面的例子中，不要打破类型。但是，有时它们太长而无法在一行上（尽量保持子类型不间断）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_method</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    self,</span></span></span><br><span class="line"><span class="function"><span class="params">    first_var: Tuple[List[MyLongType1],</span></span></span><br><span class="line"><span class="function"><span class="params">                     List[MyLongType2]],</span></span></span><br><span class="line"><span class="function"><span class="params">    second_var: List[Dict[</span></span></span><br><span class="line"><span class="function"><span class="params">        MyLongType3, MyLongType4]]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>如果单个名称和类型太长，请考虑为该类型使用别名。最后的手段是断开冒号和缩进四行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    long_variable_name:</span></span></span><br><span class="line"><span class="function"><span class="params">        long_module_name.LongTypeName,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) -&gt; <span class="keyword">None</span>:</span></span><br></pre></td></tr></table></figure>
<h5 id="前置声明"><a href="#前置声明" class="headerlink" title="前置声明"></a>前置声明</h5><p>如果需要使用尚未定义的相同模块中的类名-例如，如果需要类声明中的类，或者使用了下面定义的类 - 请为该类使用字符串名称。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,</span></span></span><br><span class="line"><span class="function"><span class="params">               stack: List[<span class="string">&quot;MyClass&quot;</span>]</span>) -&gt; <span class="keyword">None</span>:</span></span><br></pre></td></tr></table></figure>
<h5 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h5><p>根据<a href="https://www.python.org/dev/peps/pep-0008/#other-recommendations">PEP-008</a>将参数注释与默认值相结合，在=号周围使用空格（但仅限于那些同时具有注释和默认值的参数）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">a: <span class="built_in">int</span> = <span class="number">0</span></span>) -&gt; int:</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<h5 id="NoneType"><a href="#NoneType" class="headerlink" title="NoneType"></a>NoneType</h5><p>在Python类型系统中，<code>NoneType</code>是“第一类”类型，出于输入的目的，<code>None</code>是<code>NoneType</code>的别名。如果参数可以是None，则必须声明!你可以使用U<code>nion</code>，但如果只有一个其他类型，则<code>Optional</code>是一个快捷方式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">a: Optional[<span class="built_in">str</span>]</span>) -&gt; str:</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>如果参数的默认值为<code>None</code>，则标记变量O<code>ptional</code>是可选的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">a: Optional[<span class="built_in">str</span>] = <span class="literal">None</span></span>) -&gt; str:</span></span><br><span class="line">  ...</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">a: <span class="built_in">str</span> = <span class="literal">None</span></span>) -&gt; str:</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<h5 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h5><p>你可以为复杂类型声明别名。别名的名称应该是<code>CapWorded</code>; 尝试描述组合类型并以“Type”（或返回元组的“类型”）结束。如果该别名仅在本模块中使用，则应该是_Private。</p>
<p>例如，如果模块名称与类型一起太长：<br><code>SomeType = module_with_long_name.TypeWithLongName</code></p>
<p>其他例子是复杂的嵌套类型和函数的多个返回变量（作为元组）。</p>
<h5 id="忽略类型"><a href="#忽略类型" class="headerlink" title="忽略类型"></a>忽略类型</h5><p>你可以使用特殊注释<code>＃type：ignore</code>禁用类型检查。</p>
<p><code>pytype</code>对特定的错误有一个禁用选项（类似于lint）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pytype: disable=attribute-error</span></span><br></pre></td></tr></table></figure>
<h5 id="键入内部变量"><a href="#键入内部变量" class="headerlink" title="键入内部变量"></a>键入内部变量</h5><p>如果内部变量的类型很难或不可能推断，那么可以将其作为特殊评论提供：<br><code>a = SomeUndecoratedFunction()  # type: Foo</code></p>
<h5 id="元组和列表"><a href="#元组和列表" class="headerlink" title="元组和列表"></a>元组和列表</h5><p>与仅有单一类型的列表不同，元组可以具有单个重复类型或具有不同类型的一定数量的元素。后者通常用作函数的返回类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]  <span class="comment"># type: List[int]</span></span><br><span class="line">b = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  <span class="comment"># type: Tuple[int, ...]</span></span><br><span class="line">c = (<span class="number">1</span>, <span class="string">&quot;2&quot;</span>, <span class="number">3.5</span>)  <span class="comment"># type Tuple[int, str, float]</span></span><br></pre></td></tr></table></figure>
<h5 id="TypeVar"><a href="#TypeVar" class="headerlink" title="TypeVar"></a>TypeVar</h5><p>Python类型系统具有<a href="https://www.python.org/dev/peps/pep-0484/#generics">generics</a>。 工厂函数TypeVar是使用它们的常用方法。<br>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List, TypeVar</span><br><span class="line">T = TypeVar(<span class="string">&quot;T&quot;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">next</span>(<span class="params">l: List[T]</span>) -&gt; T:</span></span><br><span class="line">  <span class="keyword">return</span> l.pop()</span><br></pre></td></tr></table></figure>
<p>TypeVar可以被约束：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">AddableType = TypeVar(<span class="string">&quot;AddableType&quot;</span>, <span class="built_in">int</span>, <span class="built_in">float</span>, <span class="built_in">str</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a: AddableType, b: AddableType</span>) -&gt; AddableType:</span></span><br><span class="line">  <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure>
<p><code>类型</code>变量中一个常见的预定义类型变量是<code>AnyStr</code>。 将它用于可以是<code>bytes</code>或<code>unicode</code>的参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">AnyStr = TypeVar(<span class="string">&quot;AnyStr&quot;</span>, <span class="built_in">bytes</span>, unicode)</span><br></pre></td></tr></table></figure>
<h5 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h5><p>当注释接收或返回字符串的函数时，避免使用<code>str</code>，因为它在Python 2和Python 3中意味着不同的东西。在Python 2中，<code>str</code>是<code>bytes</code>; 在Python 3中，它是<code>unicode</code>。 只要有可能，最好是明确的.</p>
<p>对于处理字节数组的代码，请使用<code>bytes</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x: <span class="built_in">bytes</span></span>) -&gt; bytes:</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>对于处理Unicode数据的代码，请使用<code>Text</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Text</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x: Text</span>) -&gt; Text:</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>如果类型可以是字节或unicode，则使用<code>Union</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Text, Union</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x: Union[<span class="built_in">bytes</span>, Text]</span>) -&gt; Union[bytes, Text]:</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>如果函数的所有字符串类型始终相同，例如，如果返回类型与上面代码中的参数类型相同，请使用<a href="https://github.com/google/styleguide/blob/gh-pages/pyguide.md#typing-type-var">AnyStr</a>。</p>
<p>以这种方式编写代码将简化将代码移植到Python 3的过程。</p>
<h5 id="类型导入"><a href="#类型导入" class="headerlink" title="类型导入"></a>类型导入</h5><p>对于来自<code>typing</code>模块的类，始终导入类本身。明确允许从<code>typing</code>模块的一行中导入多个特定的类。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Any, Dict, Optional</span><br></pre></td></tr></table></figure>
<p>鉴于这种<code>typing</code>的方式会将项添加到本地名称空间，所以导入中的任何名称都应该与关键字类似，并且不能在您的Python代码中定义，无论是否导入。如果模块中的类型和现有名称之间存在冲突，请使用<code>import x as y</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Any <span class="keyword">as</span> AnyType</span><br></pre></td></tr></table></figure>
<p>如果需要在运行时避免类型检查所需的附加导入，则可以使用条件导入。不鼓励这种模式，并且应该优先选择重构代码以允许顶级导入的替代方案。如果完全使用这种模式，那么有条件地导入的类型需要被引用为字符串’<code>sketch.Sketch&#39;</code>而不是<code>sketch.Sketch</code>，以与Python 3向前兼容，其中注释表达式被实际评估。 只有type注释才需要的导入可以放在一个<code>if typing.TYPE_CHECKING：</code>块中。</p>
<ul>
<li>应该在这里定义仅用于设置的实体;这包括别名。否则，它将成为运行时错误，因为模块不会在运行时导入。</li>
<li>块应该在所有正常导入。</li>
<li>类型导入列表中不应该有空行。</li>
<li>将列表排序，就好像它是一个常规导入列表一样，但是将末尾的输入模块导入。</li>
<li><code>google3</code>模块也有一个<code>TYPE_CHECKING</code>常量。 如果你不想在运行时<code>typing</code>输入，你可以使用它。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> typing</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> typing.TYPE_CHECKING:</span><br><span class="line">  <span class="keyword">import</span> types</span><br><span class="line">  <span class="keyword">from</span> MySQLdb <span class="keyword">import</span> connections</span><br><span class="line">  <span class="keyword">from</span> google3.path.to.my.project <span class="keyword">import</span> my_proto_pb2</span><br><span class="line">  <span class="keyword">from</span> typing <span class="keyword">import</span> Any, Dict, Optional</span><br></pre></td></tr></table></figure>
<h5 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h5>由键入代码的循环依赖。这样的代码是重构的好选择。 尽管技术上可以保持循环依赖，但<a href="https://github.com/google/styleguide/blob/gh-pages/pyguide.md#typing-build-deps">构建系统</a>不会让你这么做，因为每个模块都必须依赖于其他模块。</li>
</ul>
<p>使用Any替换创建循环依赖项导入的模块。设置有意义的名称用别名，并使用此模块中的实际类型名称（任何属性均为Any）。 别名定义应该与上一次导入分开一行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Any</span><br><span class="line"></span><br><span class="line">some_mod = Any  <span class="comment"># some_mod.py imports this module.</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_method</span>(<span class="params">self, var: some_mod.SomeType</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>请务必保持代码的一致性</p>
<p>如果你正在编辑代码, 花几分钟看一下周边代码, 然后决定风格. 如果它们在所有的算术操作符两边都使用空格, 那么你也应该这样做。如果它们的注释都用标记包围起来, 那么你的注释也要这样。</p>
<p>制定风格指南的目的在于让代码有规可循, 这样人们就可以专注于”你在说什么”, 而不是”你在怎么说”. 我们在这里给出的是全局的规范, 但是本地的规范同样重要. 如果你加到一个文件里的代码和原有代码大相径庭, 它会让读者不知所措。 避免这种情况。</p>
<p><strong>注：</strong></p>
<p>原文来自于<a href="https://github.com/google/styleguide/blob/gh-pages/pyguide.md">Google PyGuid</a></p>
<p>参考译文来自于<a href="http://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/">Google Python Style Guide</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>基本数据结构</title>
    <url>/data_structure/base_data_structure/</url>
    <content><![CDATA[<!-- TOC -->

<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">基本数据结构</a><ul>
<li><a href="#%E7%9B%AE%E6%A0%87">目标</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">什么是线性数据结构</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%A0%88">什么是栈</a></li>
<li><a href="#%E6%A0%88%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">栈的抽象数据类型</a></li>
<li><a href="#python%E5%AE%9E%E7%8E%B0%E6%A0%88">Python实现栈</a></li>
<li><a href="#%E4%B8%AD%E7%BC%80%E5%89%8D%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F">中缀，前缀和后缀表达式</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h2 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul>
<li>理解抽象数据类型的栈，队列，deque 和列表。</li>
<li>能够使用 Python 列表实现 ADT 堆栈，队列和 deque。</li>
<li>了解基本线性数据结构实现的性能。</li>
<li>了解前缀，中缀和后缀表达式格式。</li>
<li>使用栈来实现后缀表达式。</li>
<li>使用栈将表达式从中缀转换为后缀。</li>
<li>使用队列进行基本时序仿真。</li>
<li>能够识别问题中栈，队列和 deques 数据结构的适当使用。</li>
<li>能够使用节点和引用将抽象数据类型列表实现为链表。</li>
<li>能够比较我们的链表实现与 Python 的列表实现的性能。<a id="more"></a>
<h3 id="什么是线性数据结构"><a href="#什么是线性数据结构" class="headerlink" title="什么是线性数据结构"></a>什么是线性数据结构</h3>我们从四个简单但重要的概念开始研究数据结构。栈，队列，deques, 列表是一类数据的容器，它们数据项之间的顺序由添加或删除的顺序决定。一旦一个数据项被添加，它相对于前后元素一直保持该位置不变。诸如此类的数据结构被称为线性数据结构。</li>
</ul>
<p>线性数据结构有两端，有时被称为左右，某些情况被称为前后。你也可以称为顶部和底部，名字都不重要。将两个线性数据结构区分开的方法是添加和移除项的方式，特别是添加和移除项的位置。例如一些结构允许从一端添加项，另一些允许从另一端移除项。</p>
<p>这些变种的形式产生了计算机科学最有用的数据结构。他们出现在各种算法中，并可以用于解决很多重要的问题。</p>
<h3 id="什么是栈"><a href="#什么是栈" class="headerlink" title="什么是栈"></a>什么是栈</h3><p><strong>栈</strong>（有时称为“后进先出栈”）是一个项的有序集合，其中添加移除新项总发生在同一端。这一端通常称为“顶部”。与顶部对应的端称为“底部”。</p>
<p>栈的底部很重要，因为在栈中靠近底部的项是存储时间最长的。最近添加的项是最先会被移除的。这种排序原则有时被称为<strong>LIFO</strong>，后进先出。它基于在集合内的时间长度做排序。较新的项靠近顶部，较旧的项靠近底部。</p>
<p>栈的例子很常见。几乎所有的自助餐厅都有一堆托盘或盘子，你从顶部拿一个，就会有一个新的托盘给下一个客人。想象桌上有一堆书(Figure 1), 只有顶部的那本书封面可见，要看到其他书的封面，只有先移除他们上面的书。Figure 2展示了另一个栈，包含了很多按Python对象。<br><img src="base_data_structure/figure_1.png" alt="figure1">Figure 1<br><img src="base_data_structure/figure_2.png" alt="figure2">Figure 2</p>
<p>和栈相关的最有用的想法之一来自对它的观察。假设从一个干净的桌面开始，现在把书一本本叠起来，你在构造一个栈。考虑下移除一本书会发生什么。移除的顺序跟刚刚被放置的顺序相反。栈之所以重要是因为它能反转项的顺序。插入跟删除顺序相反，Figure 3展示了Python数据对象创建和删除的过程，注意观察他们的顺序。<br><img src="base_data_structure/figure_3.png" alt="figure3">Figure 3</p>
<p>想想这种反转的属性，你可以想到使用计算机的时候所碰到的例子。例如，每个 web 浏览器都有一个返回按钮。当你浏览网页时，这些网页被放置在一个栈中（实际是网页的网址）。你现在查看的网页在顶部，你第一个查看的网页在底部。如果按‘返回’按钮，将按相反的顺序浏览刚才的页面。</p>
<h3 id="栈的抽象数据类型"><a href="#栈的抽象数据类型" class="headerlink" title="栈的抽象数据类型"></a>栈的抽象数据类型</h3><p>栈的抽象数据类型由以下结构和操作定义。如上所述，栈被构造为项的有序集合，其中项被添加和从末端移除的位置称为“顶部”。<strong>栈是有序的LIFO</strong>。栈操作如下。</p>
<ul>
<li>Stack() 创建一个空的新栈。 它不需要参数，并返回一个空栈。</li>
<li> push(item)将一个新项添加到栈的顶部。它需要 item 做参数并不返回任何内容。</li>
<li> pop() 从栈中删除顶部项。它不需要参数并返回 item 。栈被修改。</li>
<li> peek() 从栈返回顶部项，但不会删除它。不需要参数。 不修改栈。</li>
<li> isEmpty() 测试栈是否为空。不需要参数，并返回布尔值。</li>
<li> size() 返回栈中的 item 数量。不需要参数，并返回一个整数。</li>
</ul>
<p>例如，s是已经创建的空栈，Table1展示了栈操作序列的结果。栈中，顶部项列在最右边。<br><img src="base_data_structure/table1.png" alt="table1">Table 1</p>
<h3 id="Python实现栈"><a href="#Python实现栈" class="headerlink" title="Python实现栈"></a>Python实现栈</h3><p>现在我们已经将栈清楚地定义了抽象数据类型，我们将把注意力转向使用Python实现栈。回想一下，当我们给抽象数据类型一个物理实现时，我们将实现称为数据结构。<br>正如我们在第1章中所描述的，在Python中，与任何面向对象编程语言一样，抽象数据类型（如栈）的选择的实现是创建一个新类。栈操作实现为类的方法。此外，为了实现作为元素集合的栈，使用由Python提供的原语集合的能力是有意义的。我们将使用列表作为底层实现。<br>回想一下，Python中的列表类提供了有序集合机制和一组方法。例如，如果我们有列表<code>[2,5,3,6,7,4]</code>，我们只需要确定列表的哪一端将被认为是栈的顶部。一旦确定，可以使用诸如<strong>append</strong>和<strong>pop</strong>的列表方法来实现操作。<br>以下栈实现（ActiveCode 1）假定列表的结尾将保存栈的顶部元素。随着栈增长（<strong>push</strong>操作），新项将被添加到列表的末尾。<strong>pop</strong>也操作列表末尾的元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>:</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">         self.items = []</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span>(<span class="params">self</span>):</span></span><br><span class="line">         <span class="keyword">return</span> self.items == []</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, item</span>):</span></span><br><span class="line">         self.items.append(item)</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">         <span class="keyword">return</span> self.items.pop()</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">peek</span>(<span class="params">self</span>):</span></span><br><span class="line">         <span class="keyword">return</span> self.items[<span class="built_in">len</span>(self.items)-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">size</span>(<span class="params">self</span>):</span></span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">len</span>(self.items)</span><br></pre></td></tr></table></figure>
<p>ActiveCode 1<br>记住我们只定义类的实现，我们需要创建一个栈，然后使用它。ActiveCode 2展示了我们通过实例化<code>Stack</code>类执行Table 1中的操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s=Stack()</span><br><span class="line"></span><br><span class="line">print(s.isEmpty())</span><br><span class="line">s.push(<span class="number">4</span>)</span><br><span class="line">s.push(<span class="string">&#x27;dog&#x27;</span>)</span><br><span class="line">print(s.peek())</span><br><span class="line">s.push(<span class="literal">True</span>)</span><br><span class="line">print(s.size())</span><br><span class="line">print(s.isEmpty())</span><br><span class="line">s.push(<span class="number">8.4</span>)</span><br><span class="line">print(s.pop())</span><br><span class="line">print(s.pop())</span><br><span class="line">print(s.size())</span><br></pre></td></tr></table></figure>
<p>ActiveCode 2</p>
<h3 id="中缀，前缀和后缀表达式"><a href="#中缀，前缀和后缀表达式" class="headerlink" title="中缀，前缀和后缀表达式"></a>中缀，前缀和后缀表达式</h3><p>当你编写一个算术表达式如<code>B*C</code>时，表达式的形式使你能够正确理解它。在这种情况下，你知道<strong>B</strong>乘以<strong>C</strong>, 因为乘法运算符<code>*</code>出现在表达式中。这种类型的符号称为中缀，因为运算符在它处理的两个操作数之间。看另外一个中缀示例，<code>A+B*C</code>，运算符<code>+</code>和<code>*</code>仍然出现在操作数之间。这里面有个问题是，他们分别作用于哪个运算数上，<code>+</code>作用于<code>A</code>和<code>B</code>, 还是<code>*</code>作用于B和C？表达式似乎有点模糊。</p>
<p>事实上，你已经读写过这些类型的表达式很长一段时间，所以它们对你不会导致什么问题。这是因为你知道运算符<code>+</code>和<code>*</code>。每个运算符都有一个优先级。优先级较高的运算符在优先级较低的运算符之前使用。唯一改变顺序的是括号的存在。算术运算符的优先顺序是将乘法和除法置于加法和减法之上。如果出现具有相等优先级的两个运算符，则使用从左到右的顺序排序或关联。</p>
<p>我们使用运算符优先级来解释下表达式<code>A+B*C</code>。<strong>B</strong>和<strong>C</strong>首先相乘，然后将A与该结果相加。<code>(A+B)*C</code>将强制在乘法之前执行A和B的加法。在表达式<code>A+B+C</code>中，最左边的<code>+</code>首先使用。</p>
<p>虽然这一切对你来说都很明显。但请记住，计算机需要准确知道要执行的操作符和顺序。一种保证不会对操作顺序产生混淆的表达式的方法是创建一个称为完全括号表达式的表达式。这种类型的表达式对每个运算符都使用一对括号。括号没有歧义的指示操作的顺序。也没有必要记住任何优先规则。<br>表达式<code>A+B*C+D</code>可以重写为 <code>((A + (B * C)) + D)</code> ，表明先乘法，然后是左边的加法，<code>A + B + C + D</code>可以写为<code>(((A + B) + C) + D)</code>，因为加法操作从左向右相关联。</p>
<p>有两种非常重要的表达式格式，你可能一开始不会很明显的看出来。中缀表达式<code>A+B</code>, 如果我们移动两个操作数之间的运算符会发生什么？结果表达式变成<code>+ A B</code>。同样，我们也可以将运算符移动到结尾，得到<code>A B +</code>，这样看起来有点奇怪。</p>
<p>改变操作符的位置得到了两种新的表达式格式，前缀和后缀。前缀表达式符号要求所有运算符在它们处理的两个操作数之前。另一个方面，后缀要求其操作符在相应的操作数之后。看下更多的例子 (见 Table 2)<br>A+B*C 将在前缀中写为 + A * B C 。乘法运算符紧接在操作数 B 和 C 之前，表示 * 优先于 +。然后加法运算符出现在 A 和乘法的结果之前。<br>在后缀中，表达式将是 A B C * +，再次，操作的顺序被保留，因为 * 紧接在 B 和 C 之后出现，表示 * 具有高优先级，+ 优先级低。虽然操作符在它们各自的操作数前后移动，但是顺序相对于彼此保持完全相同。<br>3.9.中缀后缀和后缀表达式.table2</p>
<p>Table 2<br>现在考虑中缀表达式 (A + B) * C，回想下，在这种情况下，中缀需要括号在乘法之前强制执行加法。然而，当 A+B 写到前缀中时，加法运算符简单的移动到操作数 + A B 之前。这个操作的结果成为乘法的第一个操作数。乘法运算符移动到整个表达式的前面，得出 * + A B C，同样，在后缀 A B +中，强制先加法。可以直接对该结果和剩余的操作数 C 相乘。然后，得出后缀表达式为 A B + C *。<br>再次考虑这三个表达式(见 Table 3)，括号不见了。为什么在前缀和后缀的时候不需要括号了呢？答案是操作符对于他们的操作数不再模糊，只有中缀才需要括号，前缀和后缀表达式的操作顺序完全由操作符的顺序决定。<br>3.9.中缀后缀和后缀表达式.table3</p>
<p>Table 3<br>Table 4 展示了一些其他的例子<br>3.9.中缀后缀和后缀表达式.table4</p>
<p>Table 4<br>3.9.1.中缀表达式转换前缀和后缀<br>到目前为止，我们已经使用特定方法在中缀表达式和等效前缀和后缀表达式符号之间进行转换。正如你可能期望的，有一些算法来执行转换，允许任何复杂表达式转换。<br>我们考虑的第一种技术使用前面讨论的完全括号表达式的概念。回想一下，A + B * C可以写成（A +（B * C）），以明确标识乘法优先于加法。然而，仔细观察,你可以看到每个括号对还表示操作数对的开始和结束，中间有相应的运算符。<br>看上面的子表达式（B * C）中的右括号。 如果我们将乘法符号移动到那个位置，并删除匹配的左括号，得到 B C *，我们实际上已经将子表达式转换为后缀符号。 如果加法运算符也被移动到其相应的右括号位置并且匹配的左括号被去除，则将得到完整的后缀表达式（见 Figure 6）。<br>3.9.中缀后缀和后缀表达式.figure6</p>
<p>Figure 6<br>如果我们不是将符号移动到右括号的位置，我们将它向左移动，我们得到前缀符号（见 Figure 7）。圆括号对的位置实际上是包含的运算符的最终位置的线索。 3.9.中缀后缀和后缀表达式.figure7<br>Figure 7<br>所以为了转换表达式，无论是对前缀还是后缀符号，先根据操作的顺序把表达式转换成完全括号表达式。然后将包含的运算符移动到左或右括号的位置，具体取决于需要前缀或后缀符号。<br>这里面有个更复杂的例子, (A + B) * C - (D - E) * (F + G) ，Figure 8 显示了如何转换为后缀和前缀。<br>3.9.中缀后缀和后缀表达式.figure8</p>
<p>Figure 8<br>3.9.2.中缀转后缀通用法<br>我们需要开发一个算法来将任何中缀表达式转换为后缀表达式。 为了做到这一点，我们仔细看看转换过程。<br>再次考虑表达式 A + B * C。如上所示，A B C * +是等价的后缀表达式。 我们已经注意到，操作数 A，B 和 C 保持在它们的相对位置。只有操作符改变位置。再看中缀表达式中的运算符。从左到右出现的第一个运算符为 +。 然而，在后缀表达式中，+ 在结束位置，因为下一个运算符 * 的优先级高于加法。 原始表达式中的运算符的顺序在生成的后缀表达式中相反。<br>当我们处理表达式时，操作符必须保存在某处，因为它们相应的右操作数还没有看到。 此外，这些保存的操作符的顺序可能由于它们的优先级而需要反转。这是在该示例中的加法和乘法的情况，由于加法运算符在乘法运算符之前，并且具有较低的优先级，因此需要在使用乘法运算符之后出现。 由于这种顺序的反转，考虑使用栈来保存运算符直到用到它们是有意义的。<br>(A + B)* C的情况会是什么样呢？ 回想一下，A B + C <em>是等价的后缀表达式。从左到右处理此中缀表达式，我们先看到 +。 在这种情况下，当我们看到 <em>，+已经放置在结果表达式中，由于括号它的优先级高于</em>。 我们现在可以开始看看转换算法如何工作。当我们看到左括号时，我们保存它，表示高优先级的另一个运算符将出现。该操作符需要等到相应的右括号出现以表示其位置（回忆完全括号的算法）。 当右括号出现时，可以从栈中弹出操作符。<br>当我们从左到右扫描中缀表达式时，我们将使用栈来保留运算符。这将提供我们在第一个例子中注意到的反转。 堆栈的顶部将始终是最近保存的运算符。每当我们读取一个新的运算符时，我们需要考虑该运算符如何与已经在栈上的运算符（如果有的话）比较优先级。<br>假设中缀表达式是一个由空格分隔的标记字符串。 操作符标记是</em>，/，+和 - ，以及左右括号。操作数是单字符 A，B，C 等。 以下步骤将后缀顺序生成一个字符串。<br>创建一个名为 opstack 的空栈以保存运算符。给输出创建一个空列表。<br>通过使用字符串方法拆分将输入的中缀字符串转换为标记列表。<br>从左到右扫描标记列表。<br>如果标记是操作数，将其附加到输出列表的末尾。<br>如果标记是左括号，将其压到 opstack 上。<br>如果标记是右括号，则弹出 opstack，直到删除相应的左括号。将每个运算符附加到输出列表的末尾。<br>如果标记是运算符，*，/，+或 - ，将其压入 opstack。但是，首先删除已经在 opstack 中具有更高或相等优先级的任何运算符，并将它们加到输出列表中。<br>当输入表达式被完全处理时，检查 opstack。仍然在栈上的任何运算符都可以删除并加到输出列表的末尾。<br>Figure 9 展示了对表达式 A * B + C * D 的转换算法。注意，第一个 * 在看到 + 运算符时被删除。另外，当第二个 * 出现时， + 保留在栈中，因为乘法优先级高于加法。在中缀表达式的末尾，栈被弹出两次，删除两个运算符，并将 + 作为后缀表达式中的最后一个运算符。<br>3.9.中缀后缀和后缀表达式.figure9</p>
<p>Figure 9<br>为了在 Python 中编写算法，我们使用一个名为 prec 的字典来保存操作符的优先级。这个字典将每个运算符映射到一个整数，可以与其他运算符的优先级（我们使用整数3，2和1）进行比较。左括号将赋予最低的值。这样，与其进行比较的任何运算符将具有更高的优先级，将被放置在它的顶部。第15行将操作数定义为任何大写字符或数字。完整的转换函数见 ActiveCode 1。<br>from pythonds.basic.stack import Stack</p>
<p>def infixToPostfix(infixexpr):<br>    prec = {}<br>    prec[“*”] = 3<br>    prec[“/“] = 3<br>    prec[“+”] = 2<br>    prec[“-“] = 2<br>    prec[“(“] = 1<br>    opStack = Stack()<br>    postfixList = []<br>    tokenList = infixexpr.split()</p>
<pre><code>for token in tokenList:
    if token in &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot; or token in &quot;0123456789&quot;:
        postfixList.append(token)
    elif token == &#39;(&#39;:
        opStack.push(token)
    elif token == &#39;)&#39;:
        topToken = opStack.pop()
        while topToken != &#39;(&#39;:
            postfixList.append(topToken)
            topToken = opStack.pop()
    else:
        while (not opStack.isEmpty()) and \
           (prec[opStack.peek()] &gt;= prec[token]):
              postfixList.append(opStack.pop())
        opStack.push(token)

while not opStack.isEmpty():
    postfixList.append(opStack.pop())
return &quot; &quot;.join(postfixList)
</code></pre>
<p>print(infixToPostfix(“A * B + C * D”))<br>print(infixToPostfix(“( A + B ) * C - ( D - E ) * ( F + G )”))<br>执行结果如下</p>
<blockquote>
<blockquote>
<blockquote>
<p>infixtopostfix(“( A + B ) * ( C + D )”)<br>‘A B + C D + *’<br>infixtopostfix(“( A + B ) * C”)<br>‘A B + C *’<br>infixtopostfix(“A + B * C”)<br>‘A B C * +’</p>
</blockquote>
<p>3.9.3.后缀表达式求值<br>作为最后栈的示例，我们考虑对后缀符号中的表达式求值。在这种情况下，栈再次是我们选择的数据结构。但是，在扫描后缀表达式时，它必须等待操作数，而不像上面的转换算法中的运算符。 解决问题的另一种方法是，每当在输入上看到运算符时，计算两个最近的操作数。<br>要详细的了解这一点，考虑后缀表达式 4 5 6 * +， 首先遇到操作数 4 和 5，此时，你还不确定如何处理它们，直到看到下一个符号。将它们放置到栈上，确保它们在下一个操作符出现时可用。<br>在这种情况下，下一个符号是另一个操作数。所以，像先前一样，压入栈中。并检查下一个符号。现在我们看到了操作符 *，这意味着需要将两个最近的操作数相乘。通过弹出栈两次，我们可以得到正确的两个操作数，然后执行乘法（这种情况下结果为 30）。<br>我们现在可以通过将其放回栈中来处理此结果，以便它可以表示为表达式后面的运算符的操作数。当处理最后一个操作符时，栈上只有一个值，弹出并返回它作为表达式的结果。Figure 10 展示了整个示例表达式的栈的内容。<br>3.9.中缀后缀和后缀表达式.figure10</p>
</blockquote>
</blockquote>
<p>Figure 10<br>Figure 11 是个稍微复杂的示例，7 8 + 3 2 + / 。在这个例子中有两点需要注意，首先，栈的大小增长收缩，然后再子表达式求值的时候再次增长。第二，除法操作需要谨慎处理。回想下，后缀表达式的操作符顺序没变，仅仅改变操作符的位置。当用于除法的操作符从栈中弹出时，它们被反转。由于除法不是交换运算符，换句话说 15/5和 5/15 不同，因此我们必须保证操作数的顺序不会交换。<br>3.9.中缀后缀和后缀表达式.figure11</p>
<p>Figure 11<br>假设后缀表达式是一个由空格分隔的标记字符串。 运算符为<em>，/，+和 - ，操作数假定为单个整数值。 输出将是一个整数结果。<br>创建一个名为 operandStack 的空栈。<br>拆分字符串转换为标记列表。<br>从左到右扫描标记列表。<br>如果标记是操作数，将其从字符串转换为整数，并将值压到operandStack。<br>如果标记是运算符</em>，/，+或-，它将需要两个操作数。弹出operandStack 两次。 第一个弹出的是第二个操作数，第二个弹出的是第一个操作数。执行算术运算后，将结果压到操作数栈中。<br>当输入的表达式被完全处理后，结果就在栈上，弹出 operandStack 并返回值。<br>用于计算后缀表达式的完整函数见 ActiveCode 2，为了辅助计算，定义了一个函数 doMath, 它将获取两个操作数和运算符，执行相应的计算。<br>from pythonds.basic.stack import Stack</p>
<p>def postfixEval(postfixExpr):<br>    operandStack = Stack()<br>    tokenList = postfixExpr.split()</p>
<pre><code>for token in tokenList:
    if token in &quot;0123456789&quot;:
        operandStack.push(int(token))
    else:
        operand2 = operandStack.pop()
        operand1 = operandStack.pop()
        result = doMath(token,operand1,operand2)
        operandStack.push(result)
return operandStack.pop()
</code></pre>
<p>def doMath(op, op1, op2):<br>    if op == “*”:<br>        return op1 * op2<br>    elif op == “/“:<br>        return op1 / op2<br>    elif op == “+”:<br>        return op1 + op2<br>    else:<br>        return op1 - op2</p>
<p>print(postfixEval(‘7 8 + 3 2 + /‘))</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>排序和搜索</title>
    <url>/data_structure/sort_and_search/</url>
    <content><![CDATA[<!-- TOC -->

<ul>
<li><a href="#%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2">排序和搜索</a><ul>
<li><a href="#%E7%9B%AE%E6%A0%87">目标</a></li>
<li><a href="#%E6%90%9C%E7%B4%A2">搜索</a></li>
<li><a href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE">顺序查找</a><ul>
<li><a href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E5%88%86%E6%9E%90">顺序查找分析</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">二分查找</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h2 id="排序和搜索"><a href="#排序和搜索" class="headerlink" title="排序和搜索"></a>排序和搜索</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul>
<li>能够解释和实现顺序查找和二分查找。</li>
<li>能够解释和实现选择排序，冒泡排序，归并排序，快速排序，插入排序和希尔排序。</li>
<li>理解哈希作为搜索技术的思想。</li>
<li>引入映射抽象数据类型。</li>
<li>使用哈希实现 Map 抽象数据类型。<a id="more"></a>
<h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3>我们现在把注意力转向计算中经常出现的一些问题，即搜索和排序问题。在本节中，我们将研究搜索。我们将在本章后面的章节中介绍。<strong>搜索</strong>是在项集合中查找特定项的算法过程。搜索通常对于项是否存在返回<code>True</code>或<code>False</code>。有时它可能返回项被找到的地方。我们在这里将仅关注成员是否存在这个问题。</li>
</ul>
<p>在Python中，有一个非常简单的方法来询问一个项是否在一个项列表中。我们使用<code>in</code>运算符。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">15</span> <span class="keyword">in</span> [<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> <span class="keyword">in</span> [<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>这很容易写，一个底层的操作替我们完成这个工作。事实证明，有很多不同的方法来搜索。我们在这里感兴趣的是这些算法如何工作以及它们如何相互比较。</p>
<h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><p>当数据项存储在诸如列表的集合中时，我们说它们具有线性或顺序关系。每个数据项都存储在相对于其他数据项的位置。在Python列表中，这些相对位置是单个项的索引值。由于这些索引值是有序的，我们可以按顺序访问它们。这个过程产生我们的第一种搜索技术<strong>顺序查找</strong>。</p>
<p><code>Figure 1</code>展示了这种搜索的工作原理。从列表中的第一个项目开始，我们按照基本的顺序排序，简单地从一个项移动到另一个项，直到找到我们正在寻找的项或遍历完整个列表。如果我们遍历完整个列表，则说明正在搜索的项不存在。<br><img src="sort_and_search/figure1.png">Figure 1</p>
<p>该算法的Python实现见CodeLens 1。该函数需要一个列表和我们正在寻找的项作为参数，并返回一个是否存在的布尔值。found布尔变量初始化为<code>False</code>，如果我们发现列表中的项，则赋值为<code>True</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sequentialSearch</span>(<span class="params">alist, item</span>):</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> alist:</span><br><span class="line">        <span class="keyword">if</span> a == item:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">testlist = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">32</span>, <span class="number">8</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">42</span>, <span class="number">13</span>, <span class="number">0</span>]</span><br><span class="line">print(sequentialSearch(testlist, <span class="number">3</span>))</span><br><span class="line">print(sequentialSearch(testlist, <span class="number">13</span>))</span><br></pre></td></tr></table></figure>
<h4 id="顺序查找分析"><a href="#顺序查找分析" class="headerlink" title="顺序查找分析"></a>顺序查找分析</h4><p>为了分析搜索算法，我们需要定一个基本计算单位。回想一下，这通常是为了解决问题要重复的共同步骤。对于搜索，计算比较操作数是有意义的。每个比较都有可能找到我们正在寻找的项目。此外，我们在这里做另一个假设。项列表不以任何方式排序。项随机放置到列表中。换句话说，项在列表任何位置的概率是一样的。</p>
<p>如果项不在列表中，知道它的唯一方法是将其与存在的每个项进行比较。如果有n个项，则顺序查找需要n个比较来发现项不存在。在项在列表中的情况下，分析不是那么简单。实际上有三种不同的情况可能发生。在最好的情况下，我们在列表的开头找到所需的项，只需要一个比较。在最坏的情况下，我们直到最后的比较才找到项，第 n个比较。</p>
<p>平均情况怎么样？平均来说，我们会在列表的一半找到该项; 也就是说，我们将比较 n/2项。然而，回想一下，当n变大时，系数，无论它们是什么，在我们的近似中变得不重要，因此顺序查找的复杂度是<code>O(n)</code>。Table 1总结了这些结果。<br><img src="sort_and_search/table1.png"> Table 1</p>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>有序列表对于我们的比较是很有用的。在顺序查找中，当我们与第一个项进行比较时，如果第一个项不是我们要查找的，则最多还有n-1个项目。 二分查找从中间项开始，而不是按顺序查找列表。如果该项是我们正在寻找的项，我们就完成了查找。如果它不是，我们可以使用列表的有序性质来消除剩余项的一半。如果我们正在查找的项大于中间项，就可以消除中间项以及比中间项小的一半元素。如果该项在列表中，肯定在大的那半部分。</p>
<p>然后我们可以用大的半部分重复这个过程。从中间项开始，将其与我们正在寻找的内容进行比较。再次，我们找到元素或将列表分成两半，消除可能的搜索空间的另一部分。Figure 3展示了该算法如何快速找到值54。完整的函数见CodeLens 3中。<br><img src="sort_and_search/figure3.png">Figure 3</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span>(<span class="params">alist, item</span>):</span></span><br><span class="line">        first = <span class="number">0</span></span><br><span class="line">        last = <span class="built_in">len</span>(alist) - <span class="number">1</span></span><br><span class="line">        found = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> first &lt;= last <span class="keyword">and</span> <span class="keyword">not</span> found:</span><br><span class="line">            midpoint = (first + last) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> alist[midpoint] == item:</span><br><span class="line">                found = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> item &lt; alist[midpoint]:</span><br><span class="line">                    last = midpoint - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    first = midpoint + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> found</span><br><span class="line"></span><br><span class="line">testlist = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">32</span>, <span class="number">42</span>,]</span><br><span class="line">print(binarySearch(testlist, <span class="number">3</span>))</span><br><span class="line">print(binarySearch(testlist, <span class="number">13</span>))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>排序和搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>owt-server源码编译和部署</title>
    <url>/machine_learning/owt-server_install/</url>
    <content><![CDATA[<h2 id="owt-server源码编译和部署"><a href="#owt-server源码编译和部署" class="headerlink" title="owt-server源码编译和部署"></a>owt-server源码编译和部署</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>OWT的媒体服务器提供了一种高效的基于WebRTC的视频会议和流媒体服务。它将单个WebRTC流扩展到多个端点。同时，它为媒体流提供了媒体分析功能。它的特点:</p>
<ul>
<li>分布式、可扩展、可靠的SFU+MCU服务器</li>
<li>Intel®Core™和Intel®Xeon®处理器上的高性能VP8、VP9、H.264和HEVC实时转码</li>
<li>广泛的流协议支持包括WebRTC, RTSP, RTMP, HLS, MPEG-DASH</li>
<li>高效混合高清视频流，节省移动设备的带宽和电源</li>
<li>智能服务质量(QoS)控制机制，以适应不同的网络环境</li>
<li>客户定义的媒体分析插件，以执行分析流从MCU</li>
<li>实时媒体流分析的使用场景，包括但不限于移动/对象检测</li>
</ul>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install sudo wget curl git make gcc-6 g++-6 libglib2.0-dev pkg-config libboost1.67-dev liblog4cxx-dev gyp libx11-dev libkrb5-dev intel-gpu-tools m4 autoconf libtool automake cmake libfreetype6-dev libgstreamer-plugins-base1.0-dev lsb-core net-tools</span><br></pre></td></tr></table></figure>
<h4 id="node安装"><a href="#node安装" class="headerlink" title="node安装"></a>node安装</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl https://raw.githubusercontent.com/creationix/nvm/master/install.sh | bash</span><br><span class="line">nvm use v8.15.0</span><br><span class="line">node -v</span><br><span class="line">npm i --unsafe-perm</span><br><span class="line">npm --unsafe-perm=<span class="literal">true</span> --user=0 i</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="boost安装-不需要"><a href="#boost安装-不需要" class="headerlink" title="boost安装(不需要)"></a>boost安装(不需要)</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// sudo apt install libboost-all-dev</span><br><span class="line">// sudo apt install libboost1.65-dev</span><br><span class="line">dpkg -S /usr/include/boost/version.hpp</span><br><span class="line">// wget https://dl.bintray.com/boostorg/release/xxxx.tar.gz</span><br><span class="line">// <span class="built_in">cd</span> boost_1_65_1</span><br><span class="line">// sudo ./bootstrap.sh --with-toolset=gcc --with-python=python3.8</span><br><span class="line">// sudo ./b2 install --prefix=/usr/<span class="built_in">local</span></span><br><span class="line">// sudo ldconfig /usr/<span class="built_in">local</span>/lib</span><br></pre></td></tr></table></figure>
<h4 id="gcc安装（编译webrtc需要）"><a href="#gcc安装（编译webrtc需要）" class="headerlink" title="gcc安装（编译webrtc需要）"></a>gcc安装（编译webrtc需要）</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install gcc-6 g++-6</span><br><span class="line">sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-6 100</span><br><span class="line">sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-6 100</span><br><span class="line">sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 100</span><br><span class="line">sudo update-alternatives —config python3</span><br></pre></td></tr></table></figure>
<h4 id="源码获取"><a href="#源码获取" class="headerlink" title="源码获取"></a>源码获取</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b v4.3.1 https://github.com/open-webrtc-toolkit/owt-server.git</span><br><span class="line">git <span class="built_in">clone</span> -b v4.3.1 https://github.com/open-webrtc-toolkit/owt-client-javascript.git</span><br><span class="line"><span class="built_in">cd</span> owt-server</span><br><span class="line"><span class="comment">#下载依赖</span></span><br><span class="line">./scripts/installDepsUnattended.sh</span><br><span class="line"><span class="comment">#执行编译</span></span><br><span class="line">scripts/build.js -t all --check</span><br><span class="line">scripts/pack.js -t all --install-module --app-path <span class="variable">$&#123;webrtc-javascript-sdk-sample-conference-dist&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> dist</span><br><span class="line">./bin/init.sh --deps</span><br><span class="line">./bin/start-all.sh </span><br><span class="line">./bin/stop-all.sh</span><br><span class="line">./bin/restart-all.sh </span><br></pre></td></tr></table></figure>
<h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><h4 id="1-sipLib-so-gt-not-found-Something-failed-to-build-Try-nvm-use-v8-15-0-and-rerun-build-js-getRooms-failed-401"><a href="#1-sipLib-so-gt-not-found-Something-failed-to-build-Try-nvm-use-v8-15-0-and-rerun-build-js-getRooms-failed-401" class="headerlink" title="1. sipLib.so =&gt; not found Something failed to build. Try nvm use v8.15.0 and rerun build.js. getRooms failed( 401 )"></a>1. sipLib.so =&gt; not found Something failed to build. Try nvm use v8.15.0 and rerun build.js. getRooms failed( 401 )</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./managent_api/init.sh</span><br></pre></td></tr></table></figure>
<h4 id="2-打包的过程中出现缺少quicIO-node的时候"><a href="#2-打包的过程中出现缺少quicIO-node的时候" class="headerlink" title="2. 打包的过程中出现缺少quicIO.node的时候"></a>2. 打包的过程中出现缺少quicIO.node的时候</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">change /master/<span class="built_in">source</span>/agent/addons/quicIO/QuicTransport.cc line 74:</span><br><span class="line">boost::shared_array&lt;uint8_t&gt; new_buffer;</span><br><span class="line">to:</span><br><span class="line">boost::shared_array &lt; char &gt; new_buffer;</span><br></pre></td></tr></table></figure>
<h4 id="3-source-agent-video-videoTranscoder-videoAnalyzer-sw-build-Release-videoAnalyzer-sw-node-undefined-symbol-ZN5boost6system16generic-categoryEv"><a href="#3-source-agent-video-videoTranscoder-videoAnalyzer-sw-build-Release-videoAnalyzer-sw-node-undefined-symbol-ZN5boost6system16generic-categoryEv" class="headerlink" title="3. source/agent/video/videoTranscoder/videoAnalyzer_sw/build/Release/videoAnalyzer-sw.node: undefined symbol: _ZN5boost6system16generic_categoryEv"></a>3. source/agent/video/videoTranscoder/videoAnalyzer_sw/build/Release/videoAnalyzer-sw.node: undefined symbol: _ZN5boost6system16generic_categoryEv</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">boost 版本必须是1.6x</span><br></pre></td></tr></table></figure>
<h4 id="4-agent-addons-quicIO-build-Release-quicIO-node-not-exist"><a href="#4-agent-addons-quicIO-build-Release-quicIO-node-not-exist" class="headerlink" title="4. agent/addons/quicIO/build/Release/quicIO.node not exist"></a>4. agent/addons/quicIO/build/Release/quicIO.node not exist</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ./agent/addons/quicIO</span><br><span class="line">node-gyp configure</span><br><span class="line">node-gyp build</span><br></pre></td></tr></table></figure>
<h4 id="5-google浏览器证书问题"><a href="#5-google浏览器证书问题" class="headerlink" title="5. google浏览器证书问题"></a>5. google浏览器证书问题</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">thisisunsafe </span><br></pre></td></tr></table></figure>
<h4 id="6-error-‘RTCPHeader’-does-not-name-a-type"><a href="#6-error-‘RTCPHeader’-does-not-name-a-type" class="headerlink" title="6. error: ‘RTCPHeader’ does not name a type"></a>6. error: ‘RTCPHeader’ does not name a type</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi <span class="built_in">source</span>/agent/webrtc/webrtcLib/binding.gyp </span><br><span class="line"><span class="string">&#x27;erizo/src/erizo/lib&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;erizo/src/erizo/dtls&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;erizo/src/erizo/pipeline&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;erizo/src/erizo/rtp&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;erizo/src/erizo/thread&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;erizo/src/erizo/stats&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;../../../core/common&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;../../../core/owt_base&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;../../../core/rtc_adapter&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;../../../../third_party/webrtc/src&#x27;</span>,</span><br><span class="line"><span class="comment"># 改为:</span></span><br><span class="line"><span class="string">&#x27;erizo/src/erizo/lib&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;erizo/src/erizo/dtls&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;erizo/src/erizo/pipeline&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;erizo/src/erizo/thread&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;erizo/src/erizo/stats&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;../../../core/common&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;erizo/src/erizo/rtp&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;../../../core/owt_base&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;../../../core/rtc_adapter&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;../../../../third_party/webrtc/src&#x27;</span>,</span><br></pre></td></tr></table></figure>
<h4 id="7-webrtc不能加入会议室"><a href="#7-webrtc不能加入会议室" class="headerlink" title="7. webrtc不能加入会议室"></a>7. webrtc不能加入会议室</h4><p>目前查看是由于webrtc的代码版本造成，使用这个即可。<br>git clone -b 59-server <a href="https://github.com/open-webrtc-toolkit/owt-deps-webrtc.git">https://github.com/open-webrtc-toolkit/owt-deps-webrtc.git</a> src</p>
<h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><h3 id="镜像获取"><a href="#镜像获取" class="headerlink" title="镜像获取"></a>镜像获取</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull docker push xujavy/owt-server:v4.3.x</span><br><span class="line">docker run -itd -p 3004:3004 -p 3300:3300 -p 8080:8080 -p 60000-60050:60000-60050/udp -v /home/owt:/home/owt --name owt-server:v4.3.x /bin/bash</span><br></pre></td></tr></table></figure>
<h3 id="配置文件修改"><a href="#配置文件修改" class="headerlink" title="配置文件修改"></a>配置文件修改</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vi /home/owt/webrtc_agent/agent.toml </span></span><br><span class="line">[webrtc] network_interfaces = [&#123;name=<span class="string">&quot;eth0&quot;</span>,replaced_ip_address=<span class="string">&quot;192.168.1.4&quot;</span>&#125;]  <span class="comment"># default: [] </span></span><br><span class="line"><span class="comment"># vi /home/owt/portal/portal.toml [portal] ip_address = &quot;192.168.1.4&quot; #default: &quot;&quot;</span></span><br><span class="line"><span class="built_in">cd</span> /home/owt/&amp;&amp; ./bin/init-all.sh &amp;&amp; ./bin/start-all.sh</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>WebRTC</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title>Clickhouse性能优化</title>
    <url>/bigdata/clickhouse_optimize/</url>
    <content><![CDATA[<h2 id="Clickhouse性能优化"><a href="#Clickhouse性能优化" class="headerlink" title="Clickhouse性能优化"></a>Clickhouse性能优化</h2><!-- TOC -->

<ul>
<li><a href="#clickhouse%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">Clickhouse性能优化</a><ul>
<li><a href="#%E8%A7%86%E5%9B%BE">视图</a></li>
<li><a href="#%E7%89%A9%E5%8C%96%E8%A7%86%E5%9B%BE">物化视图</a></li>
<li><a href="#ck%E7%9A%84sql%E6%85%A2%E7%9A%84%E4%BC%98%E5%8C%96%E6%96%B9%E5%90%91">ck的sql慢的优化方向</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>ClickHouse中分为：普通视图和物化视图</p>
<ol>
<li><strong>普通视图：</strong> 不会存储数据，只保存了一个query，一般用作子查询，当base表删除后不可用</li>
<li><strong>物化视图：</strong> 存储执行query后得到的数据，创建视图时必须制定engine</li>
</ol>
<h3 id="物化视图"><a href="#物化视图" class="headerlink" title="物化视图"></a>物化视图</h3><p>通常物化视图，会做两个层面的物化视图，一个是<strong>维度层面</strong>的物化，一个是<strong>时序层面</strong>的物化。</p>
<p>什么是物化视图，假设一个数据源的原始维度有十个列，通过分析查询请求发现，group1 中的三个维度和 group2 中的三个维度分别经常同时出现，剩余的四个维度可能查询频率很低。更加严重的是，没有被查询的维度列里面有一个是高基维，就是 count district 值很大的维度，比如说像 User id 这种。这种情况下会存在很大的查询性能问题，因为高基维度会影响 Druid 的数据预聚合效果，聚合效果差就会导致索引文件 Size 变大，进而导致查询时的读 IO 变大，整体查询性能变差。针对这种 case 的优化，我们会将 group1 和 group2 这种维度分别建一个预聚合索引，然后当收到新的查询请求，系统会先分析请求里要查询维度集合，如果要查询的维度集合是刚才新建的专用的索引维度集合的一个子集，则直接访问刚才新建的索引就可以，不需要去访问原始的聚合索引，查询的性能会有一个比较明显的改善，这就是物化视图的一个设计思路，也是一个典型的用空间换时间的方案。</p>
<a id="more"></a>
<p>时序物化视图：除了刚才提到的查询场景外，还有一种查询 Case，Druid 也不能很好满足。比如大跨度时间范围的查询，假设一个数据源的聚合力度是分钟级别，但需要查询最近三个月的数据就比较麻烦，因为需要把过去三个月的所有分钟级别的索引文件全部扫描一遍，然后再做一次聚合的计算。</p>
<p>为了解决这个问题，我们在数据源分钟级别的索引上再新建一个小时级别甚至级别的物化索引，这种情况下聚合效果就会更好，索引整体的 size 也会比较小。当收到一个新的查询请求时，如果查询要统计的粒度是天级别或者是更高级别的查询粒度，会把查询请求自动路由到天级别物化索引上，这样查询性能也会有一个比较明显的改善。</p>
<h3 id="ck的sql慢的优化方向"><a href="#ck的sql慢的优化方向" class="headerlink" title="ck的sql慢的优化方向"></a>ck的sql慢的优化方向</h3><ol>
<li>分区，原则是尽量把经常一起用到的数据放到相同区（也可以根据where条件来分区），如果一个区太大再放到多个区，</li>
<li>主键（索引，即排序）order by字段选择：就是把where 里面肯定有的字段加到里面，where 中一定有的字段放到第一位，注意字段的区分度适中即可 区分度太大太小都不好，因为ck的索引时稀疏索引，采用的是按照固定的粒度抽样作为实际的索引值，不是mysql的二叉树，所以不建议使用区分度特别高的字段。<br>两种主键，第一种ORDER BY (industry, l1_name, l2_name, l3_name, job_city, job_area, row_id)，第二种不包含row_id字段，即ORDER BY (industry, l1_name, l2_name, l3_name, job_city, job_area)，其中row_id 是唯一的，在where条件中使用row_id来查询时，你会发现第二种会性能更好，即将row_id从主键中移除，查询效果更好</li>
</ol>
]]></content>
      <categories>
        <category>BigData</category>
      </categories>
      <tags>
        <tag>BigData</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树的最近公共祖先</title>
    <url>/leetcode/leetcode_lowest_common_ancestor_binary_search_tree/</url>
    <content><![CDATA[<h2 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>
<a id="more"></a>
<p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p>
<p><img src="leetcode_lowest_common_ancestor_binary_search_tree/binarysearchtree_improved.png"></p>
<p><strong>示例 1:</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4</span><br><span class="line">输出: 2</span><br><span class="line">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉搜索树中。<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3></li>
</ul>
<ol>
<li><p>分析</p>
<ul>
<li>有三种情况，p q 都在左子树或右子树，p q分别在左子树和右子树，判断当前遍历的节点是否为空，为空返回null，节点是否等于p，是否等于q，是的话返回null。</li>
<li>之后判断left和right是否为空，若都不为空，则当前root为答案，若其中一个为空，则返回另一边，为答案。</li>
</ul>
</li>
<li><p>Code</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; &#x27;TreeNode&#x27;:</span></span><br><span class="line">        <span class="keyword">if</span> (p.val &lt;= root.val <span class="keyword">and</span> q.val &gt;= root.val) <span class="keyword">or</span> (p.val &gt;= root.val <span class="keyword">and</span> q.val &lt;= root.val):</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">elif</span> (p.val &lt;= root.val):</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.right, p, q)</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>说明：</strong> 如果您有更好的解决方案或者本人写的有什么问题，请多多指教！</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的最近公共祖先</title>
    <url>/leetcode/leetcode_lowest_common_ancestor_binary_tree/</url>
    <content><![CDATA[<h2 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<a id="more"></a>
<p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]<br><img src="leetcode_lowest_common_ancestor_binary_tree/binarytree.png"></p>
<p><strong>示例 1:</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">输出: 3</span><br><span class="line">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span><br><span class="line">输出: 5</span><br><span class="line">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉树中。<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3></li>
</ul>
<ol>
<li><p>分析</p>
<ul>
<li>有三种情况，p q 都在左子树或右子树，p q分别在左子树和右子树，判断当前遍历的节点是否为空，为空返回null，节点是否等于p，是否等于q，是的话返回null。</li>
<li>之后判断left和right是否为空，若都不为空，则当前root为答案，若其中一个为空，则返回另一边，为答案。</li>
</ul>
</li>
<li><p>Code</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; &#x27;TreeNode&#x27;:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    <span class="keyword">if</span> root == p <span class="keyword">or</span> root == q:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    </span><br><span class="line">    leftNode = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">    rightNode = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> leftNode <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> rightNode <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> leftNode <span class="keyword">if</span> leftNode <span class="keyword">else</span> rightNode</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>说明：</strong> 如果您有更好的解决方案或者本人写的有什么问题，请多多指教！</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Clickhouse集群搭建以及常用语句</title>
    <url>/bigdata/install_clickhouse/</url>
    <content><![CDATA[<h2 id="Clickhouse集群搭建"><a href="#Clickhouse集群搭建" class="headerlink" title="Clickhouse集群搭建"></a>Clickhouse集群搭建</h2><!-- TOC -->

<ul>
<li><a href="#clickhouse%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA">Clickhouse集群搭建</a><ul>
<li><a href="#%E7%AE%80%E4%BB%8B">简介</a><ul>
<li><a href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">应用场景：</a></li>
<li><a href="#%E6%9C%AC%E8%BA%AB%E7%9A%84%E9%99%90%E5%88%B6">本身的限制：</a></li>
</ul>
</li>
<li><a href="#%E5%AE%89%E8%A3%85">安装</a><ul>
<li><a href="#rpm%E5%AE%89%E8%A3%85">rpm安装</a></li>
<li><a href="#yum%E5%AE%89%E8%A3%85">yum安装</a></li>
<li><a href="#%E5%8D%95%E6%9C%BA%E9%85%8D%E7%BD%AE">单机配置</a></li>
</ul>
</li>
<li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4">分布式集群</a><ul>
<li><a href="#ck%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84">CK是如何实现分布式的</a></li>
</ul>
</li>
<li><a href="#%E7%AE%80%E5%8D%95%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%B9%E6%A1%88">简单分布式方案</a></li>
<li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88">分布式+高可用方案</a></li>
<li><a href="#ck%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E9%97%AE%E9%A2%98">CK分布式的问题</a></li>
<li><a href="#ck%E7%9A%84%E5%90%AF%E5%8A%A8">CK的启动</a></li>
<li><a href="#%E5%B8%B8%E7%94%A8sql%E6%80%BB%E7%BB%93">常用SQL总结</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Clickhouse是一个用于联机分析处理（OLAP）的列式数据库管理系统（columnar DBMS）。<br>传统数据库在数据大小比较小，索引大小适合内存，数据缓存命中率足够高的情形下能正常提供服务。但残酷的是，这种理想情形最终会随着业务的增长走到尽头，查询会变得越来越慢。你可能通过增加更多的内存，订购更快的磁盘等等来解决问题（纵向扩展），但这只是拖延解决本质问题。如果你的需求是解决怎样快速查询出结果，那么ClickHouse也许可以解决你的问题。</p>
<p>ClickHouse作为分析型数据库，有三大特点：一是跑分快，二是功能多，三是文艺范</p>
<h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h4><ol>
<li>绝大多数请求都是用于读访问的</li>
<li>数据需要以大批次（大于1000行）进行更新，而不是单行更新；或者根本没有更新操作</li>
<li>数据只是添加到数据库，没有必要修改</li>
<li>读取数据时，会从数据库中提取出大量的行，但只用到一小部分列</li>
<li>表很“宽”，即表中包含大量的列</li>
<li>查询频率相对较低（通常每台服务器每秒查询数百次或更少）</li>
<li>对于简单查询，允许大约50毫秒的延迟</li>
<li>列的值是比较小的数值和短字符串（例如，每个URL只有60个字节）</li>
<li>在处理单个查询时需要高吞吐量（每台服务器每秒高达数十亿行）</li>
<li>不需要事务</li>
<li>数据一致性要求较低</li>
<li>每次查询中只会查询一个大表。除了一个大表，其余都是小表</li>
<li>查询结果显著小于数据源。即数据有过滤或聚合。返回结果不超过单个服务器内存大小</li>
</ol>
<h4 id="本身的限制："><a href="#本身的限制：" class="headerlink" title="本身的限制："></a>本身的限制：</h4><ol>
<li>不支持真正的删除/更新支持 不支持事务（期待后续版本支持）</li>
<li>不支持二级索引</li>
<li>有限的SQL支持，join实现与众不同</li>
<li>不支持窗口功能</li>
<li>元数据管理需要人工干预维护<a id="more"></a>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="rpm安装"><a href="#rpm安装" class="headerlink" title="rpm安装"></a>rpm安装</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep -q sse4_2 /proc/cpuinfo &amp;&amp; echo &quot;SSE 4.2 supported&quot; || echo &quot;SSE 4.2 not supported&quot;</span><br><span class="line">wget https://repo.yandex.ru/clickhouse/rpm/stable/x86_64/clickhouse-client-19.4.0-2.noarch.rpm</span><br><span class="line">wget https://repo.yandex.ru/clickhouse/rpm/stable/x86_64/clickhouse-server-common-19.4.0-2.noarch.rpm</span><br><span class="line">wget https://repo.yandex.ru/clickhouse/rpm/stable/x86_64/clickhouse-server-19.4.0-2.noarch.rpm</span><br><span class="line">rpm -ivh *</span><br></pre></td></tr></table></figure>
<h4 id="yum安装"><a href="#yum安装" class="headerlink" title="yum安装"></a>yum安装</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -s https://packagecloud.io/install/repositories/altinity/clickhouse/script.rpm.sh | sudo bash</span><br><span class="line">yum list &#x27;clickhouse*&#x27;</span><br><span class="line">yum install -y clickhouse-server clickhouse-client</span><br><span class="line">yum list installed &#x27;clickhouse*&#x27;</span><br></pre></td></tr></table></figure>
<h4 id="单机配置"><a href="#单机配置" class="headerlink" title="单机配置"></a>单机配置</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@host201 scripts]# ls /etc/clickhouse-server/</span><br><span class="line">config.xml  users.xml</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>vi config.xml</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置<span class="built_in">log</span>位置</span></span><br><span class="line">&lt;log&gt;/data/clickhouse/server.log&lt;/log&gt;</span><br><span class="line">&lt;errorlog&gt;/data/clickhouse/error.log&lt;/errorlog&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改host</span></span><br><span class="line">&lt;interserver_http_host&gt;host201&lt;/interserver_http_host&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置外网访问</span></span><br><span class="line">&lt;listen_host&gt;0.0.0.0&lt;/listen_host&gt; </span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置数据存在路径</span></span><br><span class="line">&lt;path&gt;/data/clickhouse/&lt;/path&gt;</span><br><span class="line">&lt;!-- Path to temporary data for processing hard queries. --&gt;</span><br><span class="line">&lt;tmp_path&gt;/data/clickhouse/tmp/&lt;/tmp_path&gt;</span><br><span class="line">&lt;!-- Directory with user provided files that are accessible by &#x27;file&#x27; table function. --&gt;</span><br><span class="line">&lt;user_files_path&gt;/var/lib/clickhouse/user_files/&lt;/user_files_path&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置时区</span></span><br><span class="line">&lt;timezone&gt;Asia/Shanghai&lt;/timezone&gt; </span><br><span class="line"><span class="meta">#</span><span class="bash"> 在后面添加集群信息</span></span><br><span class="line">&lt;include_from&gt;/data/metrika.xml&lt;/include_from&gt;</span><br></pre></td></tr></table></figure>
<h3 id="分布式集群"><a href="#分布式集群" class="headerlink" title="分布式集群"></a>分布式集群</h3><h4 id="CK是如何实现分布式的"><a href="#CK是如何实现分布式的" class="headerlink" title="CK是如何实现分布式的"></a>CK是如何实现分布式的</h4><ul>
<li><p>CK的分布式，完全依赖配置文件，即每个节点，都共享同样的配置文件，这个配置文件里，写了我跟谁是一个cluster的，我自己的名字是啥</p>
</li>
<li><p>如下面的配置文件里，有4个分片，各自用域名来标记，如果需要密码的话，集群也要写上明文密码和用户名</p>
</li>
<li><p>集群怎么用? </p>
<ul>
<li>答案是指定引擎</li>
<li>CK里的引擎有十几个，这里只推荐3个：<ul>
<li><strong>MergeTree</strong>，是CK里最Advanced的引擎，性能超高，单机写入可以达到50w峰值，查询性能非常快，有兴趣看我其他文章</li>
<li><strong>ReplicatedMergeTree</strong>，基于MergeTree，同时引入ZK，做了复制，下文会说</li>
<li><strong>Distributed</strong>，分布式引擎，本身不存储数据，可认为就是一张View，如果写入，会把请求丢到集群里的节点（有算法控制），如果查询，会帮你做查询转发再聚合返回</li>
</ul>
</li>
</ul>
</li>
<li><p>集群文件的配置<br>  <strong>vi metrika.xml</strong></p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;yandex&gt;</span><br><span class="line">&lt;clickhouse_remote_servers&gt;</span><br><span class="line">    &lt;!-- 集群名称  --&gt;</span><br><span class="line">    &lt;ck_cluster&gt;</span><br><span class="line">        &lt;!-- 数据分片1  --&gt;</span><br><span class="line">        &lt;shard&gt;</span><br><span class="line">            &lt;internal_replication&gt;false&lt;/internal_replication&gt;</span><br><span class="line">            &lt;replica&gt;</span><br><span class="line">            &lt;default_database&gt;shardt&lt;/default_database&gt;</span><br><span class="line">            &lt;host&gt;host201&lt;/host&gt;</span><br><span class="line">            &lt;port&gt;9000&lt;/port&gt;</span><br><span class="line">            &lt;/replica&gt;</span><br><span class="line">        &lt;!--</span><br><span class="line">            &lt;replica&gt;</span><br><span class="line">            &lt;default_database&gt;shardt&lt;/default_database&gt;</span><br><span class="line">            &lt;host&gt;host202&lt;/host&gt;</span><br><span class="line">            &lt;port&gt;9000&lt;/port&gt;</span><br><span class="line">            &lt;/replica&gt;</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;/shard&gt;</span><br><span class="line">        &lt;!-- 数据分片2  --&gt;</span><br><span class="line">        &lt;shard&gt;</span><br><span class="line">            &lt;internal_replication&gt;false&lt;/internal_replication&gt;</span><br><span class="line">            &lt;replica&gt;</span><br><span class="line">            &lt;default_database&gt;shardt&lt;/default_database&gt;</span><br><span class="line">            &lt;host&gt;host202&lt;/host&gt;</span><br><span class="line">            &lt;port&gt;9000&lt;/port&gt;</span><br><span class="line">            &lt;/replica&gt;</span><br><span class="line">        &lt;!--</span><br><span class="line">            &lt;replica&gt;</span><br><span class="line">            &lt;default_database&gt;shardt&lt;/default_database&gt;</span><br><span class="line">            &lt;host&gt;host203&lt;/host&gt;</span><br><span class="line">            &lt;port&gt;9000&lt;/port&gt;</span><br><span class="line">            &lt;/replica&gt;</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;/shard&gt;</span><br><span class="line">        &lt;!-- 数据分片2  --&gt;</span><br><span class="line">        &lt;shard&gt;</span><br><span class="line">            &lt;internal_replication&gt;false&lt;/internal_replication&gt;</span><br><span class="line">            &lt;replica&gt;</span><br><span class="line">            &lt;default_database&gt;shardt&lt;/default_database&gt;</span><br><span class="line">            &lt;host&gt;host203&lt;/host&gt;</span><br><span class="line">            &lt;port&gt;9000&lt;/port&gt;</span><br><span class="line">            &lt;/replica&gt;</span><br><span class="line">        &lt;!--</span><br><span class="line">            &lt;replica&gt;</span><br><span class="line">            &lt;default_database&gt;shardt&lt;/default_database&gt;</span><br><span class="line">            &lt;host&gt;host205&lt;/host&gt;</span><br><span class="line">            &lt;port&gt;9000&lt;/port&gt;</span><br><span class="line">            &lt;/replica&gt;</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;/shard&gt;</span><br><span class="line">        &lt;!-- 数据分片2  --&gt;</span><br><span class="line">        &lt;shard&gt;</span><br><span class="line">            &lt;internal_replication&gt;false&lt;/internal_replication&gt;</span><br><span class="line">            &lt;replica&gt;</span><br><span class="line">            &lt;default_database&gt;shardt&lt;/default_database&gt;</span><br><span class="line">            &lt;host&gt;host205&lt;/host&gt;</span><br><span class="line">            &lt;port&gt;9000&lt;/port&gt;</span><br><span class="line">            &lt;/replica&gt;</span><br><span class="line">                &lt;!--</span><br><span class="line">            &lt;replica&gt;</span><br><span class="line">            &lt;default_database&gt;shardt&lt;/default_database&gt;</span><br><span class="line">            &lt;host&gt;host201&lt;/host&gt;</span><br><span class="line">            &lt;port&gt;9000&lt;/port&gt;</span><br><span class="line">            &lt;/replica&gt;</span><br><span class="line">                --&gt;</span><br><span class="line">        &lt;/shard&gt;</span><br><span class="line">    &lt;/ck_cluster&gt;</span><br><span class="line">    &lt;bip_ck_cluster2&gt;</span><br><span class="line">        &lt;shard&gt;</span><br><span class="line">            &lt;internal_replication&gt;false&lt;/internal_replication&gt;</span><br><span class="line">            &lt;replica&gt;</span><br><span class="line">            &lt;default_database&gt;shardt&lt;/default_database&gt;</span><br><span class="line">            &lt;host&gt;host202&lt;/host&gt;</span><br><span class="line">            &lt;port&gt;9000&lt;/port&gt;</span><br><span class="line">            &lt;/replica&gt;</span><br><span class="line">        &lt;/shard&gt;</span><br><span class="line">        &lt;shard&gt;</span><br><span class="line">            &lt;internal_replication&gt;false&lt;/internal_replication&gt;</span><br><span class="line">            &lt;replica&gt;</span><br><span class="line">            &lt;default_database&gt;shardt&lt;/default_database&gt;</span><br><span class="line">            &lt;host&gt;host203&lt;/host&gt;</span><br><span class="line">            &lt;port&gt;9000&lt;/port&gt;</span><br><span class="line">            &lt;/replica&gt;</span><br><span class="line">        &lt;/shard&gt;</span><br><span class="line">        &lt;shard&gt;</span><br><span class="line">            &lt;internal_replication&gt;false&lt;/internal_replication&gt;</span><br><span class="line">            &lt;replica&gt;</span><br><span class="line">            &lt;default_database&gt;shardt&lt;/default_database&gt;</span><br><span class="line">            &lt;host&gt;host205&lt;/host&gt;</span><br><span class="line">            &lt;port&gt;9000&lt;/port&gt;</span><br><span class="line">            &lt;/replica&gt;</span><br><span class="line">        &lt;/shard&gt;</span><br><span class="line">    &lt;/bip_ck_cluster2&gt;</span><br><span class="line">&lt;/clickhouse_remote_servers&gt;</span><br><span class="line">&lt;!-- 监听网络（貌似重复） --&gt;</span><br><span class="line">&lt;networks&gt;</span><br><span class="line">    &lt;ip&gt;::/0&lt;/ip&gt;</span><br><span class="line">&lt;/networks&gt;</span><br><span class="line">&lt;!-- ZK  --&gt;</span><br><span class="line">&lt;zookeeper-servers&gt;</span><br><span class="line">    &lt;node index=&quot;1&quot;&gt;</span><br><span class="line">        &lt;host&gt;host201&lt;/host&gt;   </span><br><span class="line">        &lt;!-- clickhouse 与 zookeeper的连接，也就要改成了host201  --&gt;</span><br><span class="line">        &lt;port&gt;2181&lt;/port&gt;</span><br><span class="line">    &lt;/node&gt;</span><br><span class="line">    &lt;node index=&quot;2&quot;&gt;</span><br><span class="line">        &lt;host&gt;host202&lt;/host&gt;   </span><br><span class="line">        &lt;!-- clickhouse 与 zookeeper的连接 也就要改成了host202  --&gt;</span><br><span class="line">        &lt;port&gt;2181&lt;/port&gt;</span><br><span class="line">    &lt;/node&gt;</span><br><span class="line">    &lt;node index=&quot;3&quot;&gt;</span><br><span class="line">        &lt;host&gt;host203&lt;/host&gt;   </span><br><span class="line">        &lt;!-- clickhouse 与 zookeeper的连接 也就要改成了host203 --&gt;</span><br><span class="line">        &lt;port&gt;2181&lt;/port&gt;</span><br><span class="line">    &lt;/node&gt;</span><br><span class="line">    &lt;node index=&quot;4&quot;&gt;</span><br><span class="line">        &lt;host&gt;host205&lt;/host&gt;</span><br><span class="line">        &lt;!-- clickhouse 与 zookeeper的连接 也就要改成了host205  --&gt;</span><br><span class="line">        &lt;port&gt;2181&lt;/port&gt;</span><br><span class="line">    &lt;/node&gt;</span><br><span class="line">&lt;/zookeeper-servers&gt;</span><br><span class="line">&lt;clickhouse_compression&gt;</span><br><span class="line">    &lt;case&gt;</span><br><span class="line">        &lt;min_part_size&gt;10000000000&lt;/min_part_size&gt;</span><br><span class="line">        &lt;min_part_size_ratio&gt;0.01&lt;/min_part_size_ratio&gt;</span><br><span class="line">        &lt;method&gt;lz4&lt;/method&gt;</span><br><span class="line">    &lt;/case&gt;</span><br><span class="line">&lt;/clickhouse_compression&gt;</span><br><span class="line">&lt;/yandex&gt;</span><br></pre></td></tr></table></figure>
<h3 id="简单分布式方案"><a href="#简单分布式方案" class="headerlink" title="简单分布式方案"></a>简单分布式方案</h3></li>
<li><p>MergeTree + Distributed</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CREATE TABLE dbname.tablename (date DateTime, ……) ENGINE = MergeTree()</span><br><span class="line">PARTITION BY toYYYYMMDD(date)</span><br><span class="line"></span><br><span class="line">CREATE TABLE dbname.tablename_all (date DateTime, ……) ENGINE = Distributed(ck_cluster, &#x27;dbname&#x27;, &#x27;tablename&#x27;, rand())&quot;</span><br></pre></td></tr></table></figure>
<p>  <strong>说明:</strong> </p>
<ul>
<li>dbname.tablename为本地表，数据只是在本地</li>
<li>dbname.tablename_all为分布式表，查询这个表，引擎自动把整个集群数据计算后返回</li>
</ul>
</li>
</ul>
<h3 id="分布式-高可用方案"><a href="#分布式-高可用方案" class="headerlink" title="分布式+高可用方案"></a>分布式+高可用方案</h3><ul>
<li>ReplicatedMergeTree + Distributed</li>
<li>仅仅是把MergeTree引擎替换为ReplicatedMergeTree引擎</li>
<li>ReplicatedMergeTree里，共享同一个ZK路径的表，会相互，注意是，相互同步数据  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CREATE TABLE dbname.tablename (date DateTime, ……) ENGINE = ReplicatedMergeTree(&#x27;/clickhouse/db/tb/name&#x27;, &#x27;node_name&#x27;, date, (date, hour, datetime), 8192)</span><br><span class="line"></span><br><span class="line">CREATE TABLE dbname.tablename_all (date DateTime, ……) ENGINE = Distributed(ck_cluster, &#x27;dbname&#x27;, &#x27;tablename&#x27;, rand())&quot;</span><br></pre></td></tr></table></figure></li>
<li>每个IDC有3个分片，各自占1/3数据</li>
<li>每个节点，依赖ZK，各自有2个副本，这样，就不怕宕机啦~<h3 id="CK分布式的问题"><a href="#CK分布式的问题" class="headerlink" title="CK分布式的问题"></a>CK分布式的问题</h3></li>
<li>数据写入时，该写入哪张表写<ol>
<li>可以写xxx_all，也可以写xxx本地表</li>
<li>前者由于分布式表的逻辑简单，仅仅是转发请求，所以在转发安全性上，会有风险，并且rand的方式，可能会造成不均衡，<strong>建议通过DNS轮训，写本地表，这样最保险和均衡</strong></li>
</ol>
</li>
<li>数据查询时，我们读取哪张表<ol>
<li>毫无疑问，是xxx_all表</li>
</ol>
</li>
<li>集群配置里，我们用了域名，本想着方便切换，但是CK只有在启动的时候，才会做解析</li>
<li>那故障了怎么切换?<ol>
<li>CK有一个厉害的地方，节点变动，无需重启，会自动加载</li>
<li>利用上述特性，我们先去掉一个节点的配置，再加上这个节点的配置（DNS变更后），即可不重启就完成fail over</li>
</ol>
</li>
</ul>
<h3 id="CK的启动"><a href="#CK的启动" class="headerlink" title="CK的启动"></a>CK的启动</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo /etc/init.d/clickhouse-server strart/stop/restart</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果修改了域名 请以域名登录</span></span><br><span class="line">clickhouse-client -h host201 </span><br></pre></td></tr></table></figure>
<h3 id="常用SQL总结"><a href="#常用SQL总结" class="headerlink" title="常用SQL总结"></a>常用SQL总结</h3><ol>
<li>创建表 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> shardt.nc2csv; </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> shardt.nc2csv (</span><br><span class="line">    id Int64,</span><br><span class="line">    province_name String,</span><br><span class="line">    city_name String,</span><br><span class="line">    product_time Datetime,</span><br><span class="line">    lon Float64,</span><br><span class="line">    lat Float64,</span><br><span class="line">    u10 Float64,</span><br><span class="line">    v10 Float64,</span><br><span class="line">    t2 Float64,</span><br><span class="line">    rainc Float64,</span><br><span class="line">    q2 Float64,</span><br><span class="line">    psfc Float64,</span><br><span class="line">    cfract Float64,</span><br><span class="line">    ws Float64,</span><br><span class="line">    wd Float64</span><br><span class="line">)ENGINE <span class="operator">=</span> MergeTree()</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMMDD(product_time)</span><br><span class="line"><span class="keyword">PRIMARY</span> Key (id, product_time, province_name, city_name)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (id, product_time, province_name, city_name)</span><br><span class="line">SETTINGS index_granularity <span class="operator">=</span> <span class="number">8192</span>;</span><br></pre></td></tr></table></figure></li>
<li>导入CSV数据 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">time cat test.csv | clickhouse-client -h host201 --port 9000 --format_csv_delimiter=&quot;,&quot; --input_format_allow_errors_num=1 --input_format_allow_errors_ratio=0.1 --query=&quot;INSERT INTO shardt.nc2csv FORMAT CSVWithNames&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line">time clickhouse-client -h host201 --port 9000 --format_csv_delimiter=&quot;,&quot; --input_format_allow_errors_num=1 --input_format_allow_errors_ratio=0.1 --query=&quot;INSERT INTO shardt.nc2csv FORMAT CSVWithNames&quot; &lt; test.csv</span><br></pre></td></tr></table></figure>
 <strong>说明：</strong><ul>
<li>指定分隔符: –format_csv_delimiter=”,” </li>
<li>导入数据时忽略错误:<ul>
<li><code>--input_format_allow_errors_num</code> : 是允许的错误数</li>
<li><code>--input_format_allow_errors_ratio</code> : 是允许的错误率, 范围是 [0-1]</li>
</ul>
</li>
<li>CSV文件有列名： FORMAT CSVWithNames</li>
</ul>
</li>
<li>导出 CSV 数据 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">clickhouse-client -h host201 --query=&quot;select * from shardt.nc2csv_2  WHERE product_time = (toDateTime(&#x27;2018-03-04 04:00:00&#x27;)) limit 10 format CSV&quot; &gt; test.csv</span><br></pre></td></tr></table></figure></li>
<li>重命名表 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">rename <span class="keyword">table</span> tbl1 <span class="keyword">to</span> btl2;</span><br></pre></td></tr></table></figure></li>
<li>删除表 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> tbl;</span><br></pre></td></tr></table></figure>
 **注意: ** 默认情况下, Clickhouse不允许删除分区或表的大小大于 50GB的分区或表. 可以通过修改server的配置文件来永久配置. 也可以临时设置一下来删除而不用重启服务.<ul>
<li>永久配置  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/clickhouse-server/config.xml</span><br><span class="line">然后注释掉下面两行</span><br><span class="line">    &lt;!-- &lt;max_table_size_to_drop&gt;0&lt;/max_table_size_to_drop&gt; --&gt;</span><br><span class="line">    &lt;!-- &lt;max_partition_size_to_drop&gt;0&lt;/max_partition_size_to_drop&gt; --&gt;</span><br><span class="line">0表示不限制. 或者你可以设置为你想限制的最大的大小.    </span><br></pre></td></tr></table></figure></li>
<li>临时设置  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo touch &#x27;/home/username/clickhouse/flags/force_drop_table&#x27; &amp;&amp; sudo chmod 666 &#x27;/home/username/clickhouse/flags/force_drop_table&#x27;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>添加列 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> dsp_statis <span class="keyword">add</span> <span class="keyword">column</span> cost UInt32 <span class="keyword">default</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
<li>查看表结构 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">desc</span> tbl;</span><br></pre></td></tr></table></figure></li>
<li>查看集群信息 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> system.clusters;</span><br></pre></td></tr></table></figure></li>
<li>执行SQL文件 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">clickhouse<span class="operator">-</span>client <span class="operator">-</span>h host205 <span class="operator">-</span>mn <span class="operator">&lt;</span> create_cluster.sql</span><br></pre></td></tr></table></figure></li>
<li>查看分区信息<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">partition</span>, name, <span class="built_in">count</span>() <span class="keyword">AS</span> number_of_parts, formatReadableSize(<span class="built_in">sum</span>(bytes)) <span class="keyword">AS</span> sum_size</span><br><span class="line"><span class="keyword">FROM</span> system.parts </span><br><span class="line"><span class="keyword">WHERE</span> active <span class="keyword">AND</span> (database <span class="operator">=</span> <span class="string">&#x27;xxx&#x27;</span>) <span class="keyword">AND</span> (<span class="keyword">table</span> <span class="operator">=</span> <span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">partition</span>, name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">partition</span> <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure></li>
<li>查看表大小<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">database,</span><br><span class="line"><span class="keyword">table</span>,</span><br><span class="line">formatReadableSize(size) <span class="keyword">AS</span> size,</span><br><span class="line">formatReadableSize(bytes_on_disk) <span class="keyword">AS</span> bytes_on_disk,</span><br><span class="line">formatReadableSize(data_uncompressed_bytes) <span class="keyword">AS</span> data_uncompressed_bytes,</span><br><span class="line">formatReadableSize(data_compressed_bytes) <span class="keyword">AS</span> data_compressed_bytes,</span><br><span class="line">compress_rate,</span><br><span class="line"><span class="keyword">rows</span>,</span><br><span class="line">days,</span><br><span class="line">formatReadableSize(avgDaySize) <span class="keyword">AS</span> avgDaySize</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        database,</span><br><span class="line">        <span class="keyword">table</span>,</span><br><span class="line">        <span class="built_in">sum</span>(bytes) <span class="keyword">AS</span> size,</span><br><span class="line">        <span class="built_in">sum</span>(<span class="keyword">rows</span>) <span class="keyword">AS</span> <span class="keyword">rows</span>,</span><br><span class="line">        <span class="built_in">min</span>(min_date) <span class="keyword">AS</span> min_date,</span><br><span class="line">        <span class="built_in">max</span>(max_date) <span class="keyword">AS</span> max_date,</span><br><span class="line">        <span class="built_in">sum</span>(bytes_on_disk) <span class="keyword">AS</span> bytes_on_disk,</span><br><span class="line">        <span class="built_in">sum</span>(data_uncompressed_bytes) <span class="keyword">AS</span> data_uncompressed_bytes,</span><br><span class="line">        <span class="built_in">sum</span>(data_compressed_bytes) <span class="keyword">AS</span> data_compressed_bytes,</span><br><span class="line">        (data_compressed_bytes <span class="operator">/</span> data_uncompressed_bytes) <span class="operator">*</span> <span class="number">100</span> <span class="keyword">AS</span> compress_rate,</span><br><span class="line">        max_date <span class="operator">-</span> min_date <span class="keyword">AS</span> days,</span><br><span class="line">        size <span class="operator">/</span> (max_date <span class="operator">-</span> min_date) <span class="keyword">AS</span> avgDaySize</span><br><span class="line">    <span class="keyword">FROM</span> system.parts</span><br><span class="line">    <span class="keyword">WHERE</span> active</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">        database,</span><br><span class="line">        <span class="keyword">table</span></span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">        database <span class="keyword">ASC</span>,</span><br><span class="line">        size <span class="keyword">DESC</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>BigData</category>
      </categories>
      <tags>
        <tag>BigData</tag>
      </tags>
  </entry>
  <entry>
    <title>Accumulo集群搭建</title>
    <url>/bigdata/install_accumulo/</url>
    <content><![CDATA[<h2 id="Accumulo集群搭建"><a href="#Accumulo集群搭建" class="headerlink" title="Accumulo集群搭建"></a>Accumulo集群搭建</h2><!-- TOC -->

<ul>
<li><a href="#accumulo%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA">Accumulo集群搭建</a><ul>
<li><a href="#%E5%BC%80%E5%A7%8B%E5%AE%89%E8%A3%85">开始安装</a><ul>
<li><a href="#%E9%85%8D%E7%BD%AE">配置</a></li>
<li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a></li>
</ul>
</li>
<li><a href="#%E8%AE%BE%E7%BD%AE%E5%A4%9A%E4%B8%AA%E8%8A%82%E7%82%B9">设置多个节点</a></li>
<li><a href="#%E5%90%AF%E5%8A%A8accumulo">启动Accumulo</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h3 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://mirrors.tuna.tsinghua.edu.cn/apache/accumulo/1.9.3/accumulo-1.9.3-bin.tar.gz</span><br><span class="line">tar -zxvf accumulo-1.9.3-bin.tar.gz</span><br><span class="line">cd accumulo-1.9.3</span><br></pre></td></tr></table></figure>
<p><strong>验证是否满足安装需求:</strong> <code>./bin/build_native_library.sh</code><br>yum install gcc-c++<br><strong>注意:</strong> 需要首先安装Hadoop和Zookeeper，具体安装请查看本人文章<a href="https://javyxu.cn/bigdata/install_hadoop/">CentOS下安装Hadoop集群</a></p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><ol>
<li>初始化配置文件 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/bootstrap_config.sh</span><br></pre></td></tr></table></figure>
 出现以下配置设置： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Choose the heap configuration:</span><br><span class="line">1) 1GB</span><br><span class="line">2) 2GB</span><br><span class="line">3) 3GB</span><br><span class="line">4) 512MB</span><br><span class="line"><span class="meta">#</span><span class="bash">? 3</span></span><br><span class="line">Using &#x27;3GB&#x27; configuration</span><br><span class="line"></span><br><span class="line">Choose the Accumulo memory-map type:</span><br><span class="line">1) Java</span><br><span class="line">2) Native</span><br><span class="line"><span class="meta">#</span><span class="bash">? 1</span></span><br><span class="line">Using &#x27;jvm&#x27; configuration</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Choose the Apache Hadoop version:</span><br><span class="line">1) Hadoop 2</span><br><span class="line">2) HDP 2.0/2.1</span><br><span class="line">3) HDP 2.2</span><br><span class="line">4) IOP 4.1</span><br><span class="line">5) Hadoop 3</span><br><span class="line"><span class="meta">#</span><span class="bash">? 1</span></span><br><span class="line">Using Hadoop version &#x27;2&#x27; configuration</span><br><span class="line"></span><br><span class="line">Setup complete</span><br></pre></td></tr></table></figure></li>
<li>修改accumulo-site.xml文件 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi conf/accumulo-site.xml</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;instance.volumes&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;hdfs://0.0.0.0:9000/accumulo&lt;/value&gt;</span><br><span class="line">    &lt;description&gt;comma separated list of URIs for volumes. example: hdfs://localhost:9000/accumulo&lt;/description&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;instance.zookeeper.host&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;0.0.0.0:2181&lt;/value&gt;</span><br><span class="line">    &lt;description&gt;comma separated list of zookeeper servers&lt;/description&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure></li>
<li>修改accumulo-env.sh文件<br> 设置<code>ZOOKEEPER_HOME</code>和<code>HADOOP_PREFIX</code>,亦可在<code>/etc/profile</code>中, <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export HADOOP_PREFIX&#x3D;&#x2F;data&#x2F;hadoop</span><br><span class="line">export HADOOP_HOME&#x3D;$HADOOP_PREFIX</span><br><span class="line">export PATH&#x3D;$HADOOP_HOME&#x2F;bin:$HADOOP_HOME&#x2F;sbin:$PATH</span><br><span class="line">export HADOOP_SSH_OPTS&#x3D;&quot;-p 36000&quot;</span><br><span class="line">export ZOOKEEPER_HOME&#x3D;&#x2F;data&#x2F;zookeeper-3.4.14</span><br></pre></td></tr></table></figure>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/accumulo init</span><br></pre></td></tr></table></figure>
此时设置你的<code>实例名</code>和<code>root密码</code><h3 id="设置多个节点"><a href="#设置多个节点" class="headerlink" title="设置多个节点"></a>设置多个节点</h3><a id="more"></a></li>
<li>设置masters<br> 设置其中一个节点为master节点。 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi ./conf/masters</span><br><span class="line"></span><br><span class="line">10.0.3.201</span><br></pre></td></tr></table></figure></li>
<li>设置gc<br> 设置其中一个节点为gc节点。 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi ./conf/gc</span><br><span class="line"></span><br><span class="line">10.0.3.201</span><br></pre></td></tr></table></figure></li>
<li>设置monitor<br> 运行Accumulo监视web服务器的节点。 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi ./conf/monitor</span><br><span class="line"></span><br><span class="line">10.0.3.201</span><br></pre></td></tr></table></figure></li>
<li>设置slaves<br> 列出该文件中平板服务器应该运行的所有节点。 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi ./conf/slaves</span><br><span class="line"></span><br><span class="line">10.0.3.201</span><br><span class="line">10.0.3.202</span><br><span class="line">10.0.3.203</span><br></pre></td></tr></table></figure></li>
<li>设置tracers<br> 可选功能。可以指定零个或多个节点。 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi ./conf/tracers</span><br><span class="line"></span><br><span class="line">10.0.3.201</span><br><span class="line">10.0.3.202</span><br><span class="line">10.0.3.203</span><br></pre></td></tr></table></figure>
<h3 id="启动Accumulo"><a href="#启动Accumulo" class="headerlink" title="启动Accumulo"></a>启动Accumulo</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动Accumulo</span></span><br><span class="line">./bin/start-all.sh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止Accumulo</span></span><br><span class="line">./bin/stop-all.sh</span><br></pre></td></tr></table></figure>
使用浏览器上输入<code>http://localhost:9995/</code>便可查看Accumulo monitor页面。</li>
</ol>
]]></content>
      <categories>
        <category>BigData</category>
      </categories>
      <tags>
        <tag>BigData</tag>
      </tags>
  </entry>
  <entry>
    <title>redis安装和部署</title>
    <url>/bigdata/install_redis/</url>
    <content><![CDATA[<!-- TOC -->

<ul>
<li><a href="#redis%E5%AE%89%E8%A3%85%E5%92%8C%E9%83%A8%E7%BD%B2">redis安装和部署</a><ul>
<li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li>
<li><a href="#%E5%8D%95%E6%9C%BA%E5%AE%89%E8%A3%85">单机安装</a></li>
<li><a href="#%E5%90%AF%E5%8A%A8%E5%92%8C%E5%85%B3%E9%97%AD">启动和关闭</a></li>
<li><a href="#%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85">集群安装</a><ul>
<li><a href="#%E9%9B%86%E7%BE%A4%E7%9A%84%E6%A6%82%E5%BF%B5">集群的概念</a><ul>
<li><a href="#%E4%BB%8B%E7%BB%8D">介绍</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87">数据分片</a></li>
<li><a href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%9E%8B">主从复制模型</a></li>
</ul>
</li>
<li><a href="#redis%E4%B8%80%E8%87%B4%E6%80%A7%E4%BF%9D%E8%AF%81">Redis一致性保证</a></li>
<li><a href="#%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA">集群搭建</a></li>
<li><a href="#%E5%AE%89%E8%A3%85%E5%92%8C%E5%90%AF%E5%8A%A8redis%E9%9B%86%E7%BE%A4">安装和启动Redis集群</a></li>
</ul>
</li>
<li><a href="#redis%E9%9B%86%E7%BE%A4%E7%9A%84%E4%BD%BF%E7%94%A8">Redis集群的使用</a><ul>
<li><a href="#%E8%BF%9E%E6%8E%A5%E9%9B%86%E7%BE%A4">连接集群</a></li>
<li><a href="#%E9%9B%86%E7%BE%A4%E4%B8%AD%E5%8A%A0%E5%85%A5%E6%96%B0%E7%9A%84%E4%B8%BB%E8%8A%82%E7%82%B9">集群中加入新的主节点</a></li>
<li><a href="#%E6%B5%8B%E8%AF%95%E9%9B%86%E7%BE%A4%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%E6%8C%82%E6%8E%89">测试集群中的节点挂掉</a></li>
</ul>
</li>
<li><a href="#%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94">集群方案对比</a><ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84">基本架构</a></li>
<li><a href="#%E6%B0%B4%E5%B9%B3%E6%89%A9%E5%AE%B9">水平扩容</a></li>
<li><a href="#%E4%B8%BB%E4%BB%8E%E5%A4%87%E4%BB%BD">主从备份</a><ul>
<li><a href="#%E4%B8%BB%E4%BB%8E%E5%A4%87%E4%BB%BD%E6%98%AF%E5%90%A6%E5%BF%85%E9%A1%BB">主从备份是否必须</a></li>
<li><a href="#%E4%B8%BB%E4%BB%8E%E5%A4%87%E4%BB%BD%E6%96%B9%E6%A1%88">主从备份方案</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h2 id="redis安装和部署"><a href="#redis安装和部署" class="headerlink" title="redis安装和部署"></a>redis安装和部署</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>Redis</strong>是我们目前大规模使用的缓存中间件，由于它强大高效而又便捷的功能，得到了广泛的使用。单节点的Redis已经就达到了很高的性能，为了提高可用性我们可以使用Redis集群。</p>
<h3 id="单机安装"><a href="#单机安装" class="headerlink" title="单机安装"></a>单机安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-5.0.5.tar.gz</span><br><span class="line">tar -zxvf redis-5.0.5.tar.gz</span><br><span class="line">cd redis-5.0.5</span><br><span class="line">make </span><br><span class="line">make test</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<h3 id="启动和关闭"><a href="#启动和关闭" class="headerlink" title="启动和关闭"></a>启动和关闭</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-server &amp;</span><br></pre></td></tr></table></figure>
<h3 id="集群安装"><a href="#集群安装" class="headerlink" title="集群安装"></a>集群安装</h3><h4 id="集群的概念"><a href="#集群的概念" class="headerlink" title="集群的概念"></a>集群的概念</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p><strong>Redis集群</strong>是一个可以在多个Redis节点之间进行数据共享的设施（installation）。</p>
<p><strong>Redis集群</strong>不支持那些需要同时处理多个键的Redis命令， 因为执行这些命令需要在多个Redis节点之间移动数据， 并且在高负载的情况下， 这些命令将降低Redis集群的性能，并导致不可预测的错误。</p>
<p><strong>Redis集群</strong>通过分区（partition）来提供一定程度的可用性（availability）：即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。</p>
<p><strong>Redis集群</strong>提供了以下两个好处：</p>
<ul>
<li>将数据自动切分（split）到多个节点的能力。</li>
<li>当集群中的一部分节点失效或者无法进行通讯时， 仍然可以继续处理命令请求的能力。<h5 id="数据分片"><a href="#数据分片" class="headerlink" title="数据分片"></a>数据分片</h5></li>
<li>*Redis集群**使用数据分片（sharding）而非一致性哈希（consistency hashing）来实现：一个Redis集群包含16384个哈希槽（hash slot），数据库中的每个键都属于这16384个哈希槽的其中一个，集群使用公式<code>CRC16(key) % 16384</code>来计算键key属于哪个槽， 其中CRC16(key)语句用于计算键key的CRC16校验和。<h5 id="主从复制模型"><a href="#主从复制模型" class="headerlink" title="主从复制模型"></a>主从复制模型</h5>为了使得集群在一部分节点下线或者无法与集群的大多数（majority）节点进行通讯的情况下， 仍然可以正常运作， Redis 集群对节点使用了主从复制功能： 集群中的每个节点都有 1 个至 N 个复制品（replica）， 其中一个复制品为主节点（master）， 而其余的 N-1 个复制品为从节点（slave）。<h4 id="Redis一致性保证"><a href="#Redis一致性保证" class="headerlink" title="Redis一致性保证"></a>Redis一致性保证</h4>Redis并不能保证数据的强一致性. 这意味这在实际中集群在特定的条件下可能会丢失写操作：第一个原因是因为集群是用了异步复制. 写操作过程:</li>
<li>客户端向主节点B写入一条命令.</li>
<li>主节点B向客户端回复命令状态.</li>
<li>主节点将写操作复制给他得从节点B1,B2和B3</li>
</ul>
<p>主节点对命令的复制工作发生在返回命令回复之后，因为如果每次处理命令请求都需要等待复制操作完成的话，那么主节点处理命令请求的速度将极大地降低 —— 我们必须在性能和一致性之间做出权衡。注意：Redis集群可能会在将来提供同步写的方法。 Redis集群另外一种可能会丢失命令的情况是集群出现了网络分区，并且一个客户端与至少包括一个主节点在内的少数实例被孤立。</p>
<h4 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h4><a id="more"></a>
<p>要让集群正常工作至少需要3个主节点，在这里我们要创建3个redis节点，其中一个为主节点，两个为从节点，对应的redis节点的ip和端口对应关系如下（为了简单演示都在同一台机器上面）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:7000</span><br><span class="line"></span><br><span class="line">127.0.0.1:7001</span><br><span class="line"></span><br><span class="line">127.0.0.1:7002</span><br></pre></td></tr></table></figure>
<h4 id="安装和启动Redis集群"><a href="#安装和启动Redis集群" class="headerlink" title="安装和启动Redis集群"></a>安装和启动Redis集群</h4><ol>
<li>创建目录 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir redis_cluster</span><br><span class="line">cd redis_cluster</span><br><span class="line">mkdir 7000 7001 7002 7003 7004 7005</span><br></pre></td></tr></table></figure></li>
<li>复制和修改配置文件<br> 将redis目录下的配置文件复制到对应端口文件夹下,6个文件夹都要复制一份 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp ~/Downloads/redis-5.0.5/redis.conf ./7000</span><br></pre></td></tr></table></figure>
 修改配置文件<code>redis.conf</code>，将下面的选项修改 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">port 7000</span><br><span class="line">daemonize yes</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes-7000.conf</span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">appendonly yes</span><br><span class="line">appendfilename &quot;appendonly-7000.aof&quot;</span><br><span class="line">dbfilename dump-7000.rdb</span><br></pre></td></tr></table></figure>
 两个配置文件安装对应的端口分别修改配置文件</li>
<li>创建启动脚本<br> 在<code>./redis_cluster</code>目录下创建一个start_cluster.sh <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">redis-server ./7000/redis.conf</span><br><span class="line">redis-server ./7001/redis.conf</span><br><span class="line">redis-server ./7002/redis.conf</span><br></pre></td></tr></table></figure>
 这个时候我们查看一下进程看启动情况 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -ef | grep redis</span><br></pre></td></tr></table></figure></li>
<li>开启集群 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 \</span><br><span class="line">127.0.0.1:7002 127.0.0.1:7003 </span><br><span class="line"># --cluster-replicas 1 需要六个节点</span><br></pre></td></tr></table></figure>
<h3 id="Redis集群的使用"><a href="#Redis集群的使用" class="headerlink" title="Redis集群的使用"></a>Redis集群的使用</h3><h4 id="连接集群"><a href="#连接集群" class="headerlink" title="连接集群"></a>连接集群</h4>这里我们使用reids-cli连接集群，使用时加上-c参数，就可以连接到集群<br>连接7000端口的节点<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -c -p 7000</span><br><span class="line">127.0.0.1:7000&gt; set name redis-test</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> Redirected to slot [5798] located at 127.0.0.1:7001</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:7001&gt; get name</span><br><span class="line">&quot;redis-test&quot;</span><br><span class="line">127.0.0.1:7001&gt;</span><br></pre></td></tr></table></figure>
前面的理论知识我们知道了，分配key的时候，它会使用CRC16算法，这里将keyname分配到了7001节点上<br><code>Redirected to slot [5798] located at 127.0.0.1:7001</code><br>redis cluster采用的方式很直接，它直接跳转到7001节点了，而不是还在自身的7000节点。</li>
</ol>
<p>好，现在我们连接7002这个从节点进入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -c -p 7002</span><br><span class="line">127.0.0.1:7002&gt; get name</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> Redirected to slot [5798] located at 127.0.0.1:7001</span></span><br><span class="line">&quot;redis-test&quot;</span><br><span class="line">127.0.0.1:7001&gt; set age 20</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> Redirected to slot [741] located at 127.0.0.1:7000</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:7000&gt; set message helloworld</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> Redirected to slot [11537] located at 127.0.0.1:7002</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:7002&gt; set height 175</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> Redirected to slot [8223] located at 127.0.0.1:7001</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:7001&gt;</span><br></pre></td></tr></table></figure>
<p>我们发现数据会在7000-7002这3个节点之间来回跳转</p>
<h4 id="集群中加入新的主节点"><a href="#集群中加入新的主节点" class="headerlink" title="集群中加入新的主节点"></a>集群中加入新的主节点</h4><p>这里在cluster目录下再新建一个7003并修改对应的配置文件，然后启动这个这个redis进程<br>然后再使用redis-cli的add node指令加入节点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster add-node 127.0.0.1:7003 127.0.0.1:7000 [ --cluster-slave]</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Adding node 127.0.0.1:7003 to cluster 127.0.0.1:7000</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7000)</span></span><br><span class="line">M: b48e9199061ca71057630db3cc0b048c0b0f40a6 127.0.0.1:7000</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">M: d46f8b8268cbd5792d3d0663f93ef003373725c9 127.0.0.1:7001</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">M: 3c61bb75339a6b45f5e72b8f41df0459faf3a78a 127.0.0.1:7002</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Check <span class="keyword">for</span> open slots...</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Check slots coverage...</span></span><br><span class="line">[OK] All 16384 slots covered.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Send CLUSTER MEET to node 127.0.0.1:7003 to make it join the cluster.</span></span><br><span class="line">[OK] New node added correctly.</span><br></pre></td></tr></table></figure>
<h4 id="测试集群中的节点挂掉"><a href="#测试集群中的节点挂掉" class="headerlink" title="测试集群中的节点挂掉"></a>测试集群中的节点挂掉</h4><p>上面我们建立了一个集群，4个主节点和1个从节点，7000-7003负责存取数据，7004的数据同步到自己的节点上来。我们现在来模拟一下一台matser服务器宕机的情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  redis_cluster ps -ef | grep redis</span><br><span class="line">  501  2342     1   0  8:45PM ??         0:08.25 redis-server 127.0.0.1:7000 [cluster]</span><br><span class="line">  501  2344     1   0  8:45PM ??         0:08.21 redis-server 127.0.0.1:7001 [cluster]</span><br><span class="line">  501  2346     1   0  8:45PM ??         0:08.12 redis-server 127.0.0.1:7002 [cluster]</span><br><span class="line">  501  2847     1   0  9:08PM ??         0:03.03 redis-server 127.0.0.1:7003 [cluster]</span><br><span class="line">  501  3021     1   0  9:17PM ??         0:01.05 redis-server 127.0.0.1:7004 [cluster]</span><br><span class="line">  501  3133  1478   0  9:22PM ttys001    0:00.00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn redis</span><br><span class="line">➜  redis_cluster kill -9 2342</span><br><span class="line">➜  redis_cluster redis-cli check 127.0.0.1:7001</span><br><span class="line">Could not connect to Redis at 127.0.0.1:6379: Connection refused</span><br><span class="line">➜  redis_cluster redis-cli --cluster check 127.0.0.1:7001</span><br><span class="line">Could not connect to Redis at 127.0.0.1:7000: Connection refused</span><br><span class="line">127.0.0.1:7001 (d46f8b82...) -&gt; 2 keys | 5462 slots | 0 slaves.</span><br><span class="line">127.0.0.1:7002 (3c61bb75...) -&gt; 1 keys | 5461 slots | 0 slaves.</span><br><span class="line">127.0.0.1:7003 (4384138d...) -&gt; 0 keys | 0 slots | 0 slaves.</span><br><span class="line">127.0.0.1:7004 (dc276668...) -&gt; 1 keys | 5461 slots | 0 slaves.</span><br><span class="line">[OK] 4 keys in 4 masters.</span><br><span class="line">0.00 keys per slot on average.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7001)</span></span><br><span class="line">M: d46f8b8268cbd5792d3d0663f93ef003373725c9 127.0.0.1:7001</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">M: 3c61bb75339a6b45f5e72b8f41df0459faf3a78a 127.0.0.1:7002</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">M: 4384138dfde44501c49e309231929cb301f8b02d 127.0.0.1:7003</span><br><span class="line">   slots: (0 slots) master</span><br><span class="line">M: dc2766687e4c1125aabfd3193062f40840e0f287 127.0.0.1:7004</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Check <span class="keyword">for</span> open slots...</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Check slots coverage...</span></span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster reshard &lt;host&gt;:&lt;port&gt; --cluster-from &lt;node-id&gt; --cluster-to &lt;node-id&gt; --cluster-slots &lt;number of slots&gt; --cluster-yes</span><br></pre></td></tr></table></figure>
<h3 id="集群方案对比"><a href="#集群方案对比" class="headerlink" title="集群方案对比"></a>集群方案对比</h3><p><strong>Redis集群的解决方案</strong><br>| 方案 | 贡献者 | 是否官方Redis实现 | 编程语言 |<br>| — | —– | ————— | ——- |<br>| Twemproxy | Twitter | 是 | C |<br>| Redis Cluster | Redis官方 | 是 | C |<br>| Codis | 豌豆荚 | 否 | Go+C |</p>
<h4 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h4><ol>
<li>Twemproxy<br> <strong>架构图</strong><br> <strong>数据分片算法</strong><ul>
<li>采用一致性哈希算法，以KETAMA为例</li>
</ul>
</li>
<li>Redis Cluster<br> <strong>架构图</strong><br> <strong>数据分片算法</strong><ul>
<li>Key空间被划分为16384个区间,每个Master节点负责一部分区间。 </li>
</ul>
</li>
<li>Codis<br> <strong>架构图</strong><br> <strong>数据分片算法</strong><ul>
<li>Key空间被划分为1024个区间, 对于每个key来说, 通过以下公式确定所属的 Slot Id : SlotId = crc32(key) % 1024</li>
<li>每一个slot都会有一个特定的server group id来表示这个slot的数据由哪个server group来提供</li>
</ul>
</li>
</ol>
<h4 id="水平扩容"><a href="#水平扩容" class="headerlink" title="水平扩容"></a>水平扩容</h4><ol>
<li>Twemproxy <ul>
<li>不支持运行时水平扩容，需要重启。</li>
<li>根据一致性哈希算法进行数据重新分片。</li>
</ul>
</li>
<li>Redis Cluster<ul>
<li>支持通过运行时增加Master节点来水平扩容，提升存储容量，尽力降低命中率波动</li>
<li>存在节点A，需要迁出其中的部分Key区间。新增节点B，接收由节点A迁出的Key区间。</li>
<li>相应Key区间的请求首先还是会发送给A节点：如果请求为新建Key则直接重定向到B节点；如果请求不是新建Key且A节点存储有对应的Key则直接作出响应，否则重定向到B节点</li>
<li>同时Cluster会调用实用工具redis-cli向A节点发送MIGRATE命令，把迁移区间内的所有Key原子的迁移到B节点：同时锁住A、B节点=》在A节点删除Key=》在B节点新建Key=》解锁</li>
<li>运行时动态迁移大尺寸键值可能造成响应时延</li>
</ul>
</li>
<li>Codis<ul>
<li>支持运行时水平扩容</li>
<li>底层基于Codis Server特殊实现原子的数据迁移指令</li>
</ul>
</li>
</ol>
<h4 id="主从备份"><a href="#主从备份" class="headerlink" title="主从备份"></a>主从备份</h4><h5 id="主从备份是否必须"><a href="#主从备份是否必须" class="headerlink" title="主从备份是否必须"></a>主从备份是否必须</h5><ol>
<li>Twemproxy<ul>
<li>没有数据复制不影响可用节点顶替故障节点</li>
<li>故障发生时，没有数据复制的故障节点的Key会全部丢失</li>
</ul>
</li>
<li>Redis Cluster<ul>
<li>没有主从备份的节点一旦故障，将导致整个集群失败：无法写入/读取任何Key；无法进行数据重新分片。 </li>
</ul>
</li>
<li>Codis<ul>
<li>若出现故障，需要手动配置节点，进行故障转移。</li>
<li>如果没有进行故障转移，只故障节点负责的slots 会失败</li>
</ul>
</li>
</ol>
<h5 id="主从备份方案"><a href="#主从备份方案" class="headerlink" title="主从备份方案"></a>主从备份方案</h5><p>Twemproxy本身不支持出从备份，和Redis Cluster一样，需要引入Redis本身的主备复制功能。 </p>
<ul>
<li>可以设置1主1备或者1主多备</li>
<li>当Slave节点接入Cluster时，就会向配置的Master节点发送SYNC命令。断开重连时，也会再次发送SYNC命令</li>
<li>此后Master将启动后台存盘进程，同时收集所有接收到的用于修改数据集的命令，在后台进程执行完毕后，Master将传送整个数据库文件到Slave，以完成一次完全同步。而Slave服务器在接收到数据库文件数据之后将其存盘并加载到内存中。此后，Master继续将所有已经收集到的修改命令，和新的修改命令依次传送给Slaves，Slave将在本次执行这些数据修改命令，从而达到最终的数据同步。</li>
<li>Redis的数据复制是异步的，无论在Master端还是Slave端都不会阻塞。</li>
<li>Slave会周期性确认收到的备份数据</li>
</ul>
]]></content>
      <categories>
        <category>BigData</category>
      </categories>
      <tags>
        <tag>BigData</tag>
      </tags>
  </entry>
  <entry>
    <title>有效的括号字符串</title>
    <url>/leetcode/leetcode_valid_parenthesis_string/</url>
    <content><![CDATA[<h2 id="有效的括号字符串"><a href="#有效的括号字符串" class="headerlink" title="有效的括号字符串"></a>有效的括号字符串</h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给定一个只包含三种字符的字符串: <code>(</code>, <code>)</code>和<code>*</code>，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：</p>
<ol>
<li>任何左括号<code>(</code>必须有相应的右括号<code>)</code>。</li>
<li>任何右括号<code>)</code>必须有相应的左括号<code>(</code>。</li>
<li>左括号<code>(</code>必须在对应的右括号之前<code>)</code>。</li>
<li>可以被视为单个右括号<code>)</code>，或单个左括号<code>(</code>，或一个空字符串。</li>
<li>一个空字符串也被视为有效字符串。</li>
</ol>
<p><strong>示例 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;()&quot;</span></span><br><span class="line">输出: <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;(*)&quot;</span></span><br><span class="line">输出: <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;(*))&quot;</span></span><br><span class="line">输出: <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 字符串大小将在 [1，100] 范围内。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkValidString</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; bool:</span>        </span><br><span class="line">        stack = <span class="built_in">list</span>()</span><br><span class="line">        stars = <span class="built_in">list</span>()</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> index &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            tmp = s[index]</span><br><span class="line">            <span class="keyword">if</span> tmp == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                stack.append(&#123;tmp: index&#125;)</span><br><span class="line">            <span class="keyword">elif</span> tmp == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                stars.append(&#123;tmp: index&#125;)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span>:</span><br><span class="line">                    stack.pop()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">len</span>(stars) &gt; <span class="number">0</span>:</span><br><span class="line">                        stars.pop()</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(stars) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> (stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>][<span class="string">&#x27;(&#x27;</span>] &gt; stars[<span class="built_in">len</span>(stars) - <span class="number">1</span>][<span class="string">&#x27;*&#x27;</span>]):  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            stack.pop()</span><br><span class="line">            stars.pop()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(stack) == <span class="number">0</span></span><br></pre></td></tr></table></figure>


<p><strong>说明：</strong> 如果您有更好的解决方案或者本人写的有什么问题，请多多指教！</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>两数之和</title>
    <url>/leetcode/leetcode_two_sum/</url>
    <content><![CDATA[<h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给定一个整数数组<strong>nums</strong>和一个目标值<strong>target</strong>，请你在该数组中找出和为目标值的那<strong>两整数</strong>，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li><p>暴力法<br>遍历每个元素x，并查找是否存在一个值与target - x相等的目标元素。</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[j] == target:</span><br><span class="line">                    <span class="keyword">return</span> [i, j]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p> <strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：<code>O(n^2)</code>， 对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费<code>O(n)</code>的时间。因此时间复杂度为<code>O(n^2)</code>。</li>
<li>空间复杂度：<code>O(1)</code>。 </li>
</ul>
</li>
<li><p>字典一次完成<br>事实证明，我们可以一次完成。在进行迭代并将元素插入到字典中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">    res = <span class="built_in">dict</span>()</span><br><span class="line">    <span class="keyword">for</span> index, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">        another_num = target - num</span><br><span class="line">        <span class="keyword">if</span> another_num <span class="keyword">in</span> res:</span><br><span class="line">            <span class="keyword">return</span> [res[another_num], index]</span><br><span class="line">        res[num] = index</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p> <strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：<code>O(n)</code>， 我们只遍历了包含有n个元素的列表一次。在表中进行的每次查找只花费 <code>O(1)</code>的时间。</li>
<li>空间复杂度：<code>O(n)</code>， 所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储n个元素。</li>
</ul>
</li>
</ol>
<p><strong>说明：</strong> 如果您有更好的解决方案或者本人写的有什么问题，请多多指教！</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>无重复字符的最长子串</title>
    <url>/leetcode/leetcode_longest_substring/</url>
    <content><![CDATA[<h2 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给定一个字符串，请你找出其中不含有重复字符的<strong>最长子串</strong>的长度。</p>
<a id="more"></a>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3:"></a>示例 3:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>本题本人用Python和C++两种方式进行实现，具体实现方式如下：</p>
<ol>
<li>Python执行方案： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        tmp = <span class="number">0</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">in</span> d <span class="keyword">and</span> d[s[i]] &gt;= start:</span><br><span class="line">                start = d[s[i]] + <span class="number">1</span></span><br><span class="line">            tmp = i - start + <span class="number">1</span></span><br><span class="line">            d[s[i]] = i</span><br><span class="line">            res = <span class="built_in">max</span>(res, tmp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li>
<li>C++执行方案： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt; cache;</span><br><span class="line">        <span class="keyword">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; s.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cache.find(s[index]) == cache.end()) &#123;</span><br><span class="line">                cache.insert(s[index++]);</span><br><span class="line">                maxlen = max(maxlen, (<span class="keyword">int</span>)cache.size());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cache.erase(s[left++]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>说明：</strong> 如果您有更好的解决方案或者本人写的有什么问题，请多多指教！</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>求100以内的质数</title>
    <url>/leetcode/leetcode_prime/</url>
    <content><![CDATA[<h2 id="求100以内的质数"><a href="#求100以内的质数" class="headerlink" title="求100以内的质数"></a>求100以内的质数</h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>输出100以内的所有素数，素数之间以一个空格区分<br><strong>分析：</strong><br>首先了解下素数：素数（prime number）又称质数，有无限个。一个大于1的自然数，除了1和它本身外，不能被整除以其他自然数（质数），换句话说就是该数除了1和它本身以外不再有其他的因数；否则称为合数。最小的质数是2。</p>
<a id="more"></a>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li>使用试除法，看看比n小的数中有没有n的因数，如果没有，那么该数就是素数。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">output_all_prime</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: list</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">101</span>):</span><br><span class="line">            flag = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, i):</span><br><span class="line">                <span class="keyword">if</span> i % j == <span class="number">0</span>:</span><br><span class="line">                    flag = <span class="literal">False</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                res.append(i)</span><br></pre></td></tr></table></figure></li>
<li>升级版试除法，我们没必要对小于n的所有整数进行试除法，只要试除2到根号n就行了。因为因数都是成对出现的。成对的因数，其中一个必然小于等于根号n，而另一个一定大于根号n。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">output_all_prime</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: list</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">101</span>):</span><br><span class="line">            flag = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(math.sqrt(i)) + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i % j == <span class="number">0</span>:</span><br><span class="line">                    flag = <span class="literal">False</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                res.append(i)</span><br></pre></td></tr></table></figure></li>
<li>更pythonic的做法： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">output_all_prime</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: list</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        print(<span class="string">&#x27; &#x27;</span>.join([<span class="string">&#x27;%s&#x27;</span> % x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">101</span>) <span class="keyword">if</span> <span class="keyword">not</span> [y <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(math.sqrt(x) + <span class="number">1</span>)) <span class="keyword">if</span> x % y == <span class="number">0</span>]]))</span><br><span class="line">        <span class="comment">#或者</span></span><br><span class="line">        print(<span class="string">&#x27; &#x27;</span>.join([<span class="built_in">str</span>(i) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">101</span>) <span class="keyword">if</span> <span class="keyword">not</span> [y <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(math.sqrt(x) + <span class="number">1</span>)) <span class="keyword">if</span> x % y == <span class="number">0</span>]]))</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>说明：</strong> 如果您有更好的解决方案或者本人写的有什么问题，请多多指教！</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>整数反转</title>
    <url>/leetcode/leetcode_reverse_integer/</url>
    <content><![CDATA[<h2 id="整数反转"><a href="#整数反转" class="headerlink" title="整数反转"></a>整数反转</h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给出一个32位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>
<a id="more"></a>
<h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 123</span><br><span class="line">输出: 321</span><br></pre></td></tr></table></figure>
<h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: -123</span><br><span class="line">输出: -321</span><br></pre></td></tr></table></figure>
<h4 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 120</span><br><span class="line">输出: 21</span><br></pre></td></tr></table></figure>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h4><p>假设我们的环境只能存储得下32位的有符号整数，则其数值范围为 [-2147483648, 2147483647]。请根据这个假设，如果反转后整数溢出那么就返回0。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>具体实现方式如下：</p>
<ol>
<li>Python执行方案： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span>  -<span class="number">10</span> &lt; x &lt; <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">        rev_x = <span class="built_in">str</span>(x)</span><br><span class="line">        <span class="keyword">if</span> rev_x[<span class="number">0</span>] <span class="keyword">is</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            rev_x = rev_x[<span class="number">1</span>:][::-<span class="number">1</span>]</span><br><span class="line">            rev_x = -<span class="built_in">int</span>(rev_x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            rev_x = rev_x[::-<span class="number">1</span>]</span><br><span class="line">            rev_x = <span class="built_in">int</span>(rev_x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rev_x <span class="keyword">if</span> -(<span class="number">2</span> ** <span class="number">31</span>) &lt; rev_x &lt; (<span class="number">2</span> ** <span class="number">31</span>) - <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>说明：</strong> 如果您有更好的解决方案或者本人写的有什么问题，请多多指教！</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>你必须知道深度学习术语</title>
    <url>/machine_learning/deep_learning_terminology/</url>
    <content><![CDATA[<h2 id="你必须知道深度学习术语"><a href="#你必须知道深度学习术语" class="headerlink" title="你必须知道深度学习术语"></a>你必须知道深度学习术语</h2><h3 id="1-神经元"><a href="#1-神经元" class="headerlink" title="1. 神经元"></a>1. 神经元</h3><p>我们可以说，我们使用神经元来形成大脑的基本元素。也有助于形成神经网络的基本结构。当我们得到新信息时。我们开始生成一个输出。</p>
<p><img src="deep_learning_terminology/neuron.png" alt="Neuron"></p>
<p>同样，我们也要处理神经网络的情况。一旦神经元得到输入，我们就必须开始这个过程。此外，在处理之后生成输出。此外，我们必须发送神经元，这有助于进一步处理。或者，我们可以把它看作最终的输出。</p>
<h3 id="2-循环神经元-Recurrent-Neuron"><a href="#2-循环神经元-Recurrent-Neuron" class="headerlink" title="2. 循环神经元(Recurrent Neuron)"></a>2. 循环神经元(Recurrent Neuron)</h3><p>它是<a href="https://data-flair.training/blogs/deep-learning-tutorial/">深度学习</a>术语中最好的术语之一。基本上，这个输出被发送回神经元以获取t时间戳。从下图可以看出，我们可以说输出作为输入返回了t次。同样，我们必须把不同的神经元连接起来，它们看起来就像一个展开的神经元。尽管如此，重要的是它为我们提供了一个更一般化的输出。<br><img src="deep_learning_terminology/recurrent_neuron.png" alt="Recurrent Neuron"></p>
<h3 id="3-神经网络-Neural-Network"><a href="#3-神经网络-Neural-Network" class="headerlink" title="3. 神经网络(Neural Network)"></a>3. 神经网络(Neural Network)</h3><a id="more"></a>
<p>神经网络是深度学习的基础。它的目标是找到一个未知函数的近似值。它是相互连接的神经元的组合。这些神经元有权重。此外，在网络训练期间需要根据错误更新偏差。激活函数对线性组合进行非线性变换。因此，生成输出。被激活神经元的组合给出了输出。</p>
<h3 id="4-循环神经网络-Recurrent-Neural-Network"><a href="#4-循环神经网络-Recurrent-Neural-Network" class="headerlink" title="4. 循环神经网络(Recurrent Neural Network)"></a>4. 循环神经网络(Recurrent Neural Network)</h3><p>我们使用一个递归神经网络，特别是对序列数据。在这里，我们使用前面的输出来预测下一个输出。同样，在本例中，循环内部有一个网络。在一个隐藏的神经元中，循环具有存储信息的能力。因为它存储以前的单词来预测输出。</p>
<p>同样，我们必须为t时间戳发送一个隐藏层的输出。此外，你可以看到展开的神经元是这样的。一旦神经元完成所有的时间戳，它就进入下一层。因此，我们可以说输出更加一般化。虽然，之前获取的信息会在很长一段时间后保留。</p>
<p>此外，为了更新未展开网络的权值，我们必须再次传播误差。因此，称为时间反向传播(BPTT)。</p>
<h3 id="5-梯度消失问题-Vanishing-Gradient-Problem"><a href="#5-梯度消失问题-Vanishing-Gradient-Problem" class="headerlink" title="5. 梯度消失问题(Vanishing Gradient Problem)"></a>5. 梯度消失问题(Vanishing Gradient Problem)</h3><p>它是深度学习术语中最好的术语之一。当激活函数非常小时，就会出现这个问题。在反向传播时，我们必须用低梯度乘权。尽管如此，如果它们深入到网络深处，就会变得很小，而且会消失。由于这个原因，神经网络忘记了长期依赖。同时，这也成为了一个神经网络的问题。因此，依赖对网络的记忆非常重要。</p>
<p>我们使用激活函数来解决像ReLu这样没有小梯度的问题。</p>
<h3 id="6-梯度爆炸性问题-Exploding-Gradient-Problem"><a href="#6-梯度爆炸性问题-Exploding-Gradient-Problem" class="headerlink" title="6. 梯度爆炸性问题(Exploding Gradient Problem)"></a>6. 梯度爆炸性问题(Exploding Gradient Problem)</h3><p>我们可以说这和消失梯度问题是相反的。不同的是激活函数太大。而且，它使特定节点的权重非常高。不过，我们可以通过剪切梯度来求解。这样它就不会超过某个值。</p>
<h3 id="7-池化-Pooling"><a href="#7-池化-Pooling" class="headerlink" title="7. 池化(Pooling)"></a>7. 池化(Pooling)</h3><p>它是深度学习术语中最好的术语之一。我们可以在卷积层之间引入池化层。基本上，使用这个来减少参数的数量。尽管如此,防止过度学习。虽然，池的大小最常见的类型是过滤层的大小(2,2)使用MAX操作。更进一步，我们可以说它会做的是，它会取原始图像中每个4*4矩阵的最大值。<br><img src="deep_learning_terminology/pooling.png" alt="Pooling"></p>
<p>我们也可以使用其他池的应用程序，如平均池等。</p>
<h3 id="8-填充-Padding"><a href="#8-填充-Padding" class="headerlink" title="8. 填充(Padding)"></a>8. 填充(Padding)</h3><p>在这个过程中，我们必须在图像上添加一个额外的0层。因此，输出图像的大小与输入图像的大小相同。因此，称为填充。如果图像的像素是实际的或有效的，我们可以说它是有效的填充。</p>
<p><img src="deep_learning_terminology/padding.jpg" alt="Padding"></p>
<h3 id="9-数据增强-Data-Augmentation"><a href="#9-数据增强-Data-Augmentation" class="headerlink" title="9. 数据增强(Data Augmentation)"></a>9. 数据增强(Data Augmentation)</h3><p>它是指从给定的数据中添加新的数据，这些数据可能被证明对预测是有益的。</p>
<p><strong>例如:</strong> 假设我们有一个数字“9”。我们也可以改变它的认知。但如果它在旋转或倾斜。因此，旋转有助于提高模型的精度。尽管如此，我们通过旋转来提高数据的质量。因此，需要数据扩充。</p>
<p><img src="deep_learning_terminology/data_augmentation.png" alt="Data Augmentation"></p>
<h3 id="10-分类器-Softmax"><a href="#10-分类器-Softmax" class="headerlink" title="10. 分类器(Softmax)"></a>10. 分类器(Softmax)</h3><p>我们使用输出层中的softmax激活函数来处理分类问题。它就像一个sigmoid函数。另外，不同之处在于输出是标准化的，总和为1。</p>
<p>它类似于sigmoid函数，唯一的区别是输出是标准化的，加起来等于1。如果我们有一个二进制输出，sigmoid函数就会工作。但我们也有一个多类分类的问题。在这个过程中，softmax可以很容易地为每个类分配值。同样，这也可以解释为概率。</p>
<p>这样看很容易——假设你要识别一个6，它看起来也有点像8。函数将为每个数字赋值，如下所示。我们可以很容易地看到，最高的概率被分配到6，其次是最高的分配到8，以此类推……</p>
<p><img src="deep_learning_terminology/softmax.png" alt="Softmax"></p>
<h3 id="11-输入-输出-隐藏层-Input-layer-Output-layer-Hidden-layer"><a href="#11-输入-输出-隐藏层-Input-layer-Output-layer-Hidden-layer" class="headerlink" title="11. 输入/输出/隐藏层(Input layer/ Output layer / Hidden layer"></a>11. 输入/输出/隐藏层(Input layer/ Output layer / Hidden layer</h3><p>)<br>它是深度学习术语中最好的术语之一。输入层是接收输入的层。而且，它是网络的第一层。输出层是网络的最后一层。这些层是网络的隐藏层。我们使用这些隐藏层对传入的数据执行任务。因此，将生成的输出传递到下一层。尽管这两个层都是可见的，但是中间层是隐藏的。</p>
<p><img src="deep_learning_terminology/input_output_hidden_layer.png" alt="Input layer/ Output layer / Hidden layer"></p>
<h3 id="12-多层感知器-Multi-Layer-perceptron"><a href="#12-多层感知器-Multi-Layer-perceptron" class="headerlink" title="12. 多层感知器(Multi-Layer perceptron)"></a>12. 多层感知器(Multi-Layer perceptron)</h3><p>我们不能用一个神经元来完成高度复杂的任务。因此，我们使用神经元堆栈来生成所需的输出。在最简单的网络中，我们有一个输入层、一个隐藏层和一个输出层。在这里，每一层都有多个神经元。此外，在每一层，所有的神经元都连接到下一层的所有神经元。这些网络是完全连接的网络。</p>
<p><img src="deep_learning_terminology/mlp.png" alt="MLP"></p>
<h3 id="13-权重-Weights"><a href="#13-权重-Weights" class="headerlink" title="13. 权重(Weights)"></a>13. 权重(Weights)</h3><p>一旦输入进入神经元，我们就必须把它乘以权重。</p>
<p><strong>例如:</strong> 如果一个神经元有两个输入，那么我们必须给每个输入分配一个相关的权重。此外，我们必须随机初始化权重。此外，在模型训练过程中，这些权重也在不断更新。虽然，在培训之后，我们必须给输入分配更高的权重。</p>
<p>假设输入为a，然后将权重关联到W1。然后通过节点后，输入变为*W1</p>
<p><img src="deep_learning_terminology/weights.png" alt="Weights"></p>
<h3 id="14-偏差-Bias"><a href="#14-偏差-Bias" class="headerlink" title="14. 偏差(Bias)"></a>14. 偏差(Bias)</h3><p>除了权值，我们还需要加入另一个线性分量，这是偏差。在输入中，我们要加上权重乘法。基本上，我们必须添加偏差来改变权重乘以输入的范围。只要添加了偏差，结果就像*W1+偏差。因此，它是输入变换的一个线性分量。</p>
<h3 id="15-激活函数-Activation-Function"><a href="#15-激活函数-Activation-Function" class="headerlink" title="15. 激活函数(Activation Function)"></a>15. 激活函数(Activation Function)</h3><p><img src="deep_learning_terminology/activation_function.png" alt="Activation Function"></p>
<p>只要我们对输入应用线性分量，就会对它应用非线性函数。这是通过将激活函数应用于线性组合来实现的。因此，它将输入信号转换为输出信号。<br>应用激活函数后的输出将类似于f(a*W1+b)，其中f()是激活函数。<br>在下面的图中，我们有n个输入，从X1到Xn，对应的权重是Wk1到Wkn。我们有一个给定的偏置bk，首先，我们必须将权重乘以它对应的输入。然后把这些和偏置一起加起来。设为u。</p>
<p><code>u =∑w * x + b</code></p>
<p>因此，激活函数需要作用于u即f(u)上，我们从神经元接收到的最终输出为yk = f(u)</p>
<h3 id="16-梯度下降-Gradient-Descent"><a href="#16-梯度下降-Gradient-Descent" class="headerlink" title="16. 梯度下降(Gradient Descent)"></a>16. 梯度下降(Gradient Descent)</h3><p>我们将其作为最小化成本的优化算法。</p>
<p>从数学上讲，要找到一个函数的局部最小值，需要采取与函数梯度负相关的步骤。<br><img src="deep_learning_terminology/gradient_descent.png" alt="Gradient Descent"></p>
<h3 id="17-学习率"><a href="#17-学习率" class="headerlink" title="17. 学习率"></a>17. 学习率</h3><p><img src="deep_learning_terminology/learning_rate.png" alt="Learning Rate"></p>
<p>我们可以说它是每次迭代中代价函数的最小值。此外，在选择学习速度时必须谨慎。因为最优解不应该很大。同样，也不应该低到网络永远收敛。</p>
<h3 id="18-反向传播-Backpropagation"><a href="#18-反向传播-Backpropagation" class="headerlink" title="18. 反向传播(Backpropagation)"></a>18. 反向传播(Backpropagation)</h3><p>当我们想要定义一个神经网络时，我们给节点分配随机的权重和偏差值。同样，当我们收到单个迭代的输出时。因此，我们可以计算网络的误差。</p>
<p>在反向传播过程中，网络的运动是反向的，误差随梯度从外层流向隐层，并对权值进行更新。</p>
<h3 id="19-批次-Batches"><a href="#19-批次-Batches" class="headerlink" title="19. 批次(Batches)"></a>19. 批次(Batches)</h3><p>在神经网络训练中，我们将输入随机分成若干大小相等的块。而不是一次性发送全部输入。此外，经过训练的数据批使模型更加一般化。</p>
<h3 id="20-周期-Epochs"><a href="#20-周期-Epochs" class="headerlink" title="20. 周期(Epochs)"></a>20. 周期(Epochs)</h3><p>我们可以将它定义为一个单一的培训迭代。然后在转发和反向传播中使用批来定义。这意味着1周期是整个输入数据的单次向前和向后传递。</p>
<h3 id="21-丢弃-Dropout"><a href="#21-丢弃-Dropout" class="headerlink" title="21. 丢弃(Dropout)"></a>21. 丢弃(Dropout)</h3><p>Dropout是一种正则化技术，可防止网络过度拟合套。顾名思义，在训练期间，隐藏层中的一定数量的神经元被随机地丢弃。这意味着训练发生在神经网络的不同组合的神经网络的几个架构上。你可以将Dropout视为一种综合技术，然后将多个网络的输出用于产生最终输出。<br><img src="deep_learning_terminology/dropout.jpeg" alt="Dropout"></p>
<h3 id="22-批量归一化-Batch-Normalization"><a href="#22-批量归一化-Batch-Normalization" class="headerlink" title="22. 批量归一化(Batch Normalization)"></a>22. 批量归一化(Batch Normalization)</h3><p>作为一个概念，批量归一化可以被认为是我们在河流中设定为特定检查点的水坝。这样做是为了确保数据的分发与希望获得的下一层相同。当我们训练神经网络时，权重在梯度下降的每个步骤之后都会改变，这会改变数据的形状如何发送到下一层。</p>
<p><img src="deep_learning_terminology/SGD.png" alt="SGD"></p>
<p>但是下一层预期分布类似于之前所看到的分布。 所以我们在将数据发送到下一层之前明确规范化数据。</p>
<p><img src="deep_learning_terminology/SGD_1.png" alt="SGD1"></p>
<p>所以，这都是关于深度学习的术语。希望你喜欢我们的解释。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>因此，我们看到了深度学习术语。这将有助于理解复杂的神经网络和深度学习术语。我们有深入学习术语的图片，可以让你更好地理解这一点。此外，如果您对深度学习术语有任何疑问，请在评论部分提出。</p>
<p><em>原文请看此处：<br><a href="https://medium.com/@rinu.gour123/you-must-know-20-deep-learning-terminologies-d164ff027bac">You Must Know 20 Deep Learning Terminologies</a></em></p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title>十大机器学习算法简介</title>
    <url>/machine_learning/top_10_machine_learning_algorithms/</url>
    <content><![CDATA[<h2 id="十大机器学习算法简介"><a href="#十大机器学习算法简介" class="headerlink" title="十大机器学习算法简介"></a>十大机器学习算法简介</h2><h3 id="1-线性回归-Linear-Regression"><a href="#1-线性回归-Linear-Regression" class="headerlink" title="1. 线性回归(Linear Regression)"></a>1. 线性回归(Linear Regression)</h3><p>线性回归(Linear Regression)可能是统计和机器学习中最著名和最容易理解的算法之一。</p>
<p>预测建模主要关注的是最小化模型的误差，或尽可能做出最准确的预测，而牺牲了可解释性。我们将借用、重用和窃取许多不同领域的算法，包括统计数据，并将它们用于这些目的。</p>
<p>线性回归的表示是一个方程，它通过为称为系数(B)的输入变量寻找特定权重，来描述一条最适合输入变量(x)和输出变量(y)之间关系的直线，如下图所示。<br><img src="top_10_machine_learning_algorithms/linear_regression.jpeg" alt="Linear Regression"><br>例如:y = B0 + B1 * x</p>
<p>我们将在给定输入x的情况下预测y线性回归学习算法的目标是找到系数B0和B1的值。</p>
<p>从数据中学习线性回归模型可以使用不同的技术，如普通最小二乘的线性代数解和梯度下降优化。</p>
<p>线性回归已有200多年的历史，并得到了广泛的研究。使用此技术时，一些好的经验规则是删除非常相似(相关)的变量，并尽可能从数据中删除噪声。这是一种快速、简单的方法，也是一种值得尝试的好算法。</p>
<h3 id="2-逻辑回归-Logistic-Regression"><a href="#2-逻辑回归-Logistic-Regression" class="headerlink" title="2. 逻辑回归(Logistic Regression)"></a>2. 逻辑回归(Logistic Regression)</h3><p>逻辑回归(Logistic Regression)是机器学习从统计学领域借用的另一种技术。它是二进制分类问题(具有两个类值的问题)的首选方法。</p>
<p>逻辑回归类似于线性回归，其目标是找到每个输入变量权重系数的值。与线性回归不同，输出的预测是使用一个称为逻辑函数的非线性函数来转换的。</p>
<p>logistic函数看起来像一个大S，它将把任何值转换成0到1的范围。这很有用，因为我们可以对logistic函数的输出应用一个规则，将值捕捉到0和1(例如，如果小于0.5，则输出1)，并预测一个类值。<br><img src="top_10_machine_learning_algorithms/logistic_regression.jpeg" alt="Logistic Regression"></p>
<p>由于模型的学习方式，逻辑回归所做的预测也可以用作属于类0或类1的给定数据实例的概率。这对于需要为预测提供更多理论依据的问题非常有用。</p>
<p>与线性回归类似，当删除与输出变量无关的属性以及彼此非常相似(相关)的属性时，逻辑回归的效果更好。该模型学习速度快，对二值分类问题有效。</p>
<h3 id="3-线性判断分析-Linear-Discriminant-Analysis"><a href="#3-线性判断分析-Linear-Discriminant-Analysis" class="headerlink" title="3. 线性判断分析(Linear Discriminant Analysis)"></a>3. 线性判断分析(Linear Discriminant Analysis)</h3><p>逻辑回归是一种传统的分类算法，传统上仅限于两类分类问题。如果你有两个以上的类，那么线性判别分析算法是首选的线性分类技术。</p>
<p>LDA(Linear Discriminant Analysis)的表示非常直接。它包含为每个类计算的数据的统计属性。对于单个输入变量，这包括:</p>
<ul>
<li>每个类的平均值。</li>
<li>计算所有类的方差。<br><img src="top_10_machine_learning_algorithms/lda.png" alt="lda"></li>
</ul>
<p>预测是通过计算每个类的判别值，并对最大值的类进行预测。该技术假设数据具有高斯分布(钟形曲线)，因此最好预先从数据中删除异常值。它是一种简单而有效的分类预测建模方法。</p>
<h3 id="4-分类和回归树-Classification-and-Regression-Trees"><a href="#4-分类和回归树-Classification-and-Regression-Trees" class="headerlink" title="4. 分类和回归树(Classification and Regression Trees)"></a>4. 分类和回归树(Classification and Regression Trees)</h3><a id="more"></a>
<p>决策树(Decision Trees)是机器学习预测建模的一种重要算法。</p>
<p>决策树模型的表示形式为二叉树。这是来自算法和数据结构的二叉树，没什么特别的。每个节点表示一个输入变量(x)和该变量上的一个分歧点(假设该变量是数值型的)。<br><img src="top_10_machine_learning_algorithms/decision_trees.png" alt="decision_trees"></p>
<p>树的叶节点包含一个用于进行预测的输出变量(y)。通过遍历树的拆分，直到到达一个叶子节点，并在该叶子节点输出类值，就可以进行预测。</p>
<p>树学起来很快，预测起来也很快。它们对于广泛的问题通常是准确的，并且不需要为数据做任何特殊的准备。</p>
<h3 id="5-朴素贝叶斯-Naive-Bayes"><a href="#5-朴素贝叶斯-Naive-Bayes" class="headerlink" title="5. 朴素贝叶斯(Naive Bayes)"></a>5. 朴素贝叶斯(Naive Bayes)</h3><p>朴素贝叶斯(Naive Bayes)是一种简单但功能惊人的预测建模算法。</p>
<p>该模型由两类概率组成，可以直接从你的训练数据中计算出来:1)每节课的概率;2)给定每个x值，每个类的条件概率。概率模型一旦计算出来，就可以利用贝叶斯定理对新数据进行预测。当你的数据是实值的时候，通常采用高斯分布(钟形曲线)，这样你就可以很容易地估计这些概率。<br><img src="top_10_machine_learning_algorithms/naive_bayes.png" alt="naive_bayes"></p>
<p>朴素贝叶斯之所以称为朴素贝叶斯，是因为它假定每个输入变量都是独立的。这是一个强烈的假设，对真实数据来说是不现实的，然而，该技术在许多复杂的问题上是非常有效的。</p>
<h3 id="6-K最邻近算法-K-Nearest-Neighbors"><a href="#6-K最邻近算法-K-Nearest-Neighbors" class="headerlink" title="6. K最邻近算法(K-Nearest Neighbors)"></a>6. K最邻近算法(K-Nearest Neighbors)</h3><p>KNN(K-Nearest Neighbors)算法简单有效。KNN的模型表示是整个训练数据集。很简单的对吧?</p>
<p>通过搜索整个训练集中K个最相似的实例(邻居)并总结这些K个实例的输出变量，可以预测一个新的数据点。对于回归问题，这可能是平均输出变量，对于分类问题，这可能是模式(或最常见的)类值。</p>
<p>诀窍在于如何确定数据实例之间的相似性。如果您的属性都具有相同的比例(例如，都以英寸为单位)，那么最简单的技术就是使用欧式距离，您可以根据每个输入变量之间的差异直接计算这个数字。<br><img src="top_10_machine_learning_algorithms/knn.png" alt="knn"></p>
<p>KNN可能需要大量内存或空间来存储所有数据，但只有在需要预测时才会及时执行计算(或学习)。您还可以随着时间的推移更新和管理您的培训实例，以保持预测的准确性。</p>
<p>距离或接近的概念可能在非常高的维度(许多输入变量)中被打破，这可能会对算法在您的问题上的性能产生负面影响。这就是所谓的维数诅咒。它建议只使用与预测输出变量最相关的输入变量。</p>
<h3 id="7-学习矢量量化-Learning-Vector-Quantization"><a href="#7-学习矢量量化-Learning-Vector-Quantization" class="headerlink" title="7. 学习矢量量化(Learning Vector Quantization)"></a>7. 学习矢量量化(Learning Vector Quantization)</h3><p>k近邻的一个缺点是，您需要保留整个训练数据集。学习向量量化算法(简称LVQ)是一种人工神经网络算法，它允许您选择保留多少训练实例，并准确地了解这些实例应该是什么样子的。</p>
<p>LVQ的表示是一组码本向量。它们在开始时是随机选择的，经过多次学习算法的迭代，最适合于总结训练数据集。通过学习，码本向量可以像k近邻一样进行预测。通过计算每个码本向量与新数据实例之间的距离，可以找到最相似的邻居(最佳匹配码本向量)。然后返回最佳匹配单元的类值或(回归情况下的实值)作为预测。如果将数据重新调整为具有相同的范围(例如0到1之间)，就可以获得最佳结果。<br><img src="top_10_machine_learning_algorithms/lvq.png" alt="LVQ"><br>如果您发现KNN对您的数据集提供了良好的结果，请尝试使用LVQ来减少存储整个培训数据集的内存需求。</p>
<h3 id="8-支持向量机-Support-Vector-Machines"><a href="#8-支持向量机-Support-Vector-Machines" class="headerlink" title="8. 支持向量机(Support Vector Machines)"></a>8. 支持向量机(Support Vector Machines)</h3><p>支持向量机(Support Vector Machines)可能是最受欢迎和谈论的机器学习算法之一。</p>
<p>超平面是一条分割输入变量空间的线。在支持向量机中，选择一个超平面将输入变量空间中的点按类(0类或1类)进行最佳分离。在二维中，你可以把它想象成一条直线我们假设所有的输入点都可以被这条直线完全分开。支持向量机的学习算法通过超平面找到最优分类系数。<br><img src="top_10_machine_learning_algorithms/support_vector_machine.jpeg" alt="support_vector_machine"><br>超平面与最近数据点之间的距离称为边距。能够将这两个类分开的最佳或最优超平面是具有最大边界的直线。只有这些点与超平面的定义和分类器的构造有关。这些点称为支持向量。它们支持或定义超平面。在实际应用中，采用了一种优化算法来寻找使边值最大化的系数值。</p>
<p>SVM可能是最强大的开箱即用分类器之一，值得在您的数据集上尝试。</p>
<h3 id="9-随机森林-Bagging-and-Random-Forest"><a href="#9-随机森林-Bagging-and-Random-Forest" class="headerlink" title="9. 随机森林(Bagging and Random Forest)"></a>9. 随机森林(Bagging and Random Forest)</h3><p>随机森林(Bagging and Random Forest)是最流行和最强大的机器学习算法之一。它是一种集成机器学习算法，称为引导聚集或袋装。</p>
<p>bootstrap是一种强大的统计方法，用于从数据样本中估计数量。比如一个平均值。取大量数据样本，计算均值，然后取所有均值的平均值这样就能更好地估计真实均值。</p>
<p>在bagging中，使用了相同的方法，但用于估计整个统计模型，最常见的是决策树。获取多个训练数据样本，然后为每个数据样本构建模型。当您需要对新数据进行预测时，每个模型都会进行预测，并对预测进行平均，以便更好地估计真实的输出值。<br><img src="top_10_machine_learning_algorithms/random_forest.png" alt="Bagging and Random Forest"></p>
<p>随机森林是这种方法的一个改进，它创建决策树，这样就不用选择最优的分割点，而是通过引入随机性来进行次最优分割。</p>
<p>因此，为每个数据样本创建的模型比其他情况下的模型更加不同，但仍然以其独特和不同的方式准确。结合他们的预测，可以更好地估计真实的潜在产值。</p>
<p>如果您使用高方差的算法(如决策树)获得良好的结果，那么您通常可以通过打包该算法获得更好的结果。</p>
<h3 id="10-增强和自适应增强算法-Boosting-and-AdaBoost"><a href="#10-增强和自适应增强算法-Boosting-and-AdaBoost" class="headerlink" title="10. 增强和自适应增强算法(Boosting and AdaBoost)"></a>10. 增强和自适应增强算法(Boosting and AdaBoost)</h3><p>增强(Boosting)是一种集成技术，它试图从一些弱分类器创建一个强分类器。这是通过从训练数据构建一个模型，然后创建第二个模型，该模型试图纠正第一个模型中的错误。在完全预测训练集或添加最大数量的模型之前，将添加模型。</p>
<p>AdaBoost是第一个真正成功的用于二进制分类的增强算法。这是理解促进的最佳起点。现代增压方法建立在AdaBoost的基础上，最著名的是随机梯度增压机。<br><img src="top_10_machine_learning_algorithms/adaboost.jpeg" alt="AdaBoost"></p>
<p>AdaBoost用于短决策树。在创建第一个树之后，将使用树在每个训练实例上的性能来衡量创建的下一个树应该对每个训练实例关注多少。难以预测的训练数据权重更大，而易于预测的实例权重更小。模型是一个接一个依次创建的，每个模型都更新训练实例上的权重，这些实例会影响序列中的下一棵树执行的学习。在所有的树被建立之后，对新的数据进行预测，并且每棵树的性能都由它在训练数据上的准确性来加权。</p>
<p>由于算法在纠正错误上投入了如此多的精力，因此清除数据中的异常值是非常重要的。</p>
<p><em>原文请看此处：<br><a href="https://blog.goodaudience.com/top-10-machine-learning-algorithms-2a9a3e1bdaff">TOP 10 Machine Learning Algorithms</a></em></p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title>GDAL的简介和安装</title>
    <url>/gdal/gdal_using/</url>
    <content><![CDATA[<h2 id="GDAL的简介和安装"><a href="#GDAL的简介和安装" class="headerlink" title="GDAL的简介和安装"></a>GDAL的简介和安装</h2><p>在地理信息界，GDAL就是万物之源，即使连ArcGIS和QGIS都是引用它完成基础数据的处理。这开源的好东西，无疑是我们最最得意的拿手好戏。<br>其实GDAL全名为<code>Geospatial Data Abstraction Library</code>，来个官网，这个库分为两大部分是<strong>GDAL</strong>和<strong>OGR</strong>，分别管理着<strong>栅格</strong>和<strong>矢量</strong>数据。底层是C语言，上层可以是多种语言（包括python）调用，所以不用担心效率的问题。</p>
<p>GDAL主要包括以下几个主要的命令：</p>
<ul>
<li>gdalinfo: 浏览图片信息</li>
<li>gdal_translate: 格式转换</li>
<li>gdalwarp: 重投影</li>
<li>gdal_warp或者gdal_merge.py: 拼接数据</li>
<li>gdaltindex: 建立shapefile拥有栅格编号<a id="more"></a>
<h3 id="GDAL的安装和部署"><a href="#GDAL的安装和部署" class="headerlink" title="GDAL的安装和部署"></a>GDAL的安装和部署</h3><h4 id="GDAL源码安装"><a href="#GDAL源码安装" class="headerlink" title="GDAL源码安装"></a>GDAL源码安装</h4>由于本人一直处理不同的影像的数据，所以希望安装的GDAL尽可能支持多的数据格式，所以需要源码安装。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install openjpeg2-devel netcdf-devel hdf-devel geos-devel pcre-devel</span><br><span class="line"></span><br><span class="line">wget http://download.osgeo.org/gdal/2.4.0/gdal-2.4.0.tar.gz</span><br><span class="line">tar -zxvf gdal-2.4.0.tar.gz</span><br><span class="line">cd gdal-2.4.0</span><br><span class="line"></span><br><span class="line">./configure</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<h4 id="查看编译安装后，GDAL支持的格式"><a href="#查看编译安装后，GDAL支持的格式" class="headerlink" title="查看编译安装后，GDAL支持的格式"></a>查看编译安装后，GDAL支持的格式</h4></li>
</ul>
<ol>
<li>raster data<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gdalinfo --formats</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Supported Formats:</span><br><span class="line">  VRT -raster- (rw+v): Virtual Raster</span><br><span class="line">  DERIVED -raster- (ro): Derived datasets using VRT pixel functions</span><br><span class="line">  GTiff -raster- (rw+vs): GeoTIFF</span><br><span class="line">  NITF -raster- (rw+vs): National Imagery Transmission Format</span><br><span class="line">  RPFTOC -raster- (rovs): Raster Product Format TOC format</span><br><span class="line">  ECRGTOC -raster- (rovs): ECRG TOC format</span><br><span class="line">  HFA -raster- (rw+v): Erdas Imagine Images (.img)</span><br><span class="line">  SAR_CEOS -raster- (rov): CEOS SAR Image</span><br><span class="line">  CEOS -raster- (rov): CEOS Image</span><br><span class="line">  JAXAPALSAR -raster- (rov): JAXA PALSAR Product Reader (Level 1.1/1.5)</span><br><span class="line">  GFF -raster- (rov): Ground-based SAR Applications Testbed File Format (.gff)</span><br><span class="line">  ELAS -raster- (rw+v): ELAS</span><br><span class="line">  AIG -raster- (rov): Arc/Info Binary Grid</span><br><span class="line">  AAIGrid -raster- (rwv): Arc/Info ASCII Grid</span><br><span class="line">  GRASSASCIIGrid -raster- (rov): GRASS ASCII Grid</span><br><span class="line">  SDTS -raster- (rov): SDTS Raster</span><br><span class="line">  DTED -raster- (rwv): DTED Elevation Raster</span><br><span class="line">  PNG -raster- (rwv): Portable Network Graphics</span><br><span class="line">  JPEG -raster- (rwv): JPEG JFIF</span><br><span class="line">  MEM -raster- (rw+): In Memory Raster</span><br><span class="line">  JDEM -raster- (rov): Japanese DEM (.mem)</span><br><span class="line">  GIF -raster- (rwv): Graphics Interchange Format (.gif)</span><br><span class="line">  BIGGIF -raster- (rov): Graphics Interchange Format (.gif)</span><br><span class="line">  ESAT -raster- (rov): Envisat Image Format</span><br><span class="line">  BSB -raster- (rov): Maptech BSB Nautical Charts</span><br><span class="line">  XPM -raster- (rwv): X11 PixMap Format</span><br><span class="line">  BMP -raster- (rw+v): MS Windows Device Independent Bitmap</span><br><span class="line">  DIMAP -raster- (rov): SPOT DIMAP</span><br><span class="line">  AirSAR -raster- (rov): AirSAR Polarimetric Image</span><br><span class="line">  RS2 -raster- (rovs): RadarSat 2 XML Product</span><br><span class="line">  SAFE -raster- (rov): Sentinel-1 SAR SAFE Product</span><br><span class="line">  PCIDSK -raster,vector- (rw+v): PCIDSK Database File</span><br><span class="line">  PCRaster -raster- (rw+): PCRaster Raster File</span><br><span class="line">  ILWIS -raster- (rw+v): ILWIS Raster Map</span><br><span class="line">  SGI -raster- (rw+v): SGI Image File Format 1.0</span><br><span class="line">  SRTMHGT -raster- (rwv): SRTMHGT File Format</span><br><span class="line">  Leveller -raster- (rw+v): Leveller heightfield</span><br><span class="line">  Terragen -raster- (rw+v): Terragen heightfield</span><br><span class="line">  GMT -raster- (rw): GMT NetCDF Grid Format</span><br><span class="line">  netCDF -raster,vector- (rw+s): Network Common Data Format</span><br><span class="line">  ISIS3 -raster- (rw+v): USGS Astrogeology ISIS cube (Version 3)</span><br><span class="line">  ISIS2 -raster- (rw+v): USGS Astrogeology ISIS cube (Version 2)</span><br><span class="line">  PDS -raster- (rov): NASA Planetary Data System</span><br><span class="line">  PDS4 -raster- (rw+vs): NASA Planetary Data System 4</span><br><span class="line">  VICAR -raster- (rov): MIPL VICAR file</span><br><span class="line">  TIL -raster- (rov): EarthWatch .TIL</span><br><span class="line">  ERS -raster- (rw+v): ERMapper .ers Labelled</span><br><span class="line">  JP2OpenJPEG -raster,vector- (rwv): JPEG-2000 driver based on OpenJPEG library</span><br><span class="line">  L1B -raster- (rovs): NOAA Polar Orbiter Level 1b Data Set</span><br><span class="line">  FIT -raster- (rwv): FIT Image</span><br><span class="line">  GRIB -raster- (rwv): GRIdded Binary (.grb, .grb2)</span><br><span class="line">  RMF -raster- (rw+v): Raster Matrix Format</span><br><span class="line">  WCS -raster- (rovs): OGC Web Coverage Service</span><br><span class="line">  WMS -raster- (rwvs): OGC Web Map Service</span><br><span class="line">  MSGN -raster- (rov): EUMETSAT Archive native (.nat)</span><br><span class="line">  RST -raster- (rw+v): Idrisi Raster A.1</span><br><span class="line">  INGR -raster- (rw+v): Intergraph Raster</span><br><span class="line">  GSAG -raster- (rwv): Golden Software ASCII Grid (.grd)</span><br><span class="line">  GSBG -raster- (rw+v): Golden Software Binary Grid (.grd)</span><br><span class="line">  GS7BG -raster- (rw+v): Golden Software 7 Binary Grid (.grd)</span><br><span class="line">  COSAR -raster- (rov): COSAR Annotated Binary Matrix (TerraSAR-X)</span><br><span class="line">  TSX -raster- (rov): TerraSAR-X Product</span><br><span class="line">  COASP -raster- (ro): DRDC COASP SAR Processor Raster</span><br><span class="line">  R -raster- (rwv): R Object Data Store</span><br><span class="line">  MAP -raster- (rov): OziExplorer .MAP</span><br><span class="line">  KMLSUPEROVERLAY -raster- (rwv): Kml Super Overlay</span><br><span class="line">  PDF -raster,vector- (w+): Geospatial PDF</span><br><span class="line">  PLMOSAIC -raster- (ro): Planet Labs Mosaics API</span><br><span class="line">  CALS -raster- (rwv): CALS (Type 1)</span><br><span class="line">  WMTS -raster- (rwv): OGC Web Map Tile Service</span><br><span class="line">  SENTINEL2 -raster- (rovs): Sentinel 2</span><br><span class="line">  MRF -raster- (rw+v): Meta Raster Format</span><br><span class="line">  PNM -raster- (rw+v): Portable Pixmap Format (netpbm)</span><br><span class="line">  DOQ1 -raster- (rov): USGS DOQ (Old Style)</span><br><span class="line">  DOQ2 -raster- (rov): USGS DOQ (New Style)</span><br><span class="line">  PAux -raster- (rw+v): PCI .aux Labelled</span><br><span class="line">  MFF -raster- (rw+v): Vexcel MFF Raster</span><br><span class="line">  MFF2 -raster- (rw+): Vexcel MFF2 (HKV) Raster</span><br><span class="line">  FujiBAS -raster- (rov): Fuji BAS Scanner Image</span><br><span class="line">  GSC -raster- (rov): GSC Geogrid</span><br><span class="line">  FAST -raster- (rov): EOSAT FAST Format</span><br><span class="line">  BT -raster- (rw+v): VTP .bt (Binary Terrain) 1.3 Format</span><br><span class="line">  LAN -raster- (rw+v): Erdas .LAN/.GIS</span><br><span class="line">  CPG -raster- (rov): Convair PolGASP</span><br><span class="line">  IDA -raster- (rw+v): Image Data and Analysis</span><br><span class="line">  NDF -raster- (rov): NLAPS Data Format</span><br><span class="line">  EIR -raster- (rov): Erdas Imagine Raw</span><br><span class="line">  DIPEx -raster- (rov): DIPEx</span><br><span class="line">  LCP -raster- (rwv): FARSITE v.4 Landscape File (.lcp)</span><br><span class="line">  GTX -raster- (rw+v): NOAA Vertical Datum .GTX</span><br><span class="line">  LOSLAS -raster- (rov): NADCON .los/.las Datum Grid Shift</span><br><span class="line">  NTv1 -raster- (rov): NTv1 Datum Grid Shift</span><br><span class="line">  NTv2 -raster- (rw+vs): NTv2 Datum Grid Shift</span><br><span class="line">  CTable2 -raster- (rw+v): CTable2 Datum Grid Shift</span><br><span class="line">  ACE2 -raster- (rov): ACE2</span><br><span class="line">  SNODAS -raster- (rov): Snow Data Assimilation System</span><br><span class="line">  KRO -raster- (rw+v): KOLOR Raw</span><br><span class="line">  ROI_PAC -raster- (rw+v): ROI_PAC raster</span><br><span class="line">  RRASTER -raster- (rw+v): R Raster</span><br><span class="line">  BYN -raster- (rw+v): Natural Resources Canadas Geoid</span><br><span class="line">  ARG -raster- (rwv): Azavea Raster Grid format</span><br><span class="line">  RIK -raster- (rov): Swedish Grid RIK (.rik)</span><br><span class="line">  USGSDEM -raster- (rwv): USGS Optional ASCII DEM (and CDED)</span><br><span class="line">  GXF -raster- (rov): GeoSoft Grid Exchange Format</span><br><span class="line">  BAG -raster- (rwv): Bathymetry Attributed Grid</span><br><span class="line">  HDF5 -raster- (rovs): Hierarchical Data Format Release 5</span><br><span class="line">  HDF5Image -raster- (rov): HDF5 Dataset</span><br><span class="line">  NWT_GRD -raster- (rw+v): Northwood Numeric Grid Format .grd/.tab</span><br><span class="line">  NWT_GRC -raster- (rov): Northwood Classified Grid Format .grc/.tab</span><br><span class="line">  ADRG -raster- (rw+vs): ARC Digitized Raster Graphics</span><br><span class="line">  SRP -raster- (rovs): Standard Raster Product (ASRP/USRP)</span><br><span class="line">  BLX -raster- (rwv): Magellan topo (.blx)</span><br><span class="line">  SAGA -raster- (rw+v): SAGA GIS Binary Grid (.sdat, .sg-grd-z)</span><br><span class="line">  XYZ -raster- (rwv): ASCII Gridded XYZ</span><br><span class="line">  HF2 -raster- (rwv): HF2/HFZ heightfield raster</span><br><span class="line">  OZI -raster- (rov): OziExplorer Image File</span><br><span class="line">  CTG -raster- (rov): USGS LULC Composite Theme Grid</span><br><span class="line">  E00GRID -raster- (rov): Arc/Info Export E00 GRID</span><br><span class="line">  ZMap -raster- (rwv): ZMap Plus Grid</span><br><span class="line">  NGSGEOID -raster- (rov): NOAA NGS Geoid Height Grids</span><br><span class="line">  IRIS -raster- (rov): IRIS data (.PPI, .CAPPi etc)</span><br><span class="line">  PRF -raster- (rov): Racurs PHOTOMOD PRF</span><br><span class="line">  RDA -raster- (ro): DigitalGlobe Raster Data Access driver</span><br><span class="line">  EEDAI -raster- (ros): Earth Engine Data API Image</span><br><span class="line">  SIGDEM -raster- (rwv): Scaled Integer Gridded DEM .sigdem</span><br><span class="line">  IGNFHeightASCIIGrid -raster- (rov): IGN France height correction ASCII Grid</span><br><span class="line">  CAD -raster,vector- (rovs): AutoCAD Driver</span><br><span class="line">  PLSCENES -raster,vector- (ro): Planet Labs Scenes API</span><br><span class="line">  NGW -raster,vector- (rw+s): NextGIS Web</span><br><span class="line">  GenBin -raster- (rov): Generic Binary (.hdr Labelled)</span><br><span class="line">  ENVI -raster- (rw+v): ENVI .hdr Labelled</span><br><span class="line">  EHdr -raster- (rw+v): ESRI .hdr Labelled</span><br><span class="line">  ISCE -raster- (rw+v): ISCE raster</span><br><span class="line">  HTTP -raster,vector- (ro): HTTP Fetching Wrapper</span><br></pre></td></tr></table></figure></li>
<li>vector data<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ogrinfo --formats</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Supported Formats:</span><br><span class="line">  PCIDSK -raster,vector- (rw+v): PCIDSK Database File</span><br><span class="line">  netCDF -raster,vector- (rw+s): Network Common Data Format</span><br><span class="line">  JPEG2000 -raster,vector- (rwv): JPEG-2000 part 1 (ISO/IEC 15444-1), based on Jasper library</span><br><span class="line">  PDF -raster,vector- (w+): Geospatial PDF</span><br><span class="line">  MBTiles -raster,vector- (rw+v): MBTiles</span><br><span class="line">  EEDA -vector- (ro): Earth Engine Data API</span><br><span class="line">  ESRI Shapefile -vector- (rw+v): ESRI Shapefile</span><br><span class="line">  MapInfo File -vector- (rw+v): MapInfo File</span><br><span class="line">  UK .NTF -vector- (rov): UK .NTF</span><br><span class="line">  OGR_SDTS -vector- (rov): SDTS</span><br><span class="line">  S57 -vector- (rw+v): IHO S-57 (ENC)</span><br><span class="line">  DGN -vector- (rw+v): Microstation DGN</span><br><span class="line">  OGR_VRT -vector- (rov): VRT - Virtual Datasource</span><br><span class="line">  REC -vector- (ro): EPIInfo .REC</span><br><span class="line">  Memory -vector- (rw+): Memory</span><br><span class="line">  BNA -vector- (rw+v): Atlas BNA</span><br><span class="line">  CSV -vector- (rw+v): Comma Separated Value (.csv)</span><br><span class="line">  NAS -vector- (rov): NAS - ALKIS</span><br><span class="line">  GML -vector- (rw+v): Geography Markup Language (GML)</span><br><span class="line">  GPX -vector- (rw+v): GPX</span><br><span class="line">  KML -vector- (rw+v): Keyhole Markup Language (KML)</span><br><span class="line">  GeoJSON -vector- (rw+v): GeoJSON</span><br><span class="line">  GeoJSONSeq -vector- (rw+v): GeoJSON Sequence</span><br><span class="line">  ESRIJSON -vector- (rov): ESRIJSON</span><br><span class="line">  TopoJSON -vector- (rov): TopoJSON</span><br><span class="line">  Interlis 1 -vector- (rw+v): Interlis 1</span><br><span class="line">  Interlis 2 -vector- (rw+v): Interlis 2</span><br><span class="line">  OGR_GMT -vector- (rw+v): GMT ASCII Vectors (.gmt)</span><br><span class="line">  GPKG -raster,vector- (rw+vs): GeoPackage</span><br><span class="line">  SQLite -vector- (rw+v): SQLite / Spatialite</span><br><span class="line">  ODBC -vector- (rw+): ODBC</span><br><span class="line">  WAsP -vector- (rw+v): WAsP .map format</span><br><span class="line">  PGeo -vector- (ro): ESRI Personal GeoDatabase</span><br><span class="line">  MSSQLSpatial -vector- (rw+): Microsoft SQL Server Spatial Database</span><br><span class="line">  OpenFileGDB -vector- (rov): ESRI FileGDB</span><br><span class="line">  XPlane -vector- (rov): X-Plane/Flightgear aeronautical data</span><br><span class="line">  DXF -vector- (rw+v): AutoCAD DXF</span><br><span class="line">  CAD -raster,vector- (rovs): AutoCAD Driver</span><br><span class="line">  Geoconcept -vector- (rw+v): Geoconcept</span><br><span class="line">  GeoRSS -vector- (rw+v): GeoRSS</span><br><span class="line">  GPSTrackMaker -vector- (rw+v): GPSTrackMaker</span><br><span class="line">  VFK -vector- (ro): Czech Cadastral Exchange Data Format</span><br><span class="line">  PGDUMP -vector- (w+v): PostgreSQL SQL dump</span><br><span class="line">  OSM -vector- (rov): OpenStreetMap XML and PBF</span><br><span class="line">  GPSBabel -vector- (rw+): GPSBabel</span><br><span class="line">  SUA -vector- (rov): Tim Newport-Peaces Special Use Airspace Format</span><br><span class="line">  OpenAir -vector- (rov): OpenAir</span><br><span class="line">  OGR_PDS -vector- (rov): Planetary Data Systems TABLE</span><br><span class="line">  WFS -vector- (rov): OGC WFS (Web Feature Service)</span><br><span class="line">  WFS3 -vector- (ro): OGC WFS 3 client (Web Feature Service)</span><br><span class="line">  HTF -vector- (rov): Hydrographic Transfer Vector</span><br><span class="line">  AeronavFAA -vector- (rov): Aeronav FAA</span><br><span class="line">  Geomedia -vector- (ro): Geomedia .mdb</span><br><span class="line">  EDIGEO -vector- (rov): French EDIGEO exchange format</span><br><span class="line">  GFT -vector- (rw+): Google Fusion Tables</span><br><span class="line">  SVG -vector- (rov): Scalable Vector Graphics</span><br><span class="line">  CouchDB -vector- (rw+): CouchDB / GeoCouch</span><br><span class="line">  Cloudant -vector- (rw+): Cloudant / CouchDB</span><br><span class="line">  Idrisi -vector- (rov): Idrisi Vector (.vct)</span><br><span class="line">  ARCGEN -vector- (rov): Arc/Info Generate</span><br><span class="line">  SEGUKOOA -vector- (rov): SEG-P1 / UKOOA P1/90</span><br><span class="line">  SEGY -vector- (rov): SEG-Y</span><br><span class="line">  XLS -vector- (ro): MS Excel format</span><br><span class="line">  ODS -vector- (rw+v): Open Document/ LibreOffice / OpenOffice Spreadsheet</span><br><span class="line">  XLSX -vector- (rw+v): MS Office Open XML spreadsheet</span><br><span class="line">  ElasticSearch -vector- (rw+): Elastic Search</span><br><span class="line">  Walk -vector- (ro): Walk</span><br><span class="line">  Carto -vector- (rw+): Carto</span><br><span class="line">  AmigoCloud -vector- (rw+): AmigoCloud</span><br><span class="line">  SXF -vector- (rov): Storage and eXchange Format</span><br><span class="line">  Selafin -vector- (rw+v): Selafin</span><br><span class="line">  JML -vector- (rw+v): OpenJUMP JML</span><br><span class="line">  PLSCENES -raster,vector- (ro): Planet Labs Scenes API</span><br><span class="line">  CSW -vector- (ro): OGC CSW (Catalog  Service for the Web)</span><br><span class="line">  VDV -vector- (rw+v): VDV-451/VDV-452/INTREST Data Format</span><br><span class="line">  GMLAS -vector- (rwv): Geography Markup Language (GML) driven by application schemas</span><br><span class="line">  MVT -vector- (rw+v): Mapbox Vector Tiles</span><br><span class="line">  TIGER -vector- (rw+v): U.S. Census TIGER/Line</span><br><span class="line">  AVCBin -vector- (rov): Arc/Info Binary Coverage</span><br><span class="line">  AVCE00 -vector- (rov): Arc/Info E00 (ASCII) Coverage</span><br><span class="line">  NGW -raster,vector- (rw+s): NextGIS Web</span><br><span class="line">  HTTP -raster,vector- (ro): HTTP Fetching Wrapper</span><br></pre></td></tr></table></figure>
<h4 id="在Python下使用GDAL"><a href="#在Python下使用GDAL" class="headerlink" title="在Python下使用GDAL"></a>在Python下使用GDAL</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> osgeo <span class="keyword">import</span> gdal, gdal_array</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开GDAL支持的数据</span></span><br><span class="line">ds = gdal.Open(filename)</span><br><span class="line">subds = root_ds.GetSubDatasets()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存为TIFF数据</span></span><br><span class="line">driver = gdal.GetDriverByName(<span class="string">&#x27;GTiff&#x27;</span>)</span><br><span class="line">dataset = driver.Create(<span class="string">&#x27;./test.tif&#x27;</span>, RasterXSize, RasterYSize, RasterCount, DataType) <span class="comment"># DataType: gdal .GDT_UInt16</span></span><br><span class="line">out_data = dataset.GetRasterBand(<span class="number">1</span>)</span><br><span class="line">out_data.WriteArray(np.array(in_data))</span><br><span class="line">dataset.close()</span><br></pre></td></tr></table></figure></li>
</ol>
<p><em>此处只是简单结束，更多数据的读取和保存，请查看本人其他博客。</em></p>
<h4 id="源码安装后可能会存在的问题"><a href="#源码安装后可能会存在的问题" class="headerlink" title="源码安装后可能会存在的问题"></a>源码安装后可能会存在的问题</h4><ol>
<li>在执行import gdal_array时出现：<br>osgeo/_gdal.cpython-36m-x86_64-linux-gnu.so: undefined symbol: GDALDatasetTestCapability</li>
</ol>
<p>  <strong>解决方法：</strong> export LD_PRELOAD=/usr/local/lib/libgdal.so.20</p>
]]></content>
      <categories>
        <category>BigData</category>
        <category>GIS</category>
      </categories>
      <tags>
        <tag>BigData、GIS</tag>
      </tags>
  </entry>
  <entry>
    <title>GeoPySpark中的地图代数</title>
    <url>/bigdata/geopyspark/geopyspark_map_algebra/</url>
    <content><![CDATA[<h2 id="GeoPySpark中的地图代数"><a href="#GeoPySpark中的地图代数" class="headerlink" title="GeoPySpark中的地图代数"></a>GeoPySpark中的地图代数</h2><p>给定一组栅格图层，可能需要组合和过滤这些图层的内容。这是<em>映射代数</em>的函数。GeoPySpark提供了两类地图代数操作:<em>local</em>和<em>focal</em>操作。local操作考虑一个或多个栅格的像素或单元格，将函数应用于相应的单元格值。例如，添加两个栅格的像素值来形成一个新的图层是。</p>
<p>focal操作考虑一个输入栅格的每个像素周围的区域，并对每个区域应用操作。该操作的结果存储在输出栅格的相应像素中。例如，可以根据2d高斯分布对以像素为中心的5x5区域进行加权，以影响输入入栅格的模糊。有人可能会认为这相当于一个二维卷积运算。</p>
<p><strong>注意:</strong> 映射代数操作只能在<code>TiledRasterLayers</code>上工作，如果一个local操作需要多个输入，那么这些输入必须具有相同的布局和投影。</p>
<p>在开始之前，本指南中的所有示例都需要导入一下包:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> geopyspark <span class="keyword">as</span> gps</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pyspark <span class="keyword">import</span> SparkContext</span><br><span class="line"><span class="keyword">from</span> shapely.geometry <span class="keyword">import</span> Point, MultiPolygon, LineString, box</span><br><span class="line"></span><br><span class="line">conf = gps.geopyspark_conf(master=<span class="string">&quot;local[*]&quot;</span>, appName=<span class="string">&quot;map-algebra&quot;</span>)</span><br><span class="line">pysc = SparkContext(conf=conf)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Setting up the data</span></span><br><span class="line"></span><br><span class="line">cells = np.array([[[<span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">                   [<span class="number">7</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">                   [<span class="number">3</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">1</span>],</span><br><span class="line">                   [<span class="number">0</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                   [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">5</span>]]], dtype=<span class="string">&#x27;int32&#x27;</span>)</span><br><span class="line"></span><br><span class="line">extent = gps.ProjectedExtent(extent = gps.Extent(<span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">5</span>), epsg=<span class="number">4326</span>)</span><br><span class="line"></span><br><span class="line">layer = [(extent, gps.Tile.from_numpy_array(numpy_array=cells))]</span><br><span class="line"></span><br><span class="line">rdd = pysc.parallelize(layer)</span><br><span class="line">raster_layer = gps.RasterLayer.from_numpy_rdd(gps.LayerType.SPATIAL, rdd)</span><br><span class="line">tiled_layer = raster_layer.tile_to_layout(layout=gps.LocalLayout(tile_size=<span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<h3 id="Local-Operations"><a href="#Local-Operations" class="headerlink" title="Local Operations"></a>Local Operations</h3><a id="more"></a>
<p>在<code>TiledRasterLayers</code>上的Local操作可以使用<code>int</code>、<code>float</code>或其他<code>TiledRasterLayers</code>。<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>**</code>和<code>abs</code>都是当前支持的Local操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(tiled_layer + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span> - (tiled_layer * <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">((tiled_layer + tiled_layer) / (tiled_layer + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">abs</span>(tiled_layer)</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> ** tiled_layer</span><br></pre></td></tr></table></figure>
<p><strong>Pyramid</strong>也可以用于Local操作。可以在<code>Pyramid</code>的本地操作中使用的类型有:<code>int</code>、<code>float</code>、<code>TiledRasterLayer</code>和其他的<code>Pyramid</code>。</p>
<p><strong>注意:</strong> 与使用<code>TiledRasterLayer</code>一样，在多个<code>Pyramid</code>或<code>TiledRasterLayer</code>上执行计算意味着它们必须具有相同的布局和投影。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Creating out Pyramid</span></span><br><span class="line">pyramid = tiled_layer.pyramid()</span><br><span class="line"></span><br><span class="line">pyramid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">(pyramid - tiled_layer) * <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="Focal-Operations"><a href="#Focal-Operations" class="headerlink" title="Focal Operations"></a>Focal Operations</h3><p>在GeoPySpark中，Focal操作是通过对图层中每个<code>Tile</code>的邻域执行给定操作来执行的。可以从<code>Neighborhood</code>枚举类中选择要使用的邻域。同样，可以从<code>operation</code>枚举类中选择一个操作类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># This creates an instance of Square with an extent of 1. This means that</span></span><br><span class="line"><span class="comment"># each operation will be performed on a 3x3</span></span><br><span class="line"><span class="comment"># neighborhood.</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">A square neighborhood with an extent of 1.</span></span><br><span class="line"><span class="string">o = source cell</span></span><br><span class="line"><span class="string">x = cells that fall within the neighbhorhood</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">x x x</span></span><br><span class="line"><span class="string">x o x</span></span><br><span class="line"><span class="string">x x x</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">square = gps.Square(extent=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h4 id="Mean"><a href="#Mean" class="headerlink" title="Mean"></a>Mean</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tiled_layer.focal(operation=gps.Operation.MEAN, neighborhood=square)</span><br></pre></td></tr></table></figure>
<h4 id="Median"><a href="#Median" class="headerlink" title="Median"></a>Median</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tiled_layer.focal(operation=gps.Operation.MEDIAN, neighborhood=square)</span><br></pre></td></tr></table></figure>
<h4 id="Mode"><a href="#Mode" class="headerlink" title="Mode"></a>Mode</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tiled_layer.focal(operation=gps.Operation.MODE, neighborhood=square)</span><br></pre></td></tr></table></figure>
<h4 id="Sum"><a href="#Sum" class="headerlink" title="Sum"></a>Sum</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tiled_layer.focal(operation=gps.Operation.SUM, neighborhood=square)</span><br></pre></td></tr></table></figure>
<h4 id="Standard-Diviation"><a href="#Standard-Diviation" class="headerlink" title="Standard Diviation"></a>Standard Diviation</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tiled_layer.focal(operation=gps.Operation.STANDARD_DEVIATION, neighborhood=square)</span><br></pre></td></tr></table></figure>
<h4 id="Min"><a href="#Min" class="headerlink" title="Min"></a>Min</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tiled_layer.focal(operation=gps.Operation.MIN, neighborhood=square)</span><br></pre></td></tr></table></figure>
<h4 id="Max"><a href="#Max" class="headerlink" title="Max"></a>Max</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tiled_layer.focal(operation=gps.Operation.MAX, neighborhood=square)</span><br></pre></td></tr></table></figure>
<h4 id="Slope"><a href="#Slope" class="headerlink" title="Slope"></a>Slope</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tiled_layer.focal(operation=gps.Operation.SLOPE, neighborhood=square)</span><br></pre></td></tr></table></figure>
<h4 id="Aspect"><a href="#Aspect" class="headerlink" title="Aspect"></a>Aspect</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tiled_layer.focal(operation=gps.Operation.ASPECT, neighborhood=square)</span><br></pre></td></tr></table></figure>
<h3 id="各种各样的栅格操作"><a href="#各种各样的栅格操作" class="headerlink" title="各种各样的栅格操作"></a>各种各样的栅格操作</h3><p>还有其他方法可以从栅格中提取信息并创建需要显示的栅格。这些是<em>polygonal summaries, cost distance, and rasterization</em>。</p>
<h4 id="Polygonal-Summary-Methods"><a href="#Polygonal-Summary-Methods" class="headerlink" title="Polygonal Summary Methods"></a>Polygonal Summary Methods</h4><p>除了lcoal和focal操作外，还可以在<code>TiledRasterLayer</code>上执行多边形摘要。这些是在与给定几何图形和层相交的区域中执行的操作。</p>
<p><strong>注意:</strong> 重要的是，给定的几何图形在同一投影层。如果不是，那么要么返回错误的结果，要么只返回部分结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tiled_layer.layer_metadata</span><br></pre></td></tr></table></figure>
<h5 id="Polygonal-Min"><a href="#Polygonal-Min" class="headerlink" title="Polygonal Min"></a>Polygonal Min</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">poly_min = box(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>)</span><br><span class="line">tiled_layer.polygonal_min(geometry=poly_min, data_type=<span class="built_in">int</span>)</span><br></pre></td></tr></table></figure>
<h5 id="Polygonal-Max"><a href="#Polygonal-Max" class="headerlink" title="Polygonal Max"></a>Polygonal Max</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">poly_max = box(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">2.0</span>, <span class="number">2.5</span>)</span><br><span class="line">tiled_layer.polygonal_min(geometry=poly_max, data_type=<span class="built_in">int</span>)</span><br></pre></td></tr></table></figure>
<h5 id="Polygonal-Sum"><a href="#Polygonal-Sum" class="headerlink" title="Polygonal Sum"></a>Polygonal Sum</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">poly_sum = box(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>)</span><br><span class="line">tiled_layer.polygonal_min(geometry=poly_sum, data_type=<span class="built_in">int</span>)</span><br></pre></td></tr></table></figure>
<h5 id="Polygonal-Mean"><a href="#Polygonal-Mean" class="headerlink" title="Polygonal Mean"></a>Polygonal Mean</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">poly_max = box(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">2.0</span>, <span class="number">2.0</span>)</span><br><span class="line">tiled_layer.polygonal_min(geometry=poly_max, data_type=<span class="built_in">int</span>)</span><br></pre></td></tr></table></figure>
<h4 id="Cost-Distance"><a href="#Cost-Distance" class="headerlink" title="Cost Distance"></a>Cost Distance</h4><p><strong>cost_distance()</strong> 是一种迭代方法，用于逼近从栅格单元到给定几何图形的加权距离。<code>cost_distance</code>函数包含一个几何图形和一个“范围图层”，它本质上描述了遍历每个栅格单元的困难程度。落在几何形状中的单元格的最终成本为零，而包含noData值的范围单元格将对应于最终结果中的noData值。所有其他单元格都有一个值，该值描述从该单元格到几何图形的最小遍历成本。如果范围图层是均匀的，这个函数近似于欧几里得距离，取某个标量值的模。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cost_distance_cells = np.array([[[<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>],</span><br><span class="line">                                 [<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>],</span><br><span class="line">                                 [<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>],</span><br><span class="line">                                 [<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>],</span><br><span class="line">                                 [<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>]]])</span><br><span class="line"></span><br><span class="line">tile = gps.Tile.from_numpy_array(numpy_array=cost_distance_cells, no_data_value=-<span class="number">1.0</span>)</span><br><span class="line">cost_distance_extent = gps.ProjectedExtent(extent=gps.Extent(xmin=<span class="number">0.0</span>, ymin=<span class="number">0.0</span>, xmax=<span class="number">5.0</span>, ymax=<span class="number">5.0</span>), epsg=<span class="number">4326</span>)</span><br><span class="line">cost_distance_layer = [(cost_distance_extent, tile)]</span><br><span class="line"></span><br><span class="line">cost_distance_rdd = pysc.parallelize(cost_distance_layer)</span><br><span class="line">cost_distance_raster_layer = gps.RasterLayer.from_numpy_rdd(gps.LayerType.SPATIAL, cost_distance_rdd)</span><br><span class="line">cost_distance_tiled_layer = cost_distance_raster_layer.tile_to_layout(layout=gps.LocalLayout(tile_size=<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">gps.cost_distance(friction_layer=cost_distance_tiled_layer, geometries=[Point(<span class="number">0.0</span>, <span class="number">5.0</span>)], max_distance=<span class="number">144000.0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Rasterization"><a href="#Rasterization" class="headerlink" title="Rasterization"></a>Rasterization</h3><p>最好将矢量数据转换成栅格图层。因为我们提供了<code>rasterize()</code>函数，该函数确定每个向量元素所覆盖的像素值集，并将提供的值分配给目标栅格中的像素集。例如，如果有一组代表美国各县的多边形，以及每个县的收入中值，就可以制作一个栅格来表示这些数据。</p>
<p>GeoPySpark的<code>rasterize</code>功能可以采取<code>[shapely.geometry], (shapely.geometry)</code>，或<code>PythonRDD[shaply .geometry]</code>。这些几何图形将转换为栅格，然后平铺到给定的布局，然后返回一个包含这些值的<code>TiledRasterLayer</code>。</p>
<h4 id="Rasterize-MultiPolygons"><a href="#Rasterize-MultiPolygons" class="headerlink" title="Rasterize MultiPolygons"></a>Rasterize MultiPolygons</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">raster_poly_1 = box(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">5.0</span>, <span class="number">10.0</span>)</span><br><span class="line">raster_poly_2 = box(<span class="number">3.0</span>, <span class="number">6.0</span>, <span class="number">15.0</span>, <span class="number">20.0</span>)</span><br><span class="line">raster_poly_3 = box(<span class="number">13.5</span>, <span class="number">17.0</span>, <span class="number">30.0</span>, <span class="number">20.0</span>)</span><br><span class="line"></span><br><span class="line">raster_multi_poly = MultiPolygon([raster_poly_1, raster_poly_2, raster_poly_3])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Creates a TiledRasterLayer with a CRS of EPSG:4326 at zoom level 5.</span></span><br><span class="line">gps.rasterize(geoms=[raster_multi_poly], crs=<span class="number">4326</span>, zoom=<span class="number">5</span>, fill_value=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h4 id="Rasterize-a-PythonRDD-of-Polygons"><a href="#Rasterize-a-PythonRDD-of-Polygons" class="headerlink" title="Rasterize a PythonRDD of Polygons"></a>Rasterize a PythonRDD of Polygons</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">poly_rdd = pysc.parallelize([raster_poly_1, raster_poly_2, raster_poly_3])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Creates a TiledRasterLayer with a CRS of EPSG:3857 at zoom level 5.</span></span><br><span class="line">gps.rasterize(geoms=poly_rdd, crs=<span class="number">3857</span>, zoom=<span class="number">3</span>, fill_value=<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<h4 id="Rasterize-LineStrings"><a href="#Rasterize-LineStrings" class="headerlink" title="Rasterize LineStrings"></a>Rasterize LineStrings</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">line_1 = LineString(((<span class="number">0.0</span>, <span class="number">0.0</span>), (<span class="number">0.0</span>, <span class="number">5.0</span>)))</span><br><span class="line">line_2 = LineString(((<span class="number">7.0</span>, <span class="number">5.0</span>), (<span class="number">9.0</span>, <span class="number">12.0</span>), (<span class="number">12.5</span>, <span class="number">15.0</span>)))</span><br><span class="line">line_3 = LineString(((<span class="number">12.0</span>, <span class="number">13.0</span>), (<span class="number">14.5</span>, <span class="number">20.0</span>)))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Creates a TiledRasterLayer whose cells have a data type of int16.</span></span><br><span class="line">gps.rasterize(geoms=[line_1, line_2, line_3], crs=<span class="number">4326</span>, zoom=<span class="number">3</span>, fill_value=<span class="number">2</span>, cell_type=gps.CellType.INT16)</span><br></pre></td></tr></table></figure>
<h4 id="Rasterize-Polygons-and-LineStrings"><a href="#Rasterize-Polygons-and-LineStrings" class="headerlink" title="Rasterize Polygons and LineStrings"></a>Rasterize Polygons and LineStrings</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Creates a TiledRasterLayer from both LineStrings and MultiPolygons</span></span><br><span class="line">gps.rasterize(geoms=[line_1, line_2, line_3, raster_multi_poly], crs=<span class="number">4326</span>, zoom=<span class="number">5</span>, fill_value=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>BigData</category>
      </categories>
      <tags>
        <tag>BigData</tag>
      </tags>
  </entry>
  <entry>
    <title>GeoPySpark处理各类栅格数据</title>
    <url>/bigdata/geopyspark/geopyspark_layers/</url>
    <content><![CDATA[<h2 id="GeoPySpark处理各类栅格数据"><a href="#GeoPySpark处理各类栅格数据" class="headerlink" title="GeoPySpark处理各类栅格数据"></a>GeoPySpark处理各类栅格数据</h2><p>在开始之前，我们首先下载样例数据和导入模块包：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">curl -o /Users/xujavy/Documents/Work/data/jupyter_data/cropped.tif https://s3.amazonaws.com/geopyspark-test/example-files/cropped.tif</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># geopyspark需要设置SPARK_HOME</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">&quot;SPARK_HOME&quot;</span>] = <span class="string">&#x27;/Users/xujavy/Documents/Work/geoserver/installpackages/spark-2.2.3-bin-hadoop2.7&#x27;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pyproj</span><br><span class="line"><span class="keyword">import</span> geopyspark <span class="keyword">as</span> gps</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pyspark <span class="keyword">import</span> SparkContext</span><br><span class="line"><span class="keyword">from</span> shapely.geometry <span class="keyword">import</span> box, Point</span><br><span class="line"></span><br><span class="line">conf = gps.geopyspark_conf(master=<span class="string">&quot;local[*]&quot;</span>, appName=<span class="string">&quot;layers&quot;</span>)</span><br><span class="line">pysc = SparkContext(conf=conf)</span><br></pre></td></tr></table></figure>
<h3 id="如何在GeoPySpark中存储和表示数据"><a href="#如何在GeoPySpark中存储和表示数据" class="headerlink" title="如何在GeoPySpark中存储和表示数据?"></a>如何在GeoPySpark中存储和表示数据?</h3><a id="more"></a>
<p>GeoPySpark中使用的所有数据都存储在<code>RDD</code>中。因此，理解GeoPySpark如何在整个库中存储、表示和使用这些<code>RDD</code>非常重要。</p>
<p>GeoPySpark不使用PySpark RDDs，而是使用Python类作为Scala类的包装器，这些类包含并使用Scala RDD。具体来说，这些包装器类是<strong>RasterLayer</strong>和<strong>TiledRasterLayer</strong>层，后面将更详细地讨论它们。</p>
<h4 id="图层不仅仅是RDD"><a href="#图层不仅仅是RDD" class="headerlink" title="图层不仅仅是RDD"></a>图层不仅仅是RDD</h4><p>我们将Python包装器类称为层而不是<code>RDD</code>s，原因有两个:首先，<code>RasterLayer</code>或<code>TiledRasterLayer</code>实际上都没有扩展PySpark的<code>RDD</code>类;但更重要的是，这些类包含比<code>RDD</code>更多的信息。当我们提到“层”时，我们指的是<code>RDD</code>及其属性。</p>
<p>GeoPySpark层包含的<code>RDD</code>s包含类型为<code>(K, V)</code>的元组，其中K表示键，V表示值。V始终是<code>Tile</code>，但是K的不同取决于包装器类和数据本身的性质。更多信息请见下文。</p>
<h4 id="RasterLayer"><a href="#RasterLayer" class="headerlink" title="RasterLayer"></a>RasterLayer</h4><p><code>RasterLayer</code>类处理未处理的数据，也就是说，该图层的元素没有被规范化为一个统一的布局。每个栅格元素可能有不同的分辨率或尺寸;组成栅格的范围不需要遵循任何有序的模式。本质上，<code>RasterLayer</code>存储”raw”数据，其主要目的是充当获取遵循指定布局的瓦片数据的路径上的中转站。</p>
<p><code>RasterLayer</code>对象包含<code>RDD</code>s分别为<strong>ProjectedExtent</strong>或<strong>TemporalProjectedExtent</strong>的键类型K，该层类型为<strong>SPATIAL</strong>或<strong>PACETIME</strong>。</p>
<h4 id="TiledRasterLayer"><a href="#TiledRasterLayer" class="headerlink" title="TiledRasterLayer"></a>TiledRasterLayer</h4><p><code>TiledRasterLayer</code>是<code>RasterLayer</code>的补充，用于存储瓦片数据。瓦片数据已符合一定的布局，这意味着它已定期取样，并已被分割成大小均匀、不重叠的片段，可以合理地建立索引。让数据处于这种状态的好处是，很容易使用它。例如，通过这个类，用户将能够执行映射代数、创建金字塔和保存层。下面是这些操作的定义和具体示例。</p>
<p>对于<code>TiledRasterLayer</code>, K是<strong>SpatialKey</strong>或<strong>SpaceTimeKey</strong>。</p>
<h3 id="RasterLayer操作"><a href="#RasterLayer操作" class="headerlink" title="RasterLayer操作"></a>RasterLayer操作</h3><h4 id="创建RasterLayers"><a href="#创建RasterLayers" class="headerlink" title="创建RasterLayers"></a>创建RasterLayers</h4><p>有两种方法可以创建<code>RasterLayer</code>:(1)通过本地文件系统、S3或HDFS读取geotiff;(2)来自现有的PySpark RDD。</p>
<h5 id="来自PySpark-RDDs"><a href="#来自PySpark-RDDs" class="headerlink" title="来自PySpark RDDs"></a>来自PySpark RDDs</h5><p>从PySpark <code>RDD</code>创建<code>RasterLayer</code>第一个参数是<strong>from_numpy_rdd()</strong> 类方法。这一步可能有点复杂，因为它要求以特定的方式格式化PySpark RDD中的数据。</p>
<p>下面的示例从元组构造<code>RDD</code>。第一个参数是<code>ProjectedExtent</code>，因为我们决定将数据空间化。如果我们处理的是时空数据，那么<code>TemporalProjectedExtent</code>将是第一个参数。<code>Tile</code>总是元组的第二个元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.ones((<span class="number">1</span>, <span class="number">16</span>, <span class="number">16</span>), dtype=<span class="string">&#x27;int&#x27;</span>)</span><br><span class="line">tile = gps.Tile.from_numpy_array(numpy_array=np.array(arr), no_data_value=-<span class="number">500</span>)</span><br><span class="line"></span><br><span class="line">extent = gps.Extent(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>)</span><br><span class="line">projected_extent = gps.ProjectedExtent(extent=extent, epsg=<span class="number">3857</span>)</span><br><span class="line"></span><br><span class="line">rdd = pysc.parallelize([(projected_extent, tile), (projected_extent, tile)])</span><br><span class="line">multiband_raster_layer = gps.RasterLayer.from_numpy_rdd(layer_type=gps.LayerType.SPATIAL, numpy_rdd=rdd)</span><br><span class="line">multiband_raster_layer</span><br></pre></td></tr></table></figure>
<h5 id="来自GeoTiffs"><a href="#来自GeoTiffs" class="headerlink" title="来自GeoTiffs"></a>来自GeoTiffs</h5><p><code>geopyspark.geotrellis</code>中的<strong>get()</strong> 函数，可以从geotiff创建一个<code>RasterLayer</code>实例。这些文件可以位于本地文件系统、HDFS或S3上。在本例中，本地读取带有空间数据的GeoTiff。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">raster_layer = gps.geotiff.get(layer_type=gps.LayerType.SPATIAL, uri=<span class="string">&quot;file:///Users/xujavy/Documents/Work/data/jupyter_data/cropped.tif&quot;</span>)</span><br><span class="line">raster_layer</span><br></pre></td></tr></table></figure>
<h4 id="使用RasterLayer"><a href="#使用RasterLayer" class="headerlink" title="使用RasterLayer"></a>使用RasterLayer</h4><p>下一节将介绍<code>RasterLayer</code>方法。应该注意的是，并不是该类中包含的所有方法都将被覆盖。<a href="">在GeoPySpark中的可视化数据</a>中可以找到更多关于处理层内容可视化的方法的信息。</p>
<h5 id="转换成一个Python-RDD"><a href="#转换成一个Python-RDD" class="headerlink" title="转换成一个Python RDD"></a>转换成一个Python RDD</h5><p>通过使用<strong>to_numpy_rdd()</strong> ，<code>RasterLayer</code>将被序列化为Python <code>RDD</code>。这将把每个元组中的第一个值转换为<code>ProjectedExtent</code>或<code>TemporalProjectedExtent</code>，第二个值转换为<code>Tile</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python_rdd = raster_layer.to_numpy_rdd()</span><br><span class="line">python_rdd</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python_rdd.first()</span><br></pre></td></tr></table></figure>
<h5 id="SpaceTime-Layer-转换为-Spatial-Layer"><a href="#SpaceTime-Layer-转换为-Spatial-Layer" class="headerlink" title="SpaceTime Layer 转换为 Spatial Layer"></a>SpaceTime Layer 转换为 Spatial Layer</h5><p>如果使用的是spatial-temporal图层，并且希望将其转换为空间层，那么可以使用<strong>to_spatial_layer()</strong> 方法。这将通过将<code>TemporalProjectedExtent</code>转换为<code>ProjectedExtent</code>来更改层中<code>RDD</code>的键。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Creating the space time layer</span></span><br><span class="line">instant = datetime.datetime.now()</span><br><span class="line">temporal_projected_extent = gps.TemporalProjectedExtent(extent=projected_extent.extent,</span><br><span class="line">                            epsg=projected_extent.epsg,</span><br><span class="line">                            instant=instant)</span><br><span class="line"></span><br><span class="line">space_time_rdd = pysc.parallelize([temporal_projected_extent, tile])</span><br><span class="line">space_time_layer = gps.RasterLayer.from_numpy_rdd(layer_type=gps.LayerType.SPACETIME, numpy_rdd=space_time_rdd)</span><br><span class="line">space_time_layer</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Converting the SpaceTime layer to a Spatial layer</span></span><br><span class="line">space_time_layer.to_spatial_layer()</span><br></pre></td></tr></table></figure>
<h5 id="收集元数据"><a href="#收集元数据" class="headerlink" title="收集元数据"></a>收集元数据</h5><p>图层的<strong>Metadata</strong>包含图层中值的信息。这些数据包含该图层的的布局、投影和范围。</p>
<p><strong>collect_metadata()**将返回符合给定<code>layout</code>图层的</strong>Metadata**。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Collecting Metadata with the default LocalLayout()</span></span><br><span class="line">metadata = raster_layer.collect_metadata()</span><br><span class="line">metadata</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Collecting Metadata with the default GlobalLayout()</span></span><br><span class="line">raster_layer.collect_metadata(layout=gps.GlobalLayout())</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Collecting Metadata with a LayoutDefinition</span></span><br><span class="line">extent = gps.Extent(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">33.0</span>, <span class="number">33.0</span>)</span><br><span class="line">tile_layout = gps.TileLayout(<span class="number">2</span>, <span class="number">2</span>, <span class="number">256</span>, <span class="number">256</span>)</span><br><span class="line">layout_definition = gps.LayoutDefinition(extent, tile_layout)</span><br><span class="line"></span><br><span class="line">raster_layer.collect_metadata(layout=layout_definition)</span><br></pre></td></tr></table></figure>
<h5 id="重定义投影"><a href="#重定义投影" class="headerlink" title="重定义投影"></a>重定义投影</h5><p><strong>reproject()</strong> 将把图层内栅格数据的原始投影更改为给定的<code>target_crs</code>投影。此方法不会对超过瓦片边界的区域进行采样。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The CRS of the layer before reprojecting</span></span><br><span class="line">metadata.crs</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The CRS of the layer after reprojecting</span></span><br><span class="line">raster_layer.reproject(target_crs=<span class="number">3857</span>).collect_metadata().crs</span><br></pre></td></tr></table></figure>
<h5 id="将Tile数据转换到一个Layout"><a href="#将Tile数据转换到一个Layout" class="headerlink" title="将Tile数据转换到一个Layout"></a>将Tile数据转换到一个Layout</h5><p>**tile_to_layout()**将<code>RasterLayer</code>的栅格瓦片格式化为给定的布局。这个切片的结果是一个新的<code>TiledRasterLayer</code>实例。此输出包含与源<code>RasterLayer</code>相同的数据，但是，其中包含的信息现在将根据给定的布局进行组织。</p>
<p>在此步骤中，还可以重新投影<code>RasterLayer</code>。这可以通过指定要重新映射到的<code>target_crs</code>来实现。使用此方法进行重新投影产生的结果与重新投影方法返回的结果不同。后者不会超出图层内栅格的边界进行采样，而前者会。这一点非常重要，因为全局布局需要超越栅格的边界进行采样。</p>
<ol>
<li><p>从Metadata</p>
<p>创建一个包含给定<code>Metadata</code>布局的<code>TiledRasterLayer</code>。</p>
</li>
</ol>
<p>  <strong>注意:</strong> 如果指定的<code>target_crs</code>与元数据中的不同，那么将抛出一个错误。<br>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">raster_layer.tile_to_layout(layout=metadata)</span><br></pre></td></tr></table></figure><br>2. 从LayoutDefinition<br>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">raster_layer.tile_to_layout(layout=layout_definition)</span><br></pre></td></tr></table></figure><br>3. 从LocalLayout<br>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">raster_layer.tile_to_layout(gps.LocalLayout())</span><br></pre></td></tr></table></figure><br>4. 从GlobalLayout<br>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tiled_raster_layer = raster_layer.tile_to_layout(gps.GlobalLayout())</span><br><span class="line">tiled_raster_layer</span><br></pre></td></tr></table></figure><br>5. 从一个TiledRasterLayer<br>  可以将<code>RasterLayertile</code>的tile与<code>TiledRasterLayout</code>相同的布局。</p>
<p>  注意:如果指定的<strong>target_crs</strong>与其他层的不同，那么将抛出一个错误。</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">raster_layer.tile_to_layout(layout=tiled_raster_layer)</span><br></pre></td></tr></table></figure>
<h3 id="TiledRasterLayer-1"><a href="#TiledRasterLayer-1" class="headerlink" title="TiledRasterLayer"></a>TiledRasterLayer</h3><h4 id="创建TiledRasterLayers"><a href="#创建TiledRasterLayers" class="headerlink" title="创建TiledRasterLayers"></a>创建TiledRasterLayers</h4><p>我们将介绍一个<code>TiledRasterLayer</code>的初始化方法<strong>from_numpy_rdd</strong>。然而，还有其他方法可以创建这个类。这些额外的创建策略可以在[map algebra guide]中找到。</p>
<h5 id="从PySpark-RDD"><a href="#从PySpark-RDD" class="headerlink" title="从PySpark RDD"></a>从PySpark RDD</h5><p>与<code>RasterLayer</code>一样，可以使用<strong>from_numpy_rdd()</strong> 从<code>RDD</code>s创建<code>TiledRasterLayer</code>。但是，不同的是，元数据还必须在初始化期间传入。这使得以这种方式创建<code>TiledRasterLayer</code>变得更加困难。</p>
<p>下面的示例从元组构造<code>RDD</code>。第一个元素是<code>SpatialKey</code>，因为我们决定将数据空间化。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = np.zeros((<span class="number">1</span>, <span class="number">512</span>, <span class="number">512</span>), dtype=<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line">tile = gps.Tile.from_numpy_array(numpy_array=data, no_data_value=-<span class="number">1.0</span>)</span><br><span class="line">instant = datetime.datetime.now()</span><br><span class="line"></span><br><span class="line">layer = [(gps.SpaceTimeKey(row=<span class="number">0</span>, col=<span class="number">0</span>, instant=instant), tile),</span><br><span class="line">         (gps.SpaceTimeKey(row=<span class="number">1</span>, col=<span class="number">0</span>, instant=instant), tile),</span><br><span class="line">         (gps.SpaceTimeKey(row=<span class="number">0</span>, col=<span class="number">1</span>, instant=instant), tile),</span><br><span class="line">         (gps.SpaceTimeKey(row=<span class="number">1</span>, col=<span class="number">1</span>, instant=instant), tile)]</span><br><span class="line"></span><br><span class="line">rdd = pysc.parallelize(layer)</span><br><span class="line"></span><br><span class="line">extent = gps.Extent(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">33.0</span>, <span class="number">33.0</span>)</span><br><span class="line">layout = gps.TileLayout(<span class="number">2</span>, <span class="number">2</span>, <span class="number">512</span>, <span class="number">512</span>)</span><br><span class="line">bounds = gps.Bounds(gps.SpaceTimeKey(col=<span class="number">0</span>, row=<span class="number">0</span>, instant=instant), gps.SpaceTimeKey(col=<span class="number">1</span>, row=<span class="number">1</span>, instant=instant))</span><br><span class="line">layout_definition = gps.LayoutDefinition(extent, layout)</span><br><span class="line"></span><br><span class="line">metadata = gps.Metadata(</span><br><span class="line">    bounds=bounds,</span><br><span class="line">    crs=<span class="string">&#x27;+proj=merc +lon_0=0 +k=1 +x_0=0 +y_0=0 +a=6378137 +b=6378137 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs &#x27;</span>,</span><br><span class="line">    cell_type=<span class="string">&#x27;float32ud-1.0&#x27;</span>,</span><br><span class="line">    extent=extent,</span><br><span class="line">    layout_definition=layout_definition)</span><br><span class="line"></span><br><span class="line">space_time_tiled_layer = gps.TiledRasterLayer.from_numpy_rdd(layer_type=gps.LayerType.SPACETIME,</span><br><span class="line">                                 numpy_rdd=rdd, metadata=metadata)</span><br><span class="line">space_time_tiled_layer</span><br></pre></td></tr></table></figure>
<h4 id="使用TiledRasterLayers"><a href="#使用TiledRasterLayers" class="headerlink" title="使用TiledRasterLayers"></a>使用TiledRasterLayers</h4><p>本节将介绍在<code>TiledRasterLayer</code>中找到的方法。就像使用<code>RasterLayer</code>一样，但是也不会介绍该类中的所有方法。<a href="">在GeoPySpark可视化数据</a>中可以找到更多关于处理层内容可视化的方法的信息。</p>
<h5 id="转换为一个Python-RDD"><a href="#转换为一个Python-RDD" class="headerlink" title="转换为一个Python RDD"></a>转换为一个Python RDD</h5><p>通过使用<strong>to_numpy_rdd()</strong> ，基本的<code>TiledRasterLayer</code>将被序列化为Python <code>RDD</code>。这将把每个元组中的所有第一个值转换为<code>SpatialKey</code>或<code>SpaceTimeKey</code>，第二个值转换为<code>Tile</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python_rdd = tiled_raster_layer.to_numpy_rdd()</span><br><span class="line">python_rdd.first()</span><br></pre></td></tr></table></figure>
<h5 id="SpaceTime-Layer转换为Spatial-Layer"><a href="#SpaceTime-Layer转换为Spatial-Layer" class="headerlink" title="SpaceTime Layer转换为Spatial Layer"></a>SpaceTime Layer转换为Spatial Layer</h5><p>如果使用的是一个时空层，并且希望将其转换为一个空间层，那么可以使用<strong>to_spatial_layer()</strong> 方法。这将通过将<code>SpaceTimeKey</code>转换为<code>SpatialKey</code>来更改层中<code>RDD</code>的键。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Converting the SpaceTime layer to a Spatial layer</span></span><br><span class="line">space_time_tiled_layer.to_spatial_layer()</span><br></pre></td></tr></table></figure>
<ol>
<li><p>重新分区</p>
<p>虽然不是<code>RDD</code>，但<code>TiledRasterLayer</code>确实包含底层<code>RDD</code>，因此可以使用<strong>repartition()</strong> 方法对其进行重新分区。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Repartition the internal RDD to have 120 partitions</span></span><br><span class="line">tiled_raster_layer.repartition(num_partitions=<span class="number">120</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>查找</p>
<p>如果该层中存在感兴趣的特定平铺，可以使用<strong>lookup()</strong> 方法将其作为<code>Tile</code>检索。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">min_key = tiled_raster_layer.layer_metadata.bounds.minKey</span><br><span class="line"></span><br><span class="line"><span class="comment"># Retrieve the Tile that is located at the smallest column and row of the layer</span></span><br><span class="line">tiled_raster_layer.lookup(col=min_key.col, row=min_key.row)</span><br></pre></td></tr></table></figure></li>
<li><p>掩码</p>
<p>通过使用<strong>mask()</strong> 方法，可以使用一个或多个形状几何图形对·TiledRasterRDD·进行掩码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">layer_extent = tiled_raster_layer.layer_metadata.extent</span><br><span class="line"></span><br><span class="line"><span class="comment"># Polygon to mask a region of the layer</span></span><br><span class="line">mask = box(layer_extent.xmin,</span><br><span class="line">           layer_extent.ymin,</span><br><span class="line">           layer_extent.xmin + <span class="number">20</span>,</span><br><span class="line">           layer_extent.ymin + <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">tiled_raster_layer.mask(geometries=mask)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mask_2 = box(layer_extent.xmin + <span class="number">50</span>,</span><br><span class="line">             layer_extent.ymin + <span class="number">50</span>,</span><br><span class="line">             layer_extent.xmax - <span class="number">20</span>,</span><br><span class="line">             layer_extent.ymax - <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Multiple Polygons can be given to mask the layer</span></span><br><span class="line">tiled_raster_layer.mask(geometries=[mask, mask_2])</span><br></pre></td></tr></table></figure></li>
<li><p>正常化</p>
</li>
</ol>
<p>  <strong>normalize()</strong> 将对图层中的数据进行线性转换，使所有值都落在给定的范围内。<br>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Normalizes the layer so that the new min value is 0 and the new max value is 60000</span></span><br><span class="line">tiled_raster_layer.normalize(new_min=<span class="number">0</span>, new_max=<span class="number">60000</span>)</span><br></pre></td></tr></table></figure><br>5. 创建金字塔</p>
<p>   在为TMS服务器使用图层时，重要的为图层创建金字塔。也就是说，我们创建一个覆盖相同地理范围的细节层次结构，而金字塔的每一层使用的像素是下一层的四分之一。这使我们可以放大和缩小时，图层显示没有使用无关的细节。<strong>pyramid()</strong> 方法将生成一个金字塔实例，该实例将在其中包含多个<code>TiledRasterLayer</code>。每个层对应一个缩放级别，级别的数量取决于源层的<code>zoom_level</code>。<code>金字塔</code>的最大级别为源层的<code>zoom_level</code>，最小级别为0。</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># This creates a Pyramid with zoom levels that go from 0 to 11 for a total of 12.</span></span><br><span class="line">tiled_raster_layer.pyramid()</span><br></pre></td></tr></table></figure>
<ol start="6">
<li><p>重投影</p>
<p>这类似于<code>RasterLayer</code>的<strong>reproject</strong>方法，在该方法中，重新投影将不会采样超过瓦片的边界。这意味着tile的布局将会改变，因此它们将呈现<code>LocalLayout</code>而不是<code>GlobalLayout</code>。因此，无论<code>TiledRasterLayer</code>的<code>zoom_level</code>是什么，都将更改为0，因为所表示的区域只更改为tile。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The zoom_level and crs of the TiledRasterLayer before reprojecting</span></span><br><span class="line">tiled_raster_layer.zoom_level, tiled_raster_layer.layer_metadata.crs</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">reprojected_tiled_raster_layer = tiled_raster_layer.reproject(target_crs=<span class="number">3857</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># The zoom_level and crs of the TiledRasterLayer after reprojecting</span></span><br><span class="line">reprojected_tiled_raster_layer.zoom_level, reprojected_tiled_raster_layer.layer_metadata.crs</span><br></pre></td></tr></table></figure></li>
<li><p>缝合</p>
<p>使用<strong>stitch()</strong> 将<code>TiledRasterLayer</code>内的所有<code>Tile</code>缝合在一起，得到一个<code>Tile</code>。这只能在空间层中完成，如果层中包含的数据很大，则不建议这样做，因为它可能会由于结果块的大小而导致崩溃。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Creates a Tile with an underlying numpy array with a size of (1, 6144, 1536).</span></span><br><span class="line">tiled_raster_layer.stitch().cells.shape</span><br></pre></td></tr></table></figure></li>
<li><p>保存一个缝合的图层</p>
</li>
</ol>
<p>  <strong>save_stitched()</strong> 方法既可以缝合，也可以将层保存为GeoTiff。<br>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Saves the stitched layer to /tmp/stitched.tif</span></span><br><span class="line">tiled_raster_layer.save_stitched(path=<span class="string">&#x27;./stitched.tif&#x27;</span>)</span><br></pre></td></tr></table></figure><br>  也可以指定缝制层时要保存的区域。</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">layer_extent = tiled_raster_layer.layer_metadata.layout_definition.extent</span><br><span class="line"></span><br><span class="line"><span class="comment"># Only a portion of the stitched layer needs to be saved, so we will create a sub Extent to crop to.</span></span><br><span class="line">sub_exent = gps.Extent(xmin=layer_extent.xmin + <span class="number">10</span>,</span><br><span class="line">                     ymin=layer_extent.ymin + <span class="number">10</span>,</span><br><span class="line">                     xmax=layer_extent.xmax - <span class="number">10</span>,</span><br><span class="line">                     ymax=layer_extent.ymax - <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">tiled_raster_layer.save_stitched(path=<span class="string">&#x27;./cropped-stitched.tif&#x27;</span>, crop_bounds=sub_exent)</span><br></pre></td></tr></table></figure>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># In addition to the sub Extent, one can also choose how many cols and rows will be in the saved in the GeoTiff.</span></span><br><span class="line">tiled_raster_layer.save_stitched(path=<span class="string">&#x27;./cropped-stitched-2.tif&#x27;</span>,</span><br><span class="line">                               crop_bounds=sub_exent,</span><br><span class="line">                               crop_dimensions=(<span class="number">1000</span>, <span class="number">1000</span>))</span><br></pre></td></tr></table></figure>
<ol start="9">
<li><p>将tile数据转换为Layout</p>
<p>这类似于<code>RasterLayer</code>的<strong>tile_to_layout</strong>方法，除了一个重要的细节。如果在包含<code>zoom_level</code>的<code>TiledRasterLayer</code>上执行<strong>tile_to_layout()</strong> ，该<code>zoom_level</code>可能会丢失或更改，这取决于选择的<code>layout</code>和<code>target_crs</code>。因此，在重新排列<code>TiledRasterLayer</code>时，一定要记住这一点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Original zoom_level of the source TiledRasterLayer</span></span><br><span class="line">tiled_raster_layer.zoom_level</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># zoom_level will be lost in the resulting TiledRasterlayer</span></span><br><span class="line">tiled_raster_layer.tile_to_layout(layout=gps.LocalLayout())</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># zoom_level will be changed in the resulting TiledRasterLayer</span></span><br><span class="line">tiled_raster_layer.tile_to_layout(layout=gps.GlobalLayout(), target_crs=<span class="number">3857</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># zoom_level will reamin the same in the resulting TiledRasterLayer</span></span><br><span class="line">tiled_raster_layer.tile_to_layout(layout=gps.GlobalLayout(zoom=<span class="number">11</span>))</span><br></pre></td></tr></table></figure></li>
<li><p>获取点值</p>
</li>
</ol>
<p>  **get_point_values()**接受<code>shapely.geometry.Point</code>。返回图层中给定点的值。返回的值的数量取决于值的波段，因为每个波段将有一个值。</p>
<p>  也可以将<code>ResampleMethod</code>传递给此方法，但不支持所有方法。下面是所有可以用来计算点值的<code>ResampleMethods</code>:</p>
<ul>
<li><p>ResampleMethod.NEAREST_NEIGHBOR</p>
</li>
<li><p>ResampleMethod.BILINEAR</p>
</li>
<li><p>ResampleMethod.CUBIC_CONVOLUTION</p>
</li>
<li><p>ResampleMethod.CUBIC_SPLINE</p>
</li>
<li><p>*从空间图层获取点值**</p>
<p> 当在<code>LayerType</code>为<code>SPATIAL</code>的图层上使用<code>get_point_values</code>时，结果将成对为<code>(shapely.geometry.Point, [float])</code>。每个给定的<code>Points</code>与它所相交的值配对。</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Creating the points</span></span><br><span class="line">extent = tiled_raster_layer.layer_metadata.extent</span><br><span class="line"></span><br><span class="line">p1 = Point(extent.xmin, extent.ymin + <span class="number">0.5</span>)</span><br><span class="line">p2 = Point(extent.xmax , extent.ymax - <span class="number">1.0</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>*从[shapely.geometry.Point]获取点值**</p>
<p> 当<code>points</code>是一个<code>[shapely.geometry.Point]</code>, 将返回一个<code>[(shapely.geometry.Point, [float])]</code>.</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tiled_raster_layer.get_point_values(points=[p1, p2])</span><br></pre></td></tr></table></figure></li>
<li><p>*从{k: shapely.geometry.Point}获取点值**</p>
<p> 当<code>points</code>是一个<code>&#123;k: shapely.geometry.Point&#125;</code>, 将返回一个<code>&#123;k: (shapely.geometry.Point, [float])&#125;</code>。</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tiled_raster_layer.get_point_values(points=&#123;<span class="string">&#x27;point 1&#x27;</span>: p1, <span class="string">&#x27;point 2&#x27;</span>: p2&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>*从时空图层获取点值**</p>
<p> 当在<code>LayerType</code>为<code>SPACETIME</code>的图层上使用<code>get_point_values</code>时，结果将成对为<code>(shapely.geometry.Point, [(datetime.datetime, [float])])</code>。每个给定的<code>Points</code>将与一个元组列表配对，其中包含与之相交的值以及这些值的相应时间戳。</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">st_extent = space_time_tiled_layer.layer_metadata.extent</span><br><span class="line"></span><br><span class="line">p1 = Point(st_extent.xmin, st_extent.ymin + <span class="number">0.5</span>)</span><br><span class="line">p2 = Point(st_extent.xmax , st_extent.ymax - <span class="number">1.0</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>*从[shapely.geometry.Point]获取点值**</p>
<p> 当<code>points</code>是一个<code>[shapely.geometry.Point]</code>, 将返回一个<code>[(shapely.geometry.Point, [(datetime.datetime, [float])])]</code>.</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">space_time_tiled_layer.get_point_values(points=[p1, p2])</span><br></pre></td></tr></table></figure></li>
<li><p>*从{k: shapely.geometry.Point}获取点值**</p>
<p> 当<code>points</code>是一个<code>&#123;k: shapely.geometry.Point&#125;</code>, 将返回一个<code>[(shapely.geometry.Point, [(datetime.datetime, [float])])]</code>.</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">space_time_tiled_layer.get_point_values(points=&#123;<span class="string">&#x27;point 1&#x27;</span>: p1, <span class="string">&#x27;point 2&#x27;</span>: p2&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="11">
<li>聚合每个单元格的值</li>
</ol>
<p>  <strong>aggregate_by_cell()</strong> 将为每个单元计算每个键的所有值的聚合汇总。因此，如果图层中有相同键的多个副本，那么结果图层将只包含该键的一个实例，其对应的值是共享该键的所有值的汇总。</p>
<p>  不支持所有操作。下面这些可以在aggregate_by_cell中使用:</p>
<ul>
<li><p>Operation.SUM</p>
</li>
<li><p>Operation.MIN</p>
</li>
<li><p>Operation.MAX</p>
</li>
<li><p>Operation.MEAN</p>
</li>
<li><p>Operation.VARIANCE</p>
</li>
<li><p>Operation.STANDARD_DEVIATION</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">unioned_layer = gps.union(layers=[tiled_raster_layer, tiled_raster_layer + <span class="number">1</span>])</span><br><span class="line"><span class="comment">#Sum the values of the unioned_layer</span></span><br><span class="line">unioned_layer.aggregate_by_cell(operation=gps.Operation.SUM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the max value for each cell</span></span><br><span class="line">unioned_layer.aggregate_by_cell(operation=gps.Operation.MAX)</span><br></pre></td></tr></table></figure>
<h3 id="一般的方法"><a href="#一般的方法" class="headerlink" title="一般的方法"></a>一般的方法</h3><p>在<code>RasterLayer</code>和<code>TiledRasterLayer</code>中都有一些方法。这些方法倾向于执行更一般的分析/任务，因此它们适合这两个类。下一节将介绍这些方法。</p>
</li>
</ul>
<p>**注意:**在下面的示例中，将同时使用<code>RasterLayer</code>和<code>TiledRasterLayer</code>。然而，它们很容易被其他类替换。</p>
<h4 id="结合图层"><a href="#结合图层" class="headerlink" title="结合图层"></a>结合图层</h4><p>要将多层的内容组合在一起，可以使用**union()**方法。这将生成一个新的包含来自给定层的所有元素的<code>RasterLayer</code>和<code>TiledRasterLayer</code>。</p>
<p><strong>注意:</strong> 生成的层可以包含重复的键。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gps.union(layers=[tiled_raster_layer, tiled_raster_layer])</span><br></pre></td></tr></table></figure>
<h4 id="选择波段的一个子波段"><a href="#选择波段的一个子波段" class="headerlink" title="选择波段的一个子波段"></a>选择波段的一个子波段</h4><p>要选择要使用的特定波段，**bands()**方法将采用单个波段索引或波段索引集合，并将该子集作为新的<code>RasterLayer</code>和<code>TiledRasterLayer</code>返回。</p>
<p><strong>注意:</strong> 如果在一个大数据集的两个子带之间执行操作，可能会有很高的性能成本。因此，如果您正在处理大量数据，那么建议在读取它们之前进行波段选择。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Selecting the second band from the layer</span></span><br><span class="line">multiband_raster_layer.bands(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Selecting the first and second bands from the layer</span></span><br><span class="line">multiband_raster_layer.bands([<span class="number">0</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<h4 id="两个或更多层的波段组合"><a href="#两个或更多层的波段组合" class="headerlink" title="两个或更多层的波段组合"></a>两个或更多层的波段组合</h4><p><strong>combine_bands()</strong> 方法将连接两个或多个层之间共享键值的波段。因此，结果图层将为每个共享键值包含一个新的Tile, Tile将包含来自给定层的所有波段。</p>
<p>图层传递到<code>combine_bands</code>的顺序很重要。其中，结果值的波段将根据其各自层的位置进行排序。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Setting up example RDD</span></span><br><span class="line">twos = np.ones((<span class="number">1</span>, <span class="number">16</span>, <span class="number">16</span>), dtype=<span class="string">&#x27;int&#x27;</span>) + <span class="number">1</span></span><br><span class="line">twos_tile = gps.Tile.from_numpy_array(numpy_array=np.array(twos), no_data_value=-<span class="number">500</span>)</span><br><span class="line"></span><br><span class="line">twos_rdd = pysc.parallelize([(projected_extent, twos_tile)])</span><br><span class="line">twos_raster_layer = gps.RasterLayer.from_numpy_rdd(layer_type=gps.LayerType.SPATIAL, numpy_rdd=twos_rdd)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The resulting values of the layer will have 2 bands: the first will be all ones,</span></span><br><span class="line"><span class="comment"># and the last band will be all twos</span></span><br><span class="line">gps.combine_bands(layers=[multiband_raster_layer, twos_raster_layer])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The resulting values of the layer will have 2 bands: the first will be all twos and the</span></span><br><span class="line"><span class="comment"># other band will be all ones</span></span><br><span class="line">gps.combine_bands(layers=[twos_raster_layer, multiband_raster_layer])</span><br></pre></td></tr></table></figure>
<h4 id="收集图层的键值"><a href="#收集图层的键值" class="headerlink" title="收集图层的键值"></a>收集图层的键值</h4><p>要收集一个层的所有键，使用<strong>collect_keys</strong>方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Returns a list of ProjectedExtents</span></span><br><span class="line">multiband_raster_layer.collect_keys()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Returns a list of a SpatialKeys</span></span><br><span class="line">tiled_raster_layer.collect_keys()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Returns a list of SpaceTimeKeys</span></span><br><span class="line">space_time_tiled_layer.collect_keys()</span><br></pre></td></tr></table></figure>
<h4 id="按时间过滤图层"><a href="#按时间过滤图层" class="headerlink" title="按时间过滤图层"></a>按时间过滤图层</h4><p>使用<code>filter_by_times</code>方法将生成一个值位于给定时间间隔内的层。</p>
<h5 id="按精确时间过滤"><a href="#按精确时间过滤" class="headerlink" title="按精确时间过滤"></a>按精确时间过滤</h5><p>一个<code>datetime.datetime</code>实例可用于过滤该层。如果是这样，那么只保留与给定时间的精确匹配。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">space_time_layer.filter_by_times(time_intervals=[instant])</span><br></pre></td></tr></table></figure>
<h5 id="按时间间隔过滤"><a href="#按时间间隔过滤" class="headerlink" title="按时间间隔过滤"></a>按时间间隔过滤</h5><p>也可以给出不同的时间间隔，任何时间落在时间跨度内的键都将保存在层中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">end_date_1 = instant + datetime.timedelta(days=<span class="number">3</span>)</span><br><span class="line">end_date_2 = instant + datetime.timedelta(days=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Will filter out any value whose key does not fall in the range of</span></span><br><span class="line"><span class="comment"># instant and end_date_1</span></span><br><span class="line">space_time_layer.filter_by_times(time_intervals=[instant, end_date_1])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Will filter out any value whose key does not fall in the range of</span></span><br><span class="line"><span class="comment"># instant and end_date_1 OR whose key does not match end_date_2</span></span><br><span class="line">space_time_layer.filter_by_times(time_intervals=[instant, end_date_1, end_date_2])</span><br></pre></td></tr></table></figure>
<h4 id="转换光栅单元格的数据类型"><a href="#转换光栅单元格的数据类型" class="headerlink" title="转换光栅单元格的数据类型"></a>转换光栅单元格的数据类型</h4><p><strong>convert_data_type</strong> 方法将图层的栅格中的单元格类型转换为新的数据类型。在此转换期间还可以设置<code>noData</code>值，如果没有设置，则生成的栅格数据将没有<code>noData</code>值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The data type of the cells before converting</span></span><br><span class="line">metadata.cell_type</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Changing the cell type to int8 with a noData value of -100.</span></span><br><span class="line">raster_layer.convert_data_type(new_type=gps.CellType.INT8, no_data_value=-<span class="number">100</span>).collect_metadata().cell_type</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Changing the cell type to int32 with no noData value.</span></span><br><span class="line">raster_layer.convert_data_type(new_type=gps.CellType.INT32).collect_metadata().cell_type</span><br></pre></td></tr></table></figure>
<h4 id="重新分类单元的值"><a href="#重新分类单元的值" class="headerlink" title="重新分类单元的值"></a>重新分类单元的值</h4><p>根据给定的<code>value_map</code>和<code>classification_strategy</code>对单元格值进行<code>reclassify</code>。除了这两个参数外，还需要给出单元格的<code>data_type</code>, 格式是<code>int</code>或者<code>float</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Values of the first tile before being reclassified</span></span><br><span class="line">multiband_raster_layer.to_numpy_rdd().first()[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Change all values greater than or equal to 1 to 10</span></span><br><span class="line">reclassified = multiband_raster_layer.reclassify(value_map=&#123;<span class="number">1</span>: <span class="number">10</span>&#125;,</span><br><span class="line">                                                 data_type=<span class="built_in">int</span>,</span><br><span class="line">                                                 classification_strategy=gps.ClassificationStrategy.GREATER_THAN_OR_EQUAL_TO)</span><br><span class="line">reclassified.to_numpy_rdd().first()[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h4 id="将图层的值合并在一起"><a href="#将图层的值合并在一起" class="headerlink" title="将图层的值合并在一起"></a>将图层的值合并在一起</h4><p>通过使用<strong>merge</strong>方法，将图层中共享一个Key值的所有值合并在一起，形成一个新的单值。这是通过用一个值替换另一个值的单元格来实现的。然而，并非所有的单元格(如果有的话)都可以被替换。在合并值的单元格时，将采取以下步骤来确定是否应该更改单元格的值:</p>
<ol>
<li>如果单元格包含<code>NoData</code>值，则将替换该值。</li>
<li>如果没有设置<code>NoData</code>值，那么将替换vlue为0的单元格。</li>
<li>如果以上两个都不为真，则单元格保留其值。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Creating the layers</span></span><br><span class="line">no_data = np.full((<span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>), -<span class="number">1</span>)</span><br><span class="line">zeros = np.zeros((<span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_layer</span>(<span class="params">no_data_value=<span class="literal">None</span></span>):</span></span><br><span class="line">    data_tile = gps.Tile.from_numpy_array(numpy_array=no_data, no_data_value=no_data_value)</span><br><span class="line">    zeros_tile = gps.Tile.from_numpy_array(numpy_array=zeros, no_data_value=no_data_value)</span><br><span class="line"></span><br><span class="line">    layer_rdd = pysc.parallelize([(projected_extent, data_tile), (projected_extent, zeros_tile)])</span><br><span class="line">    <span class="keyword">return</span> gps.RasterLayer.from_numpy_rdd(layer_type=gps.LayerType.SPATIAL, numpy_rdd=layer_rdd)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Resulting layer has a no_data_value of -1</span></span><br><span class="line">no_data_layer = create_layer(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Resutling layer has no no_data_value</span></span><br><span class="line">no_no_data_layer = create_layer()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The resulting merged value will be all zeros since -1 is the noData value</span></span><br><span class="line">no_data_layer.merge()</span><br><span class="line"></span><br><span class="line"><span class="comment"># The resulting merged value will be all -1&#x27;s as ``no_data_value`` was set.</span></span><br><span class="line">no_no_data_layer.merge()</span><br></pre></td></tr></table></figure>
<h4 id="单元格映射"><a href="#单元格映射" class="headerlink" title="单元格映射"></a>单元格映射</h4><p>可以通过<strong>map_cells</strong>方法直接处理图层中的单元格。该方法接受一个函数，该函数期望一个numpy数组和一个noData值作为参数，并返回一个新的numpy数组。因此，给出的函数具有以下类型签名:<br><code>def input_function(numpy_array: np.ndarray, no_data_value=None) -&gt; np.ndarray</code><br>然后将给定的函数应用于层中的每个<code>Tile</code>。</p>
<p><strong>注意:</strong> 为了使该方法能够运行，首先需要将内部<code>RDD</code>从Scala反序列化到Python，然后将其从Python序列化回Scala。因此，建议将所有函数链接在一起，以避免不必要的序列化开销。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_one</span>(<span class="params">cells, _</span>):</span></span><br><span class="line">    <span class="keyword">return</span> cells + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Mapping with a single funciton</span></span><br><span class="line">raster_layer.map_cells(add_one)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">divide_two</span>(<span class="params">cells, _</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (add_one(cells) / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Chaning together two functions to be mapped</span></span><br><span class="line">raster_layer.map_cells(divide_two)</span><br></pre></td></tr></table></figure>
<h4 id="Tile映射"><a href="#Tile映射" class="headerlink" title="Tile映射"></a>Tile映射</h4><p>像<code>map_cells</code>一样，<code>map_tiles</code>将给定的函数映射到图层中的所有<code>Tile</code>上。它接受一个期望<code>Tile</code>并返回<code>Tile</code>的函数。因此，输入函数的类型签名为:<br><code>def input_function(tile: Tile) -&gt; Tile</code><br><strong>注意:</strong> 为了使该方法能够运行，首先需要将内部<code>RDD</code>从Scala反序列化到Python，然后将其从Python序列化回Scala。因此，建议将所有函数链接在一起，以避免不必要的序列化开销。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minus_two</span>(<span class="params">tile</span>):</span></span><br><span class="line">    <span class="keyword">return</span> gps.Tile.from_numpy_array(tile.cells - <span class="number">2</span>, no_data_value=tile.no_data_value)</span><br><span class="line"></span><br><span class="line">raster_layer.map_tiles(minus_two)</span><br></pre></td></tr></table></figure>
<h4 id="计算图层的直方图"><a href="#计算图层的直方图" class="headerlink" title="计算图层的直方图"></a>计算图层的直方图</h4><p>可以使用<strong>get_histogram</strong>或<strong>get_class_histogram</strong>方法计算图层的直方图。这两种方法都生成直方图，但是，在生成的直方图中表示数据的方式因使用的方法不同而不同。<code>get_histogram</code>将生成一个值为<code>float</code>的直方图。而<code>get_class_histogram</code>返回的直方图的值为<code>int</code>。</p>
<p>有关直方图类的更多信息，请参见直方图[指南]。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Returns a Histogram whose underlying values are floats</span></span><br><span class="line">tiled_raster_layer.get_histogram()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Returns a Histogram whose underlying values are ints</span></span><br><span class="line">tiled_raster_layer.get_class_histogram()</span><br></pre></td></tr></table></figure>
<h4 id="找到图层的分位数"><a href="#找到图层的分位数" class="headerlink" title="找到图层的分位数"></a>找到图层的分位数</h4><p>如果希望找到没有直方图的图层的分位数断点，那么可以使用<strong>get_quantile_breaks</strong>方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tiled_raster_layer.get_quantile_breaks(num_breaks=<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<h5 id="分位数为精确整数"><a href="#分位数为精确整数" class="headerlink" title="分位数为精确整数"></a>分位数为精确整数</h5><p><strong>get_quantile_breaks_exact_int</strong>是<strong>get_quantile_break_breaks_exact_int</strong> 的另一个版本，它可以精确计算整数值。但是，如果层中有太多的值，那么可能会发生内存错误。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tiled_raster_layer.get_quantile_breaks_exact_int(num_breaks=<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<h5 id="找出图层的最小值和最大值"><a href="#找出图层的最小值和最大值" class="headerlink" title="找出图层的最小值和最大值"></a>找出图层的最小值和最大值</h5><p><strong>get_min_max</strong> 方法将找到该图层的最小值和最大值。无论单元格的数据类型如何，结果总是<code>(float, float)</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tiled_raster_layer.get_min_max()</span><br></pre></td></tr></table></figure>
<h4 id="将图层转换为png"><a href="#将图层转换为png" class="headerlink" title="将图层转换为png"></a>将图层转换为png</h4><p>通过<strong>to_png_rdd</strong>方法，可以将图层中的值转换为字节形式的PNG。为了将每个值转换为PNG，需要提供一个<code>ColorMap</code>。</p>
<p>除了将每个值转换为PNG外，<code>(K, V)</code>的结果集合将保存在Python <code>RDD</code>中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hist = tiled_raster_layer.get_histogram()</span><br><span class="line">cmap = gps.ColorMap.build(hist, <span class="string">&#x27;viridis&#x27;</span>)</span><br><span class="line"></span><br><span class="line">png_rdd = tiled_raster_layer.to_png_rdd(color_map=cmap)</span><br><span class="line">png_rdd</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line">im = Image.<span class="built_in">open</span>(io.BytesIO(png_rdd.collect()[<span class="number">0</span>][<span class="number">1</span>]))</span><br><span class="line">im</span><br></pre></td></tr></table></figure>
<p><img src="geopyspark_layers/image.png" alt="png"></p>
<h4 id="将图层换为geotiff"><a href="#将图层换为geotiff" class="headerlink" title="将图层换为geotiff"></a>将图层换为geotiff</h4><p>类似于<strong>to_png_rdd</strong>，只有<strong>to_geotiff_rdd</strong>将返回Python <code>RDD[(K, bytes)]</code>，其中字节表示一个GeoTiff。</p>
<h5 id="选择一个StorageMethod"><a href="#选择一个StorageMethod" class="headerlink" title="选择一个StorageMethod"></a>选择一个StorageMethod</h5><p>有两种不同的方式可以格式化GeoTiff:<code>StorageMethod.STRIPED</code>或<code>StorageMethod.TILED</code>。这由<code>storage_method</code>参数表示。默认情况下,<code>StorageMethod.STRIPED</code>。</p>
<h5 id="选择片段的大小"><a href="#选择片段的大小" class="headerlink" title="选择片段的大小"></a>选择片段的大小</h5><p>有两个不同的参数控制每个段的大小:<code>rows_per_strip</code>和<code>tile_dimensions</code>。只需要设置其中一个值，这由<code>storage_method</code>是什么决定。</p>
<p>如果<code>storage_method</code>是<code>StorageMethod.STRIPED</code>。<code>rows_per_strip</code>参数将要被更改。默认情况下，将计算<code>rows_per_strip</code>，使每个strip小于或等于8K。</p>
<p>如果<code>storage_method</code>是<code>StorageMethod.TILED</code>。<code>tile_dimensions</code>可以设置。这是一个<code>(int, int)</code>，其中第一个值是<code>cols</code>的数量，第二个值是<code>rows</code>。默认情况下，<code>tile_dimensions</code>是<code>(256,256)</code>。</p>
<h5 id="选择一个CompressionMethod"><a href="#选择一个CompressionMethod" class="headerlink" title="选择一个CompressionMethod"></a>选择一个CompressionMethod</h5><p>可以选择的两种压缩类型是:<code>Compression.NO_COMPRESSION</code> 或者 <code>Compression.DEFLATE_COMPRESSION</code>。默认情况下，压缩参数设置为<code>Compression.NO_COMPRESSION</code>。</p>
<h5 id="选择一个色彩"><a href="#选择一个色彩" class="headerlink" title="选择一个色彩"></a>选择一个色彩</h5><p><code>color_space</code>参数确定在每个GeoTiff中应该如何组织颜色。默认情况下，它是<code>ColorSpace.BLACK_IS_ZERO</code>。</p>
<h5 id="传入一个颜色映射"><a href="#传入一个颜色映射" class="headerlink" title="传入一个颜色映射"></a>传入一个颜色映射</h5><p>可以传入<code>ColorMap</code>实例，以使生成的geotiff处于不同的渐变中。默认情况下，<code>color_map</code>是<code>None</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Creates an RDD[(K, bytes)] with the default parameters</span></span><br><span class="line">tiled_raster_layer.to_geotiff_rdd()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Creates an RDD whose GeoTiffs are tiled with a size of (128, 128)</span></span><br><span class="line">tiled_raster_layer.to_geotiff_rdd(storage_method=gps.StorageMethod.TILED, tile_dimensions=(<span class="number">128</span>, <span class="number">128</span>))</span><br></pre></td></tr></table></figure>
<h3 id="RDD方法"><a href="#RDD方法" class="headerlink" title="RDD方法"></a>RDD方法</h3><p>正如在<code>TiledRasterLayer</code>的重分区方法一节中所提到的，<code>TiledRasterLayer</code>的内部<code>RDD</code>有很多方法。这也适用于<code>RasterLayer</code>。</p>
<p>下面是一个<code>RDD</code>列表，其中包含两个类都支持的示例。</p>
<h5 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">raster_layer.cache()</span><br></pre></td></tr></table></figure>
<h5 id="Persist"><a href="#Persist" class="headerlink" title="Persist"></a>Persist</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># If no level is given, then MEMORY_ONLY will be used</span></span><br><span class="line">tiled_raster_layer.persist()</span><br></pre></td></tr></table></figure>
<h5 id="Unpersist"><a href="#Unpersist" class="headerlink" title="Unpersist"></a>Unpersist</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tiled_raster_layer.unpersist()</span><br></pre></td></tr></table></figure>
<h5 id="getNumberOfPartitions"><a href="#getNumberOfPartitions" class="headerlink" title="getNumberOfPartitions"></a>getNumberOfPartitions</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">raster_layer.getNumPartitions()</span><br></pre></td></tr></table></figure>
<h5 id="Count"><a href="#Count" class="headerlink" title="Count"></a>Count</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">raster_layer.count()</span><br></pre></td></tr></table></figure>
<h5 id="isEmpty"><a href="#isEmpty" class="headerlink" title="isEmpty"></a>isEmpty</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">raster_layer.isEmpty()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>BigData</category>
      </categories>
      <tags>
        <tag>BigData</tag>
      </tags>
  </entry>
  <entry>
    <title>Python下的GeoTrellis —— GeoPySpark</title>
    <url>/bigdata/geopyspark/geopyspark_intro/</url>
    <content><![CDATA[<h2 id="Python下的GeoTrellis-——-GeoPySpark"><a href="#Python下的GeoTrellis-——-GeoPySpark" class="headerlink" title="Python下的GeoTrellis —— GeoPySpark"></a>Python下的GeoTrellis —— GeoPySpark</h2><h3 id="什么是GeoPySpark"><a href="#什么是GeoPySpark" class="headerlink" title="什么是GeoPySpark"></a>什么是GeoPySpark</h3><p>GeoPySpark是Scala库GeoTrellis的Python语言库。与GeoTrellis一样，这个项目也是在Apache 2许可下发布的。</p>
<p>GeoPySpark试图利用GeoTrellis来实现对栅格数据的读取、写入和操作。因此，它能够扩展到数据，并且仍然能够很好地执行。</p>
<p>除了栅格处理，GeoPySpark还允许将栅格数据渲染成PNG。该项目的目标之一是能够以web速度处理栅格数据并对大型数据集执行批处理。</p>
<h3 id="为什么要用GeoPySpark"><a href="#为什么要用GeoPySpark" class="headerlink" title="为什么要用GeoPySpark"></a>为什么要用GeoPySpark</h3><p>Python中的处理栅格已经取得了长足的进步;然而，随着数据集大小的增加，仍然会出现问题。无论是性能还是易用性，随着越来越多的数据向公众开放，这类问题将变得更加普遍。</p>
<p>人们可以求助于地理网格来解决上述问题(并且应该尝试一下!)，但这也带来了新的挑战。Scala虽然是一门强大的语言，但它的学习曲线有些陡峭。这可能会耽误那些没有时间和/或兴趣学习一门新语言的人。</p>
<p>通过Scala的速度和可伸缩性以及Python的易用性，GeoPySpark可以解决这种困境。</p>
<h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><a id="more"></a>
<p>因为GeoPySpark是一个现有项目GeoTrellis的库，所以一些术语和数据表示形式得以延续。本节除了描述GeoPySpark中如何表示栅格类型外，还将解释这个术语。</p>
<p>在开始之前，本指南中的所有示例都需要导入一下包:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> geopyspark <span class="keyword">as</span> gps</span><br><span class="line"><span class="keyword">from</span> shapely.geometry <span class="keyword">import</span> box</span><br></pre></td></tr></table></figure>
<h4 id="栅格数据"><a href="#栅格数据" class="headerlink" title="栅格数据"></a>栅格数据</h4><p>GeoPySpark不同于其他地理空间Python库(如rasterIO)的栅格表示方式。在GeoPySpark中，它们由<code>Tile</code>类表示。该类包含一个numpy数组(称为<code>cells</code>)，除了与数据相关的其他信息外，该数组还表示格网的单元格。除了<code>cells</code>之外，Tile还可以具有栅格数据的<code>no_data_value</code>。</p>
<p><strong>注意:</strong> GeoPySpark中的所有栅格数据都可以表示为多个波段，即使原始光栅仅包含一个波段。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.array([[[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                 [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">                 [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>]]], dtype=np.int16)</span><br><span class="line"></span><br><span class="line"><span class="comment"># The resulting Tile will set -10 as the no_data_value for the raster</span></span><br><span class="line">gps.Tile.from_numpy_array(numpy_array=arr, no_data_value=-<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># The resulting Tile will have no no_data_value</span></span><br><span class="line">gps.Tile.from_numpy_array(numpy_array=arr)</span><br></pre></td></tr></table></figure>
<h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>描述栅格数据所代表的地球上的位置。这个区域是由坐标参考系中的坐标表示的。因此，根据所使用的坐标系统不同，范围的值可能会有所不同。<code>Extent</code>也可以作为一个<em>bounding box</em> 来引用。</p>
<p><strong>注意:</strong> <code>Extent</code>内的值必须是<strong>float</strong>，而不是<strong>double</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">extent = gps.Extent(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">10.0</span>, <span class="number">10.0</span>)</span><br><span class="line">extent</span><br></pre></td></tr></table></figure>
<h3 id="坐标范围"><a href="#坐标范围" class="headerlink" title="坐标范围"></a>坐标范围</h3><p><code>ProjectedExtent</code>描述了除了CRS外栅格数据在地球上所代表的区域。可以使用<strong>EPSG代码</strong>或<strong>proj4字符串</strong>来指示<code>ProjectedExtent</code>的CRS。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Using an EPSG code</span></span><br><span class="line">gps.ProjectedExtent(extent=extent, epsg=<span class="number">3857</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Using a Proj4 String</span></span><br><span class="line">proj4 = <span class="string">&quot;+proj=merc +lon_0=0 +k=1 +x_0=0 +y_0=0 +a=6378137 +b=6378137 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs &quot;</span></span><br><span class="line">gps.ProjectedExtent(extent=extent, proj4=proj4)</span><br></pre></td></tr></table></figure>
<h3 id="临时坐标范围"><a href="#临时坐标范围" class="headerlink" title="临时坐标范围"></a>临时坐标范围</h3><p>与<code>ProjectedExtent</code>类似，<strong>TemporalProjectedExtent</strong>描述栅格数据所表示的地球上的区域、CRS和数据所表示的时间。这个时间点称为<code>instant</code>，是<strong>datetime.datetime</strong> 的一个实例。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">time = datetime.datetime.now()</span><br><span class="line">gps.TemporalProjectedExtent(extent=extent, instant=time, epsg=<span class="number">3857</span>)</span><br></pre></td></tr></table></figure>
<h3 id="切片布局"><a href="#切片布局" class="headerlink" title="切片布局"></a>切片布局</h3><p><strong>TileLayout</strong>描述表示栅格如何在一个层中的组织和分类。<strong>layoutCols</strong>和<strong>layoutRows</strong>分别详细说明了网格本身有多少列和行。而<strong>tileCols</strong>和<strong>tileRows</strong> 表示每个栅格具有多少列和行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Describes a layer where there are four rasters in a 2x2 grid. Each raster has 256 cols and rows.</span></span><br><span class="line">tile_layout = gps.TileLayout(layoutCols=<span class="number">2</span>, layoutRows=<span class="number">2</span>, tileCols=<span class="number">256</span>, tileRows=<span class="number">256</span>)</span><br><span class="line">tile_layout</span><br></pre></td></tr></table></figure>
<h3 id="Layout定义"><a href="#Layout定义" class="headerlink" title="Layout定义"></a>Layout定义</h3><p><code>LayoutDefinition</code>描述了栅格数据在一个层中的组织方式以及栅格所覆盖的区域。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">layout_definition = gps.LayoutDefinition(extent=extent, tileLayout=tile_layout)</span><br><span class="line">layout_definition</span><br></pre></td></tr></table></figure>
<h3 id="切片策略"><a href="#切片策略" class="headerlink" title="切片策略"></a>切片策略</h3><p>通常情况下，层的布局是未知的。这里有两种不同的瓦片生成策略，它们将根据给定的数据生成布局，而不是费力地找出最优布局。</p>
<h4 id="局部策略"><a href="#局部策略" class="headerlink" title="局部策略"></a>局部策略</h4><p><code>LocalLayout</code>是第一种瓦片生成策略，它生成的布局是在给定瓦片大小的层内的所有像素上构建网格。生成的布局将匹配栅格内单元格的原始分辨率。</p>
<p><strong>注意:</strong> 此布局<strong>不能用于创建显示层。相反，它最好用于将执行操作和分析的层。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Creates a LocalLayout where each tile within the grid will be 256x256 pixels.</span></span><br><span class="line">gps.LocalLayout()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Creates a LocalLayout where each tile within the grid will be 512x512 pixels.</span></span><br><span class="line">gps.LocalLayout(tile_size=<span class="number">512</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Creates a LocalLayout where each tile within the grid will be 256x512 pixels.</span></span><br><span class="line">gps.LocalLayout(tile_cols=<span class="number">256</span>, tile_rows=<span class="number">512</span>)</span><br></pre></td></tr></table></figure>
<h4 id="全局策略"><a href="#全局策略" class="headerlink" title="全局策略"></a>全局策略</h4><p>另一种切片生成策略是<code>GlobalLayout</code>，即在全局范围CRS上构建网格。结果层的单元格分辨率乘以CRS的2次方。因此，使用这种策略将导致原始栅格数据的向上或向下采样。</p>
<p><strong>注意:</strong> 这种布局策略<strong>应该使用当结果层要在TMS服务器中展现。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Creates a GobalLayout instance with the default values</span></span><br><span class="line">gps.GlobalLayout()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Creates a GlobalLayout instance for a zoom of 12</span></span><br><span class="line">gps.GlobalLayout(zoom=<span class="number">12</span>)</span><br></pre></td></tr></table></figure>
<p>可以从上面的两个示例中注意到，<code>GlobalLayout</code>默认情况创建布局时下不会给定的缩放级别。相反，它根据栅格内单元格的大小决定缩放的大小。如果希望为特定的缩放级别创建布局，则必须设置<code>zoom</code>参数。</p>
<h3 id="SpatialKey"><a href="#SpatialKey" class="headerlink" title="SpatialKey"></a>SpatialKey</h3><p><code>SpatialKey</code>描述栅格在布局网格中的位置。这个网格是一个二维平面，其中栅格的位置由一对坐标<strong>col</strong>和<strong>row</strong>分别表示。顾名思义，<code>SpatialKey</code>只处理空间数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gps.SpatialKey(col=<span class="number">0</span>, row=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="SpaceTimeKey"><a href="#SpaceTimeKey" class="headerlink" title="SpaceTimeKey"></a>SpaceTimeKey</h3><p>和<code>SpatialKeys</code>一样，<strong>SpaceTimeKeys</strong>描述栅格在布局中的位置。然而，网格是一个三维平面，其中光栅的位置由一对坐标<strong>col</strong>和<strong>row</strong>表示，以及一个表示时间点<strong>instant</strong>的z值表示。与<strong>TemporalProjectedExtent</strong>中的<strong>instant</strong>类似，这也是<strong>datetime.datetime</strong>的一个实例。因此，<strong>SpaceTimeKeys</strong> 处理时空数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">time = datetime.datetime.now()</span><br><span class="line">gps.SpaceTimeKey(col=<span class="number">0</span>, row=<span class="number">0</span>, instant=time)</span><br></pre></td></tr></table></figure>
<h3 id="界限"><a href="#界限" class="headerlink" title="界限"></a>界限</h3><p><code>Bounds</code>表示布局网格中键的范围。它同时具有<strong>minKey</strong>和<strong>maxKey</strong>属性。根据层中的数据类型，这些键可以是<strong>SpatialKey</strong>或<strong>SpaceTimeKey</strong>。<strong>minKey</strong>是网格中最左边的单元格，<strong>maxKey</strong> 是网格中最右边的单元格。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Creating a Bounds from SpatialKeys</span></span><br><span class="line"></span><br><span class="line">min_spatial_key = gps.SpatialKey(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">max_spatial_key = gps.SpatialKey(<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line">bounds = gps.Bounds(min_spatial_key, max_spatial_key)</span><br><span class="line">bounds</span><br><span class="line"></span><br><span class="line"><span class="comment"># Creating a Bounds from SpaceTimeKeys</span></span><br><span class="line">min_space_time_key = gps.SpaceTimeKey(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1.0</span>)</span><br><span class="line">max_space_time_key = gps.SpaceTimeKey(<span class="number">10</span>, <span class="number">10</span>, <span class="number">1.0</span>)</span><br><span class="line">gps.Bounds(min_space_time_key, max_space_time_key)</span><br></pre></td></tr></table></figure>
<h3 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h3><p><strong>元数据</strong>包含层中值的信息。这些数据属于层中包含的数据的布局、投影和范围。</p>
<p>下面的示例展示了如何手工构造元数据，但是，这几乎从来不需要，而且可以使用更简单的方法生成元数据。对于<code>RasterLayer</code>，可以调用方法**collect_metadata()**，而<code>TiledRasterLayer</code>具有属性<code>layer_metadata</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Creates Metadata for a layer with rasters that have a cell type of int16 with the previously defined</span></span><br><span class="line"><span class="comment"># bounds, crs, extent, and layout definition.</span></span><br><span class="line">gps.Metadata(bounds=bounds,</span><br><span class="line">             crs=proj4,</span><br><span class="line">             cell_type=gps.CellType.INT16.value,</span><br><span class="line">             extent=extent,</span><br><span class="line">             layout_definition=layout_definition)</span><br></pre></td></tr></table></figure>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p><strong>特性</strong> 是带有某种关联元数据的形状几何图形。这种类型的主要目的是提供一种栅格化具有不同单元格值和可能重叠的多个几何图形的方法。</p>
<h4 id="单元值"><a href="#单元值" class="headerlink" title="单元值"></a>单元值</h4><p>在实践中，一个<code>Feature</code>可以具有任何类型的元数据，但是<strong>CellValue</strong>需要与要栅格化的特性一起使用。<strong>CellValue</strong>有两个参数:<strong>value</strong>和<strong>zindex</strong>。<strong>value</strong>是与<strong>Feature</strong>的几何形状相交的所有单元格的值。<strong>Feature</strong>的<strong>zindex</strong>决定一个单元格在多个几何图形相交时的值。<strong>zindex</strong> 越高，优先级越高。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">geom1 = box(<span class="number">0</span>, <span class="number">0</span>, <span class="number">15</span>, <span class="number">15</span>)</span><br><span class="line">geom2 = box(<span class="number">100</span>, <span class="number">26</span>, <span class="number">109</span>, <span class="number">208</span>)</span><br><span class="line">geom3 = box(<span class="number">610</span>, <span class="number">215</span>, <span class="number">1000</span>, <span class="number">500</span>)</span><br><span class="line"></span><br><span class="line">cell_value1 = gps.CellValue(value=<span class="number">1</span>, zindex=<span class="number">1</span>)</span><br><span class="line">cell_value2 = gps.CellValue(value=<span class="number">2</span>, zindex=<span class="number">2</span>)</span><br><span class="line">cell_value3 = gps.CellValue(value=<span class="number">3</span>, zindex=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Will not be selected if feature2 and/or feature3 also intersects target cell</span></span><br><span class="line">feature1 = gps.Feature(geometry=geom1, properties=cell_value1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Will not be selected if feature3 also intersects target cell</span></span><br><span class="line">feature2 = gps.Feature(geometry=geom2, properties=cell_value2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Will always be selected</span></span><br><span class="line">feature3 = gps.Feature(geometry=geom3, properties=cell_value3)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>BigData</category>
      </categories>
      <tags>
        <tag>BigData</tag>
      </tags>
  </entry>
  <entry>
    <title>在PySpark下使用Pandas和Apache Arrow</title>
    <url>/bigdata/pyspark_pandas_apachearrow/</url>
    <content><![CDATA[<h2 id="在PySpark下使用Pandas和Apache-Arrow"><a href="#在PySpark下使用Pandas和Apache-Arrow" class="headerlink" title="在PySpark下使用Pandas和Apache Arrow"></a>在PySpark下使用Pandas和Apache Arrow</h2><h3 id="在PySpark下的Apache-Arrow"><a href="#在PySpark下的Apache-Arrow" class="headerlink" title="在PySpark下的Apache Arrow"></a>在PySpark下的Apache Arrow</h3><p>Apache Arrow是一种内存中的列式数据格式，在Spark中用于在JVM和Python进程之间高效地传输数据。目前，这对于使用panda/NumPy数据的Python用户最为有利。它的使用不是自动的，可能需要对配置或代码进行一些细微的更改，以充分利用和确保兼容性。本指南将对如何在Spark中使用Apache Arrow进行高级描述，并突出显示在处理启用箭头的数据时的任何差异。</p>
<h3 id="确保PyArrow安装"><a href="#确保PyArrow安装" class="headerlink" title="确保PyArrow安装"></a>确保PyArrow安装</h3><p>如果使用pip安装PySpark，那么可以使用命令<code>pip install PySpark</code>将PyArrow作为SQL模块的额外依赖项引入。否则，必须确保在所有集群节点上安装并可用PyArrow。当前支持的版本是0.8.0。您可以从conda-forge通道使用pip或conda进行安装。有关详细信息，请参见PyArrow<a href="https://arrow.apache.org/docs/python/install.html">安装</a>。</p>
<h3 id="支持与Pandas的相互转换"><a href="#支持与Pandas的相互转换" class="headerlink" title="支持与Pandas的相互转换"></a>支持与Pandas的相互转换</h3><a id="more"></a>
<p>在使用<code>toPandas()</code>调用将Spark DataFrame转换为panda DataFrame时，以及在使用<code>createDataFrame(pandas_df)</code>从panda DataFrame创建Spark DataFrame时，可以使用Arrow进行优化。要在执行这些调用时使用Arrow，用户需要首先设置Spark配置的<strong>Spark.sql.execute.Arrow.enabled</strong>为<strong>true</strong>“。这是默认禁用的。</p>
<p>此外，“spark.sql.execute.arrow.enabled”还支持优化。如果在Spark中实际计算之前发生错误，可以自动退回到非箭头优化实现。这可以通过“spark.sql.execute.arrow.fallback.enabled”来控制。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable Arrow-based columnar data transfers</span></span><br><span class="line">spark.conf.<span class="built_in">set</span>(<span class="string">&quot;spark.sql.execution.arrow.enabled&quot;</span>, <span class="string">&quot;true&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Generate a Pandas DataFrame</span></span><br><span class="line">pdf = pd.DataFrame(np.random.rand(<span class="number">100</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a Spark DataFrame from a Pandas DataFrame using Arrow</span></span><br><span class="line">df = spark.createDataFrame(pdf)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Convert the Spark DataFrame back to a Pandas DataFrame using Arrow</span></span><br><span class="line">result_pdf = df.select(<span class="string">&quot;*&quot;</span>).toPandas()</span><br></pre></td></tr></table></figure>
<p>使用上述优化将产生与未启用Arrow时相同的结果。注意，即使使用Arrow，<code>toPandas()</code>也会将DataFrame中的所有记录收集到驱动程序中，并且应该对数据的一小部分进行收集。当前不支持所有Spark数据类型，如果列为不受支持的类型，可能会引发错误，请参见<a href="https://spark.apache.org/docs/latest/sql-pyspark-pandas-with-arrow.html#supported-sql-types">受支持的SQL类型</a>。如果在<code>createDataFrame()</code>期间发生错误，Spark将返回来创建没有Arrow的DataFrame。</p>
<h3 id="Pandas-UDFs-向量UDFs"><a href="#Pandas-UDFs-向量UDFs" class="headerlink" title="Pandas UDFs(向量UDFs)"></a>Pandas UDFs(向量UDFs)</h3><p>Pandas UDFs是用户定义的函数，通过Spark执行，用Arrow来传输数据，而Pandas用于处理数据。Pandas UDFs是使用关键字pandas_udf作为装饰器或包装函数来定义的，不需要额外的配置。目前，有两种类型的Pandas UDFs:Scalar and Grouped Map。</p>
<h4 id="Scalar"><a href="#Scalar" class="headerlink" title="Scalar"></a>Scalar</h4><p>Scalar Pandas UDFs用于向量化标量操作。它们可以与<code>select</code>和<code>withColumn</code>等函数一起使用。Python函数应该使用<code>pandas.Serise</code>作为输入并返回一个<code>pandas.Series</code>长度相同的级数。在内部，Spark将执行Pandas UDFs方法将列分成批，并将每个批的函数作为数据的子集调用，然后将结果连接在一起。</p>
<p>下面的示例展示如何创建一个标量Pandas UDF，该标量计算两列的乘积</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> col, pandas_udf</span><br><span class="line"><span class="keyword">from</span> pyspark.sql.types <span class="keyword">import</span> LongType</span><br><span class="line"></span><br><span class="line"><span class="comment"># Declare the function and create the UDF</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiply_func</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> a * b</span><br><span class="line"></span><br><span class="line">multiply = pandas_udf(multiply_func, returnType=LongType())</span><br><span class="line"></span><br><span class="line"><span class="comment"># The function for a pandas_udf should be able to execute with local Pandas data</span></span><br><span class="line">x = pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">print(multiply_func(x, x))</span><br><span class="line"><span class="comment"># 0    1</span></span><br><span class="line"><span class="comment"># 1    4</span></span><br><span class="line"><span class="comment"># 2    9</span></span><br><span class="line"><span class="comment"># dtype: int64</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a Spark DataFrame, &#x27;spark&#x27; is an existing SparkSession</span></span><br><span class="line">df = spark.createDataFrame(pd.DataFrame(x, columns=[<span class="string">&quot;x&quot;</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Execute function as a Spark vectorized UDF</span></span><br><span class="line">df.select(multiply(col(<span class="string">&quot;x&quot;</span>), col(<span class="string">&quot;x&quot;</span>))).show()</span><br><span class="line"><span class="comment"># +-------------------+</span></span><br><span class="line"><span class="comment"># |multiply_func(x, x)|</span></span><br><span class="line"><span class="comment"># +-------------------+</span></span><br><span class="line"><span class="comment"># |                  1|</span></span><br><span class="line"><span class="comment"># |                  4|</span></span><br><span class="line"><span class="comment"># |                  9|</span></span><br><span class="line"><span class="comment"># +-------------------+</span></span><br></pre></td></tr></table></figure>
<h4 id="Grouped-Map"><a href="#Grouped-Map" class="headerlink" title="Grouped Map"></a>Grouped Map</h4><p>分组映射Pandas UDFs与<code>groupBy().apply()</code>一起使用实现了“split-apply-combine”模式。拆分-应用-合并包括三个步骤:</p>
<ul>
<li>使用<code>DataFrame.groupBy</code>将数据分成组。</li>
<li>对每个组应用一个函数。函数的输入和输出都是<code>pandas.DataFrame</code>。输入数据包含每个组的所有行和列。</li>
<li>将结果合并到一个新的<code>DataFrame</code>中。</li>
</ul>
<p>要使用<code>groupBy().apply()</code>，用户需要定义以下内容:</p>
<ul>
<li>定义每个组的计算的Python函数。</li>
<li>一个<code>StructType</code>对象或字符串，它定义输出<code>DataFrame</code>的模式。</li>
</ul>
<p>为了返回<code>pandas.DataFrame</code>的列标签：如果指定为字符串，DataFrame必须匹配已定义输出模式中的字段名，如果不是字符串，则必须按位置匹配字段数据类型，例如整数索引。.关于如何在构造<code>pandas.DataFrame</code>时对列进行标记,请看<a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.html#pandas.DataFrame">pandas.DataFrame</a>。</p>
<p>请注意，在应用该函数之前，组的所有数据都将加载到内存中。这可能导致内存不足异常，特别是在组大小不正常的情况下。<code>maxRecordsPerBatch</code>的配置并不应用于组，而是由用户来确保分组的数据适合于可用内存。</p>
<p>下面的例子展示了如何使用<code>groupby().apply()</code>从组中的每个值中减去平均值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> pandas_udf, PandasUDFType</span><br><span class="line"></span><br><span class="line">df = spark.createDataFrame(</span><br><span class="line">    [(<span class="number">1</span>, <span class="number">1.0</span>), (<span class="number">1</span>, <span class="number">2.0</span>), (<span class="number">2</span>, <span class="number">3.0</span>), (<span class="number">2</span>, <span class="number">5.0</span>), (<span class="number">2</span>, <span class="number">10.0</span>)],</span><br><span class="line">    (<span class="string">&quot;id&quot;</span>, <span class="string">&quot;v&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="meta">@pandas_udf(<span class="params"><span class="string">&quot;id long, v double&quot;</span>, PandasUDFType.GROUPED_MAP</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subtract_mean</span>(<span class="params">pdf</span>):</span></span><br><span class="line">    <span class="comment"># pdf is a pandas.DataFrame</span></span><br><span class="line">    v = pdf.v</span><br><span class="line">    <span class="keyword">return</span> pdf.assign(v=v - v.mean())</span><br><span class="line"></span><br><span class="line">df.groupby(<span class="string">&quot;id&quot;</span>).apply(subtract_mean).show()</span><br><span class="line"><span class="comment"># +---+----+</span></span><br><span class="line"><span class="comment"># | id|   v|</span></span><br><span class="line"><span class="comment"># +---+----+</span></span><br><span class="line"><span class="comment"># |  1|-0.5|</span></span><br><span class="line"><span class="comment"># |  1| 0.5|</span></span><br><span class="line"><span class="comment"># |  2|-3.0|</span></span><br><span class="line"><span class="comment"># |  2|-1.0|</span></span><br><span class="line"><span class="comment"># |  2| 4.0|</span></span><br><span class="line"><span class="comment"># +---+----+</span></span><br></pre></td></tr></table></figure>
<p>有关详细用法，请参见<a href="https://spark.apache.org/docs/latest/api/python/pyspark.sql.html#pyspark.sql.functions.pandas_udf">pyspark.sql.functions.pandas_udf</a>和<a href="https://spark.apache.org/docs/latest/api/python/pyspark.sql.html#pyspark.sql.GroupedData.apply">pyspark.sql.GroupedData.apply</a>。</p>
<h4 id="分组聚合"><a href="#分组聚合" class="headerlink" title="分组聚合"></a>分组聚合</h4><p>分组聚合Pandas UDFs类似于Spark聚合函数。分组的聚合Pandas UDFs与<code>groupBy().agg()</code>和<a href="https://spark.apache.org/docs/latest/api/python/pyspark.sql.html#pyspark.sql.Window">pyspark.sql.window</a>一起使用。它定义了来自一个或多个<code>pandas.Series</code>级数到标量值，其中每个<code>pandas.Series</code>表示组或窗口中的一列。</p>
<p>注意，这种类型的UDF不支持部分聚合，组或窗口的所有数据都将加载到内存中。此外，目前只支持分组聚合Pandas UFDs的无界窗口。</p>
<p>下面的例子展示了如何使用这种类型的UDF来计算groupBy和窗口操作的平均值:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> pandas_udf, PandasUDFType</span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> Window</span><br><span class="line"></span><br><span class="line">df = spark.createDataFrame(</span><br><span class="line">    [(<span class="number">1</span>, <span class="number">1.0</span>), (<span class="number">1</span>, <span class="number">2.0</span>), (<span class="number">2</span>, <span class="number">3.0</span>), (<span class="number">2</span>, <span class="number">5.0</span>), (<span class="number">2</span>, <span class="number">10.0</span>)],</span><br><span class="line">    (<span class="string">&quot;id&quot;</span>, <span class="string">&quot;v&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="meta">@pandas_udf(<span class="params"><span class="string">&quot;double&quot;</span>, PandasUDFType.GROUPED_AGG</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mean_udf</span>(<span class="params">v</span>):</span></span><br><span class="line">    <span class="keyword">return</span> v.mean()</span><br><span class="line"></span><br><span class="line">df.groupby(<span class="string">&quot;id&quot;</span>).agg(mean_udf(df[<span class="string">&#x27;v&#x27;</span>])).show()</span><br><span class="line"><span class="comment"># +---+-----------+</span></span><br><span class="line"><span class="comment"># | id|mean_udf(v)|</span></span><br><span class="line"><span class="comment"># +---+-----------+</span></span><br><span class="line"><span class="comment"># |  1|        1.5|</span></span><br><span class="line"><span class="comment"># |  2|        6.0|</span></span><br><span class="line"><span class="comment"># +---+-----------+</span></span><br><span class="line"></span><br><span class="line">w = Window \</span><br><span class="line">    .partitionBy(<span class="string">&#x27;id&#x27;</span>) \</span><br><span class="line">    .rowsBetween(Window.unboundedPreceding, Window.unboundedFollowing)</span><br><span class="line">df.withColumn(<span class="string">&#x27;mean_v&#x27;</span>, mean_udf(df[<span class="string">&#x27;v&#x27;</span>]).over(w)).show()</span><br><span class="line"><span class="comment"># +---+----+------+</span></span><br><span class="line"><span class="comment"># | id|   v|mean_v|</span></span><br><span class="line"><span class="comment"># +---+----+------+</span></span><br><span class="line"><span class="comment"># |  1| 1.0|   1.5|</span></span><br><span class="line"><span class="comment"># |  1| 2.0|   1.5|</span></span><br><span class="line"><span class="comment"># |  2| 3.0|   6.0|</span></span><br><span class="line"><span class="comment"># |  2| 5.0|   6.0|</span></span><br><span class="line"><span class="comment"># |  2|10.0|   6.0|</span></span><br><span class="line"><span class="comment"># +---+----+------+</span></span><br></pre></td></tr></table></figure>
<p>有关详细用法，请参见<a href="https://spark.apache.org/docs/latest/api/python/pyspark.sql.html#pyspark.sql.functions.pandas_udf">pyspark.sql.functions.pandas_udf</a></p>
<h3 id="使用笔记"><a href="#使用笔记" class="headerlink" title="使用笔记"></a>使用笔记</h3><h4 id="支持的SQL-Types"><a href="#支持的SQL-Types" class="headerlink" title="支持的SQL Types"></a>支持的SQL Types</h4><p>目前，所有Spark SQL数据类型都支持基于行的转换，仅当安装的PyArrow等于或高于0.10.0时，才支持<code>MapType</code>、<code>ArrayType</code>和<code>TimestampType</code>和<code>StructType.BinaryType</code>。</p>
<h4 id="设置Arrow-Batch大小"><a href="#设置Arrow-Batch大小" class="headerlink" title="设置Arrow Batch大小"></a>设置Arrow Batch大小</h4><p>Spark中的数据分区被转换为Arrow记录批处理，这可能会暂时导致JVM中的高内存使用。为了避免可能的内存不足异常，可以通过设置conf下的“spark.sql.execute.arrow..maxRecordsPerBatch”来调整Arrow记录批的大小。maxRecordsPerBatch”到一个整数，该整数将确定每个批处理的最大行数。默认值是每批10,000条记录。如果列数很大，则应相应地调整该值。使用此限制，每个数据分区将被分成1个或多个记录批处理。</p>
<h4 id="带有时区语义的时间戳"><a href="#带有时区语义的时间戳" class="headerlink" title="带有时区语义的时间戳"></a>带有时区语义的时间戳</h4><p>Spark内部将时间戳存储为UTC值，没有指定时区输入的时间戳数据被转换为具有微秒分辨率的本地时间到UTC。在Spark中导出或显示时间戳数据时，会话时区用于本地化时间戳值。会话时区是用配置的<code>spark.sql.session.timeZone</code>设置的。如果没有设置，则默认为JVM系统本地时区。Pandas使用<code>datetime64</code>类型，分辨率为纳秒，<code>datetime64[ns]</code>，每个列具有可选的时区。</p>
<p>当时间戳数据从Spark传输到panda时，它将被转换为纳秒，每一列将被转换为Spark会话时区，然后本地化到该时区，这将删除该时区并显示值作为本地时间。当使用时间戳列调用<code>toPandas()</code>或<code>pandas_udf</code>时，将发生这种情况。</p>
<p>当时间戳数据从Pandas传输到Spark时，它将被转换为UTC微秒。当使用panda DataFrame调用<code>createDataFrame</code>或从<code>pandas_udf</code>返回时间戳时，会发生这种情况。这些转换是自动完成的，以确保Spark将具有预期格式的数据，因此没有必要自己进行任何这些转换。任何纳秒值都将被截断。</p>
<p>请注意，标准UDF(非Pandas)将以Python datetime对象的形式加载时间戳数据，这与Pandas时间戳不同。建议在使用<code>pandas_udf</code>中的时间戳时使用panda时间序列功能，以获得最佳性能，详细信息请参见<a href="https://pandas.pydata.org/pandas-docs/stable/timeseries.html">这里</a>。</p>
]]></content>
      <categories>
        <category>BigData</category>
      </categories>
      <tags>
        <tag>BigData</tag>
      </tags>
  </entry>
  <entry>
    <title>岛屿的周长</title>
    <url>/leetcode/leetcode_perimeter_of_island/</url>
    <content><![CDATA[<h2 id="岛屿的周长"><a href="#岛屿的周长" class="headerlink" title="岛屿的周长"></a>岛屿的周长</h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。</p>
<p>网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。</p>
<p>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。</p>
<a id="more"></a>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[[0,1,0,0],</span><br><span class="line"> [1,1,1,0],</span><br><span class="line"> [0,1,0,0],</span><br><span class="line"> [1,1,0,0]]</span><br><span class="line"></span><br><span class="line">输出: 16</span><br></pre></td></tr></table></figure>
<h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>它的周长是下面图片中的 16 个黄色的边：<br><img src="leetcode_perimeter_of_island/island.png"></p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>具体实现方式如下：</p>
<ol>
<li>Python执行方案： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">islandPerimeter</span>(<span class="params">self, grid</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> grid <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(grid)</span><br><span class="line">        m = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid[i])):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> i -<span class="number">1</span> &gt;= <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">if</span> grid[i - <span class="number">1</span>][j] == <span class="number">1</span>:</span><br><span class="line">                            result += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> j - <span class="number">1</span> &gt;= <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">if</span> grid[i][j - <span class="number">1</span>] == <span class="number">1</span>:</span><br><span class="line">                            result += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> i + <span class="number">1</span> &lt; n:</span><br><span class="line">                        <span class="keyword">if</span> grid[i + <span class="number">1</span>][j] == <span class="number">1</span>:</span><br><span class="line">                            result += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> j + <span class="number">1</span> &lt; m:</span><br><span class="line">                        <span class="keyword">if</span> grid[i][<span class="number">1</span> + j] == <span class="number">1</span>:</span><br><span class="line">                            result += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count * <span class="number">4</span> - result</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>说明：</strong> 如果您有更好的解决方案或者本人写的有什么问题，请多多指教！</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>逃脱阻碍者</title>
    <url>/leetcode/leetcode_escaper/</url>
    <content><![CDATA[<h2 id="逃脱阻碍者"><a href="#逃脱阻碍者" class="headerlink" title="逃脱阻碍者"></a>逃脱阻碍者</h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>你在进行一个简化版的吃豆人游戏。你从 (0, 0) 点开始出发，你的目的地是 (target[0], target[1]) 。地图上有一些阻碍者，第 i 个阻碍者从 (ghosts[i][0], ghosts[i][1]) 出发。</p>
<p>每一回合，你和阻碍者们<strong>可以</strong>同时向东，西，南，北四个方向移动，每次可以移动到距离原位置1个单位的新位置。</p>
<p>如果你可以在任何阻碍者抓住你之前到达目的地（阻碍者可以采取任意行动方式），则被视为逃脱成功。如果你和阻碍者同时到达了一个位置（包括目的地）都不算是逃脱成功。</p>
<p>当且仅当你有可能成功逃脱时，输出<strong>True</strong>。</p>
<a id="more"></a>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p><strong>只需要计算距离离目的地远近即可</strong>，具体实现方式如下：</p>
<ol>
<li>Python执行用时44ms，执行方案： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> prices <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices) - <span class="number">1</span>):</span><br><span class="line">            diff =  prices[i + <span class="number">1</span>] - prices[i]</span><br><span class="line">            <span class="keyword">if</span> diff &gt; <span class="number">0</span>:</span><br><span class="line">                result = result + diff</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>说明：</strong> 如果您有更好的解决方案或者本人写的有什么问题，请多多指教！</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>JupyterHub的授权登录</title>
    <url>/web_programming/jupyterhub_auth/</url>
    <content><![CDATA[<h2 id="JupyterHub的授权登录"><a href="#JupyterHub的授权登录" class="headerlink" title="JupyterHub的授权登录"></a>JupyterHub的授权登录</h2><p>关于JupyterHub的安装和配置可以查看此处。现在我们来看一下JupyterHub的授权方式。<br>本人在本人中介绍两种授权方式：OAuth2和Github的授权方式，其他方式大致一样，需要的可以看<a href="https://jupyterhub.readthedocs.io/en/stable/">官网</a>介绍。</p>
<h3 id="安装授权包"><a href="#安装授权包" class="headerlink" title="安装授权包"></a>安装授权包</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3 -m pip install -i https://pypi.tuna.tsinghua.edu.cn/simple oauthenticator</span><br></pre></td></tr></table></figure>
<h3 id="Github授权"><a href="#Github授权" class="headerlink" title="Github授权"></a>Github授权</h3><ol>
<li><p>创建Github OAuth账户信息，点击<a href="https://github.com/settings/developers">Github Oauth</a>,创建信息，如下图所示：<br><img src="jupyterhub_auth/jupyterhub_register.png"></p>
</li>
<li><p>创建完后，我们进行<code>jupyterhub_config</code>文件的配置</p>
<p>vi ./jupyterhub_config.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> oauthenticator.github <span class="keyword">import</span> GitHubOAuthenticator</span><br><span class="line">c.JupyterHub.authenticator_class = GitHubOAuthenticator</span><br><span class="line">c.GitHubOAuthenticator.oauth_callback_url = <span class="string">&#x27;http[s]://[your-host]/hub/oauth_callback</span></span><br><span class="line"><span class="string">c.GitHubOAuthenticator.client_id = &#x27;</span>xxxxxxxx<span class="string">&#x27;  #</span></span><br><span class="line"><span class="string">c.GitHubOAuthenticator.client_secret = &#x27;</span>xxxxxxxx<span class="string">&#x27;  #</span></span><br><span class="line"><span class="string">c.GitHubOAuthenticator.scope = [&#x27;</span>user:email<span class="string">&#x27;] #此处设置你的用户名和邮箱</span></span><br></pre></td></tr></table></figure>
<p>此处要填写的信息，可以查看此处：<br><img src="jupyterhub_auth/jupyterhub_auth.png"></p>
</li>
<li><p>配置完，点击登录地址，可以看到此处登录信息：<br><img src="jupyterhub_auth/github_auth.png"></p>
</li>
</ol>
<h3 id="OAuth2授权"><a href="#OAuth2授权" class="headerlink" title="OAuth2授权"></a>OAuth2授权</h3><a id="more"></a>
<ol>
<li><p>创建OAuth2账户信息,获取相应的<code>oauth_callback_url</code>、<code>client_id</code>、<code>client_secret</code>等信息。</p>
</li>
<li><p>配置<code>jupyterhub_config</code>文件</p>
<p> vi ./jupyterhub_config.py</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> oauthenticator.generic <span class="keyword">import</span> GenericOAuthenticator</span><br><span class="line">c.JupyterHub.authenticator_class = GenericOAuthenticator</span><br><span class="line"></span><br><span class="line">c.GenericOAuthenticator.oauth_callback_url = <span class="string">&#x27;http://YOUR-JUPYTERHUB.com/hub/oauth_callback&#x27;</span></span><br><span class="line">c.GenericOAuthenticator.client_id = <span class="string">&#x27;CLIENT-ID&#x27;</span></span><br><span class="line">c.GenericOAuthenticator.client_secret = <span class="string">&#x27;CLIENT-SECRET-KEY&#x27;</span></span><br><span class="line">c.GenericOAuthenticator.login_service = <span class="string">&#x27;OAuth2&#x27;</span></span><br><span class="line">c.GenericOAuthenticator.userdata_url = <span class="string">&#x27;http://YOUR-MOODLE-DOMAIN.com/local/oauth/user_info&#x27;</span></span><br><span class="line">c.GenericOAuthenticator.token_url = <span class="string">&#x27;http://YOUR-MOODLE-DOMAIN.com/local/oauth/token&#x27;</span></span><br><span class="line">c.GenericOAuthenticator.userdata_method = <span class="string">&#x27;POST&#x27;</span></span><br><span class="line">c.GenericOAuthenticator.extra_params = &#123;</span><br><span class="line">    <span class="string">&#x27;scope&#x27;</span>: <span class="string">&#x27;user_info&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;client_id&#x27;</span>: <span class="string">&#x27;MOODLE-CLIENT-ID&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;client_secret&#x27;</span>: <span class="string">&#x27;MOODLE-CLIENT-SECRET-KEY&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<p> 在环境变量里面设置<code>OAUTH2_AUTHORIZE_URL</code>:</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export http://localhost:8800/auth/oauth/authorize</span><br></pre></td></tr></table></figure></li>
<li><p>配置完，点击登录地址，可以看到此处登录信息：<br><img src="jupyterhub_auth/auth2_auth.png"></p>
</li>
</ol>
<h3 id="登录后的的界面如下所示："><a href="#登录后的的界面如下所示：" class="headerlink" title="登录后的的界面如下所示："></a>登录后的的界面如下所示：</h3><p><img src="jupyterhub_auth/jupyterhub_index.png"></p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Web Programming</category>
      </categories>
      <tags>
        <tag>Python、 Web Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>JupyterHub的安装和使用</title>
    <url>/web_programming/install_jupyterhub/</url>
    <content><![CDATA[<h2 id="JupyterHub的安装和使用"><a href="#JupyterHub的安装和使用" class="headerlink" title="JupyterHub的安装和使用"></a>JupyterHub的安装和使用</h2><h3 id="JupyterHub简介"><a href="#JupyterHub简介" class="headerlink" title="JupyterHub简介"></a>JupyterHub简介</h3><p><strong>JupyterHub</strong> 一个支持多用户的<a href="https://javyxu.cn/web_programming/install_jupyter/">Jupyter Notebook</a>服务器，用于创建、管理、代理多个<code>Jupyter Notebook</code>实例。具有扩展性和可定制性。</p>
<h3 id="JupyterHub的安装"><a href="#JupyterHub的安装" class="headerlink" title="JupyterHub的安装"></a>JupyterHub的安装</h3><ol>
<li>在CentOS下安装JupyterHub<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install npm</span><br><span class="line">npm install -g configurable-http-proxy</span><br><span class="line">python3 -m pip install -i https://pypi.tuna.tsinghua.edu.cn/simple JupyterHub</span><br><span class="line">python3 -m pip install notebook</span><br></pre></td></tr></table></figure></li>
<li>启动JupyterHub<a id="more"></a>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jupyterhub -h # 可以查看帮助</span><br><span class="line">configurable-http-proxy -h</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动jupyterhub</span></span><br><span class="line">jupyterhub</span><br></pre></td></tr></table></figure>
此时，你可以看到如下信息：<br><img src="install_jupyterhub/jupyterhub_01.png"><br>然后可以通过<code>https://localhost:8000</code>来访问JupyterHub。登录界面如下图所示：<br><img src="install_jupyterhub/jupyterhub_login.png"></li>
</ol>
<p><em>说明：</em> 设置的验证方式不一样，登录的界面不一样，目前Jupyterhub支持一下几种认证方式：</p>
<table>
<thead>
<tr>
<th>认证方式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>PAMAuthenticator</td>
<td>默认的认证方式</td>
</tr>
<tr>
<td>OAuthenticator</td>
<td>OAuth + JupyterHub Authenticator = OAuthenticator认证</td>
</tr>
<tr>
<td>ldapauthenticator</td>
<td>Simple LDAP Authenticator Plugin for JupyterHub</td>
</tr>
<tr>
<td>kdcAuthenticator</td>
<td>Kerberos Authenticator Plugin for JupyterHub</td>
</tr>
<tr>
<td>本人会在本人中简单介绍默认的认证方式，后续会有其他的认证方式的简介。</td>
<td></td>
</tr>
</tbody></table>
<ol start="3">
<li><p>生成JupyterHub配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jupyterHub --generate-config</span><br></pre></td></tr></table></figure>
<p>执行完后，会在当前目录下生成这样的一个文件，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;jupyterhub_config.py</span><br></pre></td></tr></table></figure></li>
<li><p>配置Jupyter配置文件</p>
<p>vi ./jupyterhub_config.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>创建登录用户和密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adduser test</span><br><span class="line">passwd test</span><br><span class="line">Changing password for user test.</span><br><span class="line">New password:</span><br><span class="line">BAD PASSWORD: The password is shorter than 8 characters</span><br><span class="line">Retype new password:</span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br></pre></td></tr></table></figure>
<h3 id="JupyterHub的简单使用"><a href="#JupyterHub的简单使用" class="headerlink" title="JupyterHub的简单使用"></a>JupyterHub的简单使用</h3></li>
<li><p>输入刚刚创建的用户和密码进入系统，此时我们就可以使用JupyterHub，登录后的界面，如下图所示：<br><img src="install_jupyterhub/jupyterhub_index.png"><br>。</p>
</li>
</ol>
<p>此时我们可以看到，现在的界面就跟之前的jupyter的界面一样了，此时我们就可以使用多用户，来使用一台服务器上的Jupyter，不需要人人都去配置和安装一台。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Web Programming</category>
      </categories>
      <tags>
        <tag>Python、 Web Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>Jupyter的安装和使用</title>
    <url>/web_programming/install_jupyter/</url>
    <content><![CDATA[<h2 id="Jupyter的安装和使用"><a href="#Jupyter的安装和使用" class="headerlink" title="Jupyter的安装和使用"></a>Jupyter的安装和使用</h2><h3 id="Jupyter简介"><a href="#Jupyter简介" class="headerlink" title="Jupyter简介"></a>Jupyter简介</h3><p><strong>Jupyter Notebook</strong> 是一个开源的web应用程序，允许您创建和共享包含实时代码、等式、可视化和叙述性文本的文档。用途包括:数据清理和转换、数值模拟、统计建模、数据可视化、机器学习等等，解释来自于出自<a href="https://jupyter.org/">官网</a>。</p>
<p><strong>Project Jupyter</strong> 的存在是为了开发跨越数十种编程语言的开源软件、开放标准和交互式计算服务。</p>
<h3 id="Jupyter的安装"><a href="#Jupyter的安装" class="headerlink" title="Jupyter的安装"></a>Jupyter的安装</h3><a id="more"></a>
<ol>
<li><p>在CentOS下安装Jupyter</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple jupyter</span><br></pre></td></tr></table></figure></li>
<li><p>启动Jupyter</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jupyter-notebook</span><br></pre></td></tr></table></figure>
<p>启动后会生成下面信息：<br><img src="install_jupyter/jupyter_01.png"><br>此时我们只能运行在本机上，而不能在服务器上运行，若要运行在服务器上，还要进行一下配置。</p>
</li>
<li><p>生成Jupyter配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jupyter notebook --generate-config</span><br></pre></td></tr></table></figure>
<p>执行完后，会在根目录下生成这样的一个文件，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;root&#x2F;.jupyter&#x2F;jupyter_notebook_config.py</span><br></pre></td></tr></table></figure></li>
<li><p>配置Jupyter配置文件<br>在配置之前我们先来生成登录密码，生成方式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> notebook.auth <span class="keyword">import</span> passwd</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>passwd()</span><br><span class="line">Enter password:</span><br><span class="line">Verify password:</span><br><span class="line"><span class="string">&#x27;sha1:60a66c7f3847:a5f23daafbd1b350b3b0570609d1a7e279594cb1&#x27;</span></span><br></pre></td></tr></table></figure>
<p>vi /root/.jupyter/jupyter_notebook_config.py</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># The IP address the notebook server will listen on.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">c.NotebookApp.ip = <span class="string">&#x27;localhost&#x27;</span></span></span><br><span class="line">c.NotebookApp.ip = &#x27;0.0.0.0&#x27;  # 设置远程登录IP，此时为系统IP</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Hashed password to use for web authentication.</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#  To generate, type in a python/IPython shell:</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#    from notebook.auth import passwd; passwd()</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#  The string should be of the form type:salt:hashed-password.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">c.NotebookApp.password = <span class="string">&#x27;&#x27;</span></span></span><br><span class="line">c.NotebookApp.password = &#x27;sha1:60a66c7f3847:a5f23daafbd1b350b3b0570609d1a7e279594cb1&#x27;  # 设置远程登录密码，上面生成的sha码</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># The port the notebook server will listen on.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">c.NotebookApp.port = 8888</span></span><br><span class="line">c.NotebookApp.port = 8888 # 设置远程登录port，默认为8888</span><br></pre></td></tr></table></figure>
<h3 id="Jupyter的使用"><a href="#Jupyter的使用" class="headerlink" title="Jupyter的使用"></a>Jupyter的使用</h3></li>
<li><p>输入网址进行登录，如下图所示：<br><img src="install_jupyter/jupyter_login.png"><br>输入设置密码进入系统，此时我们就可以使用Jupyter。</p>
</li>
<li><p>Jupyter的简单使用,如下图所示：<br><img src="install_jupyter/jupyter_index.png"><br>如界面所示，我们可以创建<strong>Python</strong>、<strong>Text</strong>、<strong>Folder</strong>文件，以及执行<strong>Terminal</strong> 命令等。</p>
</li>
</ol>
<h3 id="Jupyter增加内核"><a href="#Jupyter增加内核" class="headerlink" title="Jupyter增加内核"></a>Jupyter增加内核</h3><p>我们在使用Jupyter过程中，可能会用到不同的内核，比如Python3和Python2的同时使用，下面我们来在只有Python3的内核下，安装Python2的内核：</p>
<ol>
<li>创建一个Python2的虚拟Python环境，关于Python虚拟环境，请查看<a href="https://javyxu.cn/python/python_virtual_env/">本文</a>，此处不再赘述。</li>
<li>安装Python内核<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple ipykernel</span><br><span class="line">python -m ipykernel install [--name kernel_name] <span class="comment"># kernel_name:Jupyter中显示内核名称</span></span><br></pre></td></tr></table></figure></li>
<li>此时我们已经在Jupyter下新增了一个Python2的内核，如下图所示：<br><img src="install_jupyter/jupyter_kernel.png"></li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
        <category>Web Programming</category>
      </categories>
      <tags>
        <tag>Python、 Web Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>买卖股票的最佳时机II</title>
    <url>/leetcode/leetcode_sell_stocks_II/</url>
    <content><![CDATA[<h2 id="买卖股票的最佳时机II"><a href="#买卖股票的最佳时机II" class="headerlink" title="买卖股票的最佳时机II"></a>买卖股票的最佳时机II</h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。</span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>本题本人用Python和C++两种方式进行实现，C++的运行时间远远超于Python，具体实现方式如下：</p>
<ol>
<li>Python执行用时44ms，执行方案： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> prices <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices) - <span class="number">1</span>):</span><br><span class="line">            diff =  prices[i + <span class="number">1</span>] - prices[i]</span><br><span class="line">            <span class="keyword">if</span> diff &gt; <span class="number">0</span>:</span><br><span class="line">                result = result + diff</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></li>
<li>C++执行用时8ms，执行方案： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(prices.size() &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i != prices.size())&#123;</span><br><span class="line">                <span class="keyword">int</span> diff = prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (diff &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    count += diff;</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>说明：</strong> 如果您有更好的解决方案或者本人写的有什么问题，请多多指教！</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark的使用</title>
    <url>/bigdata/using_spark/</url>
    <content><![CDATA[<h2 id="Spark的使用"><a href="#Spark的使用" class="headerlink" title="Spark的使用"></a>Spark的使用</h2><h3 id="起点：SparkSession"><a href="#起点：SparkSession" class="headerlink" title="起点：SparkSession"></a>起点：SparkSession</h3><p>Spark中所有功能的入口点都是<a href="https://spark.apache.org/docs/2.2.2/api/python/pyspark.sql.html#pyspark.sql.SparkSession">SparkSession</a>。要创建一个基本的<code>SparkSession</code>，只需使用<code>SparkSession.builder</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession</span><br><span class="line"></span><br><span class="line">spark = SparkSession \</span><br><span class="line">    .builder \</span><br><span class="line">    .appName(<span class="string">&quot;Python Spark SQL basic example&quot;</span>) \</span><br><span class="line">    .config(<span class="string">&quot;spark.some.config.option&quot;</span>, <span class="string">&quot;some-value&quot;</span>) \</span><br><span class="line">    .getOrCreate()</span><br></pre></td></tr></table></figure>
<p>在Spark 2.0中的SparkSession为Hive特性提供了内置支持，包括使用HiveQL编写查询、访问Hive UDF和读取Hive表数据的能力。但是要使用这些特性，不一定要安装和配置一个Hive。</p>
<h3 id="创建DataFrames"><a href="#创建DataFrames" class="headerlink" title="创建DataFrames"></a>创建DataFrames</h3><p>使用<code>SparkSession</code>，应用程序可以创建Datafrmaes从现有的RDD、Hive表或<a href="https://javyxu.cn/bigdata/spark_datasources/">Spark数据源</a>。</p>
<p>例如，下面根据JSON文件的内容创建一个DataFrame:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># spark is an existing SparkSession</span></span><br><span class="line">df = spark.read.json(<span class="string">&quot;examples/src/main/resources/people.json&quot;</span>)</span><br><span class="line"><span class="comment"># Displays the content of the DataFrame to stdout</span></span><br><span class="line">df.show()</span><br><span class="line"><span class="comment"># +----+-------+</span></span><br><span class="line"><span class="comment"># | age|   name|</span></span><br><span class="line"><span class="comment"># +----+-------+</span></span><br><span class="line"><span class="comment"># |null|Michael|</span></span><br><span class="line"><span class="comment"># |  30|   Andy|</span></span><br><span class="line"><span class="comment"># |  19| Justin|</span></span><br><span class="line"><span class="comment"># +----+-------+</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="非类型化数据集操作-即DataFrame操作"><a href="#非类型化数据集操作-即DataFrame操作" class="headerlink" title="非类型化数据集操作(即DataFrame操作)"></a>非类型化数据集操作(即DataFrame操作)</h3><p>DataFrames为Scala、Java、Python和R中的结构化数据操作提供了一种特定于领域的语言。</p>
<p>如上所述，在Spark 2.0中，DataFrames只是Scala和Java API中的行数据集。与强类型Scala/Java数据集提供的”类型化转换”相比，这些操作也称为”非类型化转换”。</p>
<p>以下是一些使用数据集进行结构化数据处理的基本例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># spark, df are from the previous example</span></span><br><span class="line"><span class="comment"># Print the schema in a tree format</span></span><br><span class="line">df.printSchema()</span><br><span class="line"><span class="comment"># root</span></span><br><span class="line"><span class="comment"># |-- age: long (nullable = true)</span></span><br><span class="line"><span class="comment"># |-- name: string (nullable = true)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Select only the &quot;name&quot; column</span></span><br><span class="line">df.select(<span class="string">&quot;name&quot;</span>).show()</span><br><span class="line"><span class="comment"># +-------+</span></span><br><span class="line"><span class="comment"># |   name|</span></span><br><span class="line"><span class="comment"># +-------+</span></span><br><span class="line"><span class="comment"># |Michael|</span></span><br><span class="line"><span class="comment"># |   Andy|</span></span><br><span class="line"><span class="comment"># | Justin|</span></span><br><span class="line"><span class="comment"># +-------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Select everybody, but increment the age by 1</span></span><br><span class="line">df.select(df[<span class="string">&#x27;name&#x27;</span>], df[<span class="string">&#x27;age&#x27;</span>] + <span class="number">1</span>).show()</span><br><span class="line"><span class="comment"># +-------+---------+</span></span><br><span class="line"><span class="comment"># |   name|(age + 1)|</span></span><br><span class="line"><span class="comment"># +-------+---------+</span></span><br><span class="line"><span class="comment"># |Michael|     null|</span></span><br><span class="line"><span class="comment"># |   Andy|       31|</span></span><br><span class="line"><span class="comment"># | Justin|       20|</span></span><br><span class="line"><span class="comment"># +-------+---------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Select people older than 21</span></span><br><span class="line">df.<span class="built_in">filter</span>(df[<span class="string">&#x27;age&#x27;</span>] &gt; <span class="number">21</span>).show()</span><br><span class="line"><span class="comment"># +---+----+</span></span><br><span class="line"><span class="comment"># |age|name|</span></span><br><span class="line"><span class="comment"># +---+----+</span></span><br><span class="line"><span class="comment"># | 30|Andy|</span></span><br><span class="line"><span class="comment"># +---+----+</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Count people by age</span></span><br><span class="line">df.groupBy(<span class="string">&quot;age&quot;</span>).count().show()</span><br><span class="line"><span class="comment"># +----+-----+</span></span><br><span class="line"><span class="comment"># | age|count|</span></span><br><span class="line"><span class="comment"># +----+-----+</span></span><br><span class="line"><span class="comment"># |  19|    1|</span></span><br><span class="line"><span class="comment"># |null|    1|</span></span><br><span class="line"><span class="comment"># |  30|    1|</span></span><br><span class="line"><span class="comment"># +----+-----+</span></span><br></pre></td></tr></table></figure>
<p>在Python中，可以通过属性(df.age)或索引(df[‘age’])访问DataFrame的列。虽然前者便于交互式数据探索，但强烈建议用户使用后一种形式，这是将来的证明，不会与DataFrame类的属性列名相冲突。</p>
<p>有关可以在DataFrame上执行的操作类型的完整列表，请参阅<a href="https://spark.apache.org/docs/2.2.2/api/python/pyspark.sql.html#pyspark.sql.DataFrame">API文档</a>。</p>
<p>除了简单的列引用和表达式之外，DataFrames还有一个丰富的函数库，包括字符串操作、日期算术、常见的数学操作等等。完整的列表可以在<a href="https://spark.apache.org/docs/2.2.2/api/python/pyspark.sql.html#module-pyspark.sql.functions">DataFrame函数引用</a>中获得。</p>
<h3 id="以编程方式运行SQL查询"><a href="#以编程方式运行SQL查询" class="headerlink" title="以编程方式运行SQL查询"></a>以编程方式运行SQL查询</h3><p><code>SparkSession</code>上的SQL函数允许应用程序以编程方式运行sql查询，并以<code>DataFrame</code>的形式返回结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Register the DataFrame as a SQL temporary view</span></span><br><span class="line">df.createOrReplaceTempView(<span class="string">&quot;people&quot;</span>)</span><br><span class="line"></span><br><span class="line">sqlDF = spark.sql(<span class="string">&quot;SELECT * FROM people&quot;</span>)</span><br><span class="line">sqlDF.show()</span><br><span class="line"><span class="comment"># +----+-------+</span></span><br><span class="line"><span class="comment"># | age|   name|</span></span><br><span class="line"><span class="comment"># +----+-------+</span></span><br><span class="line"><span class="comment"># |null|Michael|</span></span><br><span class="line"><span class="comment"># |  30|   Andy|</span></span><br><span class="line"><span class="comment"># |  19| Justin|</span></span><br><span class="line"><span class="comment"># +----+-------+</span></span><br></pre></td></tr></table></figure>
<h3 id="全局临时视图"><a href="#全局临时视图" class="headerlink" title="全局临时视图"></a>全局临时视图</h3><p>Spark SQL中的临时视图是会话范围的，如果创建它的会话终止，它将消失。如果希望所有会话之间共享一个临时视图，并在Spark应用程序终止之前保持活动状态，那么您可以创建一个全局临时视图。全局临时视图被绑定到系统保存的数据库<code>global_temp</code>，我们必须使用限定名来引用它，例如，<code>SELECT * FROM global_temp.view1.</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Register the DataFrame as a global temporary view</span></span><br><span class="line">df.createGlobalTempView(<span class="string">&quot;people&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Global temporary view is tied to a system preserved database `global_temp`</span></span><br><span class="line">spark.sql(<span class="string">&quot;SELECT * FROM global_temp.people&quot;</span>).show()</span><br><span class="line"><span class="comment"># +----+-------+</span></span><br><span class="line"><span class="comment"># | age|   name|</span></span><br><span class="line"><span class="comment"># +----+-------+</span></span><br><span class="line"><span class="comment"># |null|Michael|</span></span><br><span class="line"><span class="comment"># |  30|   Andy|</span></span><br><span class="line"><span class="comment"># |  19| Justin|</span></span><br><span class="line"><span class="comment"># +----+-------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Global temporary view is cross-session</span></span><br><span class="line">spark.newSession().sql(<span class="string">&quot;SELECT * FROM global_temp.people&quot;</span>).show()</span><br><span class="line"><span class="comment"># +----+-------+</span></span><br><span class="line"><span class="comment"># | age|   name|</span></span><br><span class="line"><span class="comment"># +----+-------+</span></span><br><span class="line"><span class="comment"># |null|Michael|</span></span><br><span class="line"><span class="comment"># |  30|   Andy|</span></span><br><span class="line"><span class="comment"># |  19| Justin|</span></span><br><span class="line"><span class="comment"># +----+-------+</span></span><br></pre></td></tr></table></figure>

<h3 id="与RDDs交互使用"><a href="#与RDDs交互使用" class="headerlink" title="与RDDs交互使用"></a>与RDDs交互使用</h3><p>Spark SQL支持两种不同的方法来将现有的RDDs转换为数据集。第一种方法使用反射来推断包含特定类型对象的RDD的模式。这种基于反射的方法可以生成更简洁的代码，并且当在编写Spark应用程序时已经知道模式时，这种方法可以很好地工作。</p>
<p>创建数据集的第二种方法是通过编程接口，该接口允许构造模式，然后将其应用于现有的RDD。虽然这个方法比较冗长，但它允许创建数据集在列及其类型未知的情况下。</p>
<h4 id="使用反射推断模式"><a href="#使用反射推断模式" class="headerlink" title="使用反射推断模式"></a>使用反射推断模式</h4><p>Spark SQL可以将行对象的RDD转换为DataFrame，从而推断数据类型。通过将key/value对列表作为kwargs传递给Row来构造行。该列表的键定义表的列名，通过对整个数据集进行采样来推断类型，类似于对JSON文件执行的推断。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> Row</span><br><span class="line"></span><br><span class="line">sc = spark.sparkContext</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load a text file and convert each line to a Row.</span></span><br><span class="line">lines = sc.textFile(<span class="string">&quot;examples/src/main/resources/people.txt&quot;</span>)</span><br><span class="line">parts = lines.<span class="built_in">map</span>(<span class="keyword">lambda</span> l: l.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">people = parts.<span class="built_in">map</span>(<span class="keyword">lambda</span> p: Row(name=p[<span class="number">0</span>], age=<span class="built_in">int</span>(p[<span class="number">1</span>])))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Infer the schema, and register the DataFrame as a table.</span></span><br><span class="line">schemaPeople = spark.createDataFrame(people)</span><br><span class="line">schemaPeople.createOrReplaceTempView(<span class="string">&quot;people&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># SQL can be run over DataFrames that have been registered as a table.</span></span><br><span class="line">teenagers = spark.sql(<span class="string">&quot;SELECT name FROM people WHERE age &gt;= 13 AND age &lt;= 19&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># The results of SQL queries are Dataframe objects.</span></span><br><span class="line"><span class="comment"># rdd returns the content as an :class:`pyspark.RDD` of :class:`Row`.</span></span><br><span class="line">teenNames = teenagers.rdd.<span class="built_in">map</span>(<span class="keyword">lambda</span> p: <span class="string">&quot;Name: &quot;</span> + p.name).collect()</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> teenNames:</span><br><span class="line">    print(name)</span><br><span class="line"><span class="comment"># Name: Justin</span></span><br></pre></td></tr></table></figure>
<h4 id="以编程方式指定模式"><a href="#以编程方式指定模式" class="headerlink" title="以编程方式指定模式"></a>以编程方式指定模式</h4><p>如果不能提前定义kwargs字典(例如，记录的结构以字符串形式编码，或者解析文本数据集，并针对不同的用户以不同的方式投影字段)，可以通过三个步骤以编程方式创建DataFrame。</p>
<ol>
<li><p>从原始的RDD中创建元组或列表的RDD;</p>
</li>
<li><p>在步骤1中创建的RDD中，使用匹配元组或列表结构的<code>StructType</code>表示模式。</p>
</li>
<li><p>通过<code>SparkSession</code>提供的<code>createDataFrame</code>方法将模式应用到RDD。</p>
</li>
</ol>
<p>例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Import data types</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql.types <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sc = spark.sparkContext</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load a text file and convert each line to a Row.</span></span><br><span class="line">lines = sc.textFile(<span class="string">&quot;examples/src/main/resources/people.txt&quot;</span>)</span><br><span class="line">parts = lines.<span class="built_in">map</span>(<span class="keyword">lambda</span> l: l.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line"><span class="comment"># Each line is converted to a tuple.</span></span><br><span class="line">people = parts.<span class="built_in">map</span>(<span class="keyword">lambda</span> p: (p[<span class="number">0</span>], p[<span class="number">1</span>].strip()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># The schema is encoded in a string.</span></span><br><span class="line">schemaString = <span class="string">&quot;name age&quot;</span></span><br><span class="line"></span><br><span class="line">fields = [StructField(field_name, StringType(), <span class="literal">True</span>) <span class="keyword">for</span> field_name <span class="keyword">in</span> schemaString.split()]</span><br><span class="line">schema = StructType(fields)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Apply the schema to the RDD.</span></span><br><span class="line">schemaPeople = spark.createDataFrame(people, schema)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Creates a temporary view using the DataFrame</span></span><br><span class="line">schemaPeople.createOrReplaceTempView(<span class="string">&quot;people&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># SQL can be run over DataFrames that have been registered as a table.</span></span><br><span class="line">results = spark.sql(<span class="string">&quot;SELECT name FROM people&quot;</span>)</span><br><span class="line"></span><br><span class="line">results.show()</span><br><span class="line"><span class="comment"># +-------+</span></span><br><span class="line"><span class="comment"># |   name|</span></span><br><span class="line"><span class="comment"># +-------+</span></span><br><span class="line"><span class="comment"># |Michael|</span></span><br><span class="line"><span class="comment"># |   Andy|</span></span><br><span class="line"><span class="comment"># | Justin|</span></span><br><span class="line"><span class="comment"># +-------+</span></span><br></pre></td></tr></table></figure>
<h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p><a href="https://spark.apache.org/docs/2.2.2/api/scala/index.html#org.apache.spark.sql.functions$">内置的DataFrames函数</a>提供常见的聚合函数，如<code>count()、countDistinct()、avg()、max()、min()</code>等,在Scala和Java中，park SQL还有一些类型安全的版本，可以用于处理强类型数据集。此外，用户不受预定义聚合函数的限制，可以创建自己的聚合函数。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.sql.expressions.<span class="type">MutableAggregationBuffer</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.expressions.<span class="type">UserDefinedAggregateFunction</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.types._</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.<span class="type">Row</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.<span class="type">SparkSession</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyAverage</span> <span class="keyword">extends</span> <span class="title">UserDefinedAggregateFunction</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Data types of input arguments of this aggregate function</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">inputSchema</span></span>: <span class="type">StructType</span> = <span class="type">StructType</span>(<span class="type">StructField</span>(<span class="string">&quot;inputColumn&quot;</span>, <span class="type">LongType</span>) :: <span class="type">Nil</span>)</span><br><span class="line">  <span class="comment">// Data types of values in the aggregation buffer</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">bufferSchema</span></span>: <span class="type">StructType</span> = &#123;</span><br><span class="line">    <span class="type">StructType</span>(<span class="type">StructField</span>(<span class="string">&quot;sum&quot;</span>, <span class="type">LongType</span>) :: <span class="type">StructField</span>(<span class="string">&quot;count&quot;</span>, <span class="type">LongType</span>) :: <span class="type">Nil</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// The data type of the returned value</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">dataType</span></span>: <span class="type">DataType</span> = <span class="type">DoubleType</span></span><br><span class="line">  <span class="comment">// Whether this function always returns the same output on the identical input</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">deterministic</span></span>: <span class="type">Boolean</span> = <span class="literal">true</span></span><br><span class="line">  <span class="comment">// Initializes the given aggregation buffer. The buffer itself is a `Row` that in addition to</span></span><br><span class="line">  <span class="comment">// standard methods like retrieving a value at an index (e.g., get(), getBoolean()), provides</span></span><br><span class="line">  <span class="comment">// the opportunity to update its values. Note that arrays and maps inside the buffer are still</span></span><br><span class="line">  <span class="comment">// immutable.</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span>(buffer: <span class="type">MutableAggregationBuffer</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    buffer(<span class="number">0</span>) = <span class="number">0</span>L</span><br><span class="line">    buffer(<span class="number">1</span>) = <span class="number">0</span>L</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Updates the given aggregation buffer `buffer` with new input data from `input`</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">update</span></span>(buffer: <span class="type">MutableAggregationBuffer</span>, input: <span class="type">Row</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (!input.isNullAt(<span class="number">0</span>)) &#123;</span><br><span class="line">      buffer(<span class="number">0</span>) = buffer.getLong(<span class="number">0</span>) + input.getLong(<span class="number">0</span>)</span><br><span class="line">      buffer(<span class="number">1</span>) = buffer.getLong(<span class="number">1</span>) + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Merges two aggregation buffers and stores the updated buffer values back to `buffer1`</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">merge</span></span>(buffer1: <span class="type">MutableAggregationBuffer</span>, buffer2: <span class="type">Row</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    buffer1(<span class="number">0</span>) = buffer1.getLong(<span class="number">0</span>) + buffer2.getLong(<span class="number">0</span>)</span><br><span class="line">    buffer1(<span class="number">1</span>) = buffer1.getLong(<span class="number">1</span>) + buffer2.getLong(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Calculates the final result</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">evaluate</span></span>(buffer: <span class="type">Row</span>): <span class="type">Double</span> = buffer.getLong(<span class="number">0</span>).toDouble / buffer.getLong(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register the function to access it</span></span><br><span class="line">spark.udf.register(<span class="string">&quot;myAverage&quot;</span>, <span class="type">MyAverage</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> df = spark.read.json(<span class="string">&quot;examples/src/main/resources/employees.json&quot;</span>)</span><br><span class="line">df.createOrReplaceTempView(<span class="string">&quot;employees&quot;</span>)</span><br><span class="line">df.show()</span><br><span class="line"><span class="comment">// +-------+------+</span></span><br><span class="line"><span class="comment">// |   name|salary|</span></span><br><span class="line"><span class="comment">// +-------+------+</span></span><br><span class="line"><span class="comment">// |Michael|  3000|</span></span><br><span class="line"><span class="comment">// |   Andy|  4500|</span></span><br><span class="line"><span class="comment">// | Justin|  3500|</span></span><br><span class="line"><span class="comment">// |  Berta|  4000|</span></span><br><span class="line"><span class="comment">// +-------+------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> result = spark.sql(<span class="string">&quot;SELECT myAverage(salary) as average_salary FROM employees&quot;</span>)</span><br><span class="line">result.show()</span><br><span class="line"><span class="comment">// +--------------+</span></span><br><span class="line"><span class="comment">// |average_salary|</span></span><br><span class="line"><span class="comment">// +--------------+</span></span><br><span class="line"><span class="comment">// |        3750.0|</span></span><br><span class="line"><span class="comment">// +--------------+</span></span><br></pre></td></tr></table></figure>
<h4 id="类型安全的用户定义聚合函数"><a href="#类型安全的用户定义聚合函数" class="headerlink" title="类型安全的用户定义聚合函数"></a>类型安全的用户定义聚合函数</h4><p>强类型数据集的用户定义聚合围绕[]聚合器](<a href="https://spark.apache.org/docs/2.2.2/api/scala/index.html#org.apache.spark.sql.expressions.Aggregator)%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%82%E4%BE%8B%E5%A6%82%EF%BC%8C%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E7%9A%84%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E5%B9%B3%E5%9D%87%E5%80%BC%E5%8F%AF%E4%BB%A5%E5%A6%82%E4%B8%8B%E6%89%80%E7%A4%BA">https://spark.apache.org/docs/2.2.2/api/scala/index.html#org.apache.spark.sql.expressions.Aggregator)抽象类。例如，类型安全的用户定义平均值可以如下所示</a>:</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.sql.expressions.<span class="type">Aggregator</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.<span class="type">Encoder</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.<span class="type">Encoders</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.<span class="type">SparkSession</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span>(<span class="params">name: <span class="type">String</span>, salary: <span class="type">Long</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Average</span>(<span class="params">var sum: <span class="type">Long</span>, var count: <span class="type">Long</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">MyAverage</span> <span class="keyword">extends</span> <span class="title">Aggregator</span>[<span class="type">Employee</span>, <span class="type">Average</span>, <span class="type">Double</span>] </span>&#123;</span><br><span class="line">  <span class="comment">// A zero value for this aggregation. Should satisfy the property that any b + zero = b</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">zero</span></span>: <span class="type">Average</span> = <span class="type">Average</span>(<span class="number">0</span>L, <span class="number">0</span>L)</span><br><span class="line">  <span class="comment">// Combine two values to produce a new value. For performance, the function may modify `buffer`</span></span><br><span class="line">  <span class="comment">// and return it instead of constructing a new object</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">reduce</span></span>(buffer: <span class="type">Average</span>, employee: <span class="type">Employee</span>): <span class="type">Average</span> = &#123;</span><br><span class="line">    buffer.sum += employee.salary</span><br><span class="line">    buffer.count += <span class="number">1</span></span><br><span class="line">    buffer</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Merge two intermediate values</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">merge</span></span>(b1: <span class="type">Average</span>, b2: <span class="type">Average</span>): <span class="type">Average</span> = &#123;</span><br><span class="line">    b1.sum += b2.sum</span><br><span class="line">    b1.count += b2.count</span><br><span class="line">    b1</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Transform the output of the reduction</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">finish</span></span>(reduction: <span class="type">Average</span>): <span class="type">Double</span> = reduction.sum.toDouble / reduction.count</span><br><span class="line">  <span class="comment">// Specifies the Encoder for the intermediate value type</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">bufferEncoder</span></span>: <span class="type">Encoder</span>[<span class="type">Average</span>] = <span class="type">Encoders</span>.product</span><br><span class="line">  <span class="comment">// Specifies the Encoder for the final output value type</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">outputEncoder</span></span>: <span class="type">Encoder</span>[<span class="type">Double</span>] = <span class="type">Encoders</span>.scalaDouble</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> ds = spark.read.json(<span class="string">&quot;examples/src/main/resources/employees.json&quot;</span>).as[<span class="type">Employee</span>]</span><br><span class="line">ds.show()</span><br><span class="line"><span class="comment">// +-------+------+</span></span><br><span class="line"><span class="comment">// |   name|salary|</span></span><br><span class="line"><span class="comment">// +-------+------+</span></span><br><span class="line"><span class="comment">// |Michael|  3000|</span></span><br><span class="line"><span class="comment">// |   Andy|  4500|</span></span><br><span class="line"><span class="comment">// | Justin|  3500|</span></span><br><span class="line"><span class="comment">// |  Berta|  4000|</span></span><br><span class="line"><span class="comment">// +-------+------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Convert the function to a `TypedColumn` and give it a name</span></span><br><span class="line"><span class="keyword">val</span> averageSalary = <span class="type">MyAverage</span>.toColumn.name(<span class="string">&quot;average_salary&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> result = ds.select(averageSalary)</span><br><span class="line">result.show()</span><br><span class="line"><span class="comment">// +--------------+</span></span><br><span class="line"><span class="comment">// |average_salary|</span></span><br><span class="line"><span class="comment">// +--------------+</span></span><br><span class="line"><span class="comment">// |        3750.0|</span></span><br><span class="line"><span class="comment">// +--------------+</span></span><br></pre></td></tr></table></figure>
<p><em>注：</em> 本小节代码都是Scala语言。</p>
<p><strong>要想了解更多关于Spark的使用，请查看本人下面博客：</strong></p>
<ol>
<li><a href="https://javyxu.cn/bigdata/using_spark/">Spark的使用</a></li>
<li><a href="https://javyxu.cn/bigdata/spark_datasources/">Python处理各种Spark数据源</a></li>
<li><a href="https://javyxu.cn/bigdata/spark_performance/">Spark性能优化</a></li>
</ol>
]]></content>
      <categories>
        <category>BigData</category>
      </categories>
      <tags>
        <tag>BigData</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark性能优化</title>
    <url>/bigdata/spark_performance/</url>
    <content><![CDATA[<h2 id="Spark性能优化"><a href="#Spark性能优化" class="headerlink" title="Spark性能优化"></a>Spark性能优化</h2><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>对于某些工作负载，可以通过在内存中缓存数据或打开一些实验性选项来提高性能。</p>
<h4 id="在内存中缓存数据"><a href="#在内存中缓存数据" class="headerlink" title="在内存中缓存数据"></a>在内存中缓存数据</h4><p>Spark SQL可以通过调用<code>spark.catalog.cacheTable(&quot;tableName&quot;)</code>或<code>dataFrame.cache()</code>来使用内存中的列状格式缓存表。然后Spark SQL将只扫描所需的列，并自动调优压缩，以最小化内存使用和GC压力。可以调用<code>spark.catalog.uncacheTable(&quot;tableName&quot;)</code>从内存中删除表。</p>
<p>可以使用<code>SparkSession</code>上的<code>setConf</code>方法或使用SQL运行<code>SET key=value</code>命令来配置内存缓存。</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>spark.sql.inMemoryColumnarStorage.compressed</td>
<td>true</td>
<td>当设置为true时，Spark SQL将根据数据的统计信息自动为每一列选择压缩编解码器。</td>
</tr>
<tr>
<td>spark.sql.inMemoryColumnarStorage.batchSize</td>
<td>10000</td>
<td>控制列缓存的批大小。更大的批处理大小可以提高内存利用率和压缩，但是在缓存数据时存在oom风险。</td>
</tr>
</tbody></table>
<h4 id="其他配置选项"><a href="#其他配置选项" class="headerlink" title="其他配置选项"></a>其他配置选项</h4><a id="more"></a>
<table>
<thead>
<tr>
<th>属性名</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>spark.sql.files.maxPartitionBytes</td>
<td>134217728 (128 MB)</td>
<td>读取文件时装入单个分区的最大字节数</td>
</tr>
<tr>
<td>spark.sql.files.openCostInBytes</td>
<td>4194304 (4 MB)</td>
<td>打开一个文件的估计成本，以字节数衡量，可以在同一时间扫描。这是在将多个文件放入一个分区时使用的。最好是高估它，那么带有小文件的分区将比带有大文件的分区(首先是调度的)更快</td>
</tr>
<tr>
<td>spark.sql.broadcastTimeout</td>
<td>300</td>
<td>以秒为单位的广播连接中的广播等待时间超时</td>
</tr>
<tr>
<td>spark.sql.autoBroadcastJoinThreshold</td>
<td>10485760 (10 MB)</td>
<td>配置执行联接时将广播到所有工作节点的表的最大字节大小。通过将此值设置为-1，可以禁用广播。注意，目前统计数据只支持Hive Metastore表，其中命令ANALYZE TABLE <tableName> COMPUTE statistics noscan已经运行</td>
</tr>
<tr>
<td>spark.sql.shuffle.partitions</td>
<td>200</td>
<td>配置在为连接或聚合洗牌数据时要使用的分区数</td>
</tr>
</tbody></table>
<p><strong>要想了解更多关于Spark的使用，请查看本人下面博客：</strong></p>
<ol>
<li><a href="https://javyxu.cn/bigdata/using_spark/">Spark的使用</a></li>
<li><a href="https://javyxu.cn/bigdata/spark_datasources/">Python处理各种Spark数据源</a></li>
<li><a href="https://javyxu.cn/bigdata/spark_performance/">Spark性能优化</a></li>
</ol>
]]></content>
      <categories>
        <category>BigData</category>
      </categories>
      <tags>
        <tag>BigData</tag>
      </tags>
  </entry>
  <entry>
    <title>Python处理各种Spark数据源</title>
    <url>/bigdata/spark_datasources/</url>
    <content><![CDATA[<h2 id="Python处理各种Spark数据源"><a href="#Python处理各种Spark数据源" class="headerlink" title="Python处理各种Spark数据源"></a>Python处理各种Spark数据源</h2><p>Spark SQL通过DataFrame接口支持对各种数据源进行操作。DataFrame可以使用关系型数据库转换操作，也可以用来创建临时视图。将一个DataFrame注册为临时视图允许您对其数据运行SQL查询。现在本人介绍使用Spark加载和保存数据的基本使用方法，然后介绍内置数据源的读取和保存。</p>
<h3 id="数据的加载和保存"><a href="#数据的加载和保存" class="headerlink" title="数据的加载和保存"></a>数据的加载和保存</h3><ol>
<li>普通方式加载和保存spark默认数据类型parquet</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = spark.read.load(<span class="string">&quot;examples/src/main/resources/users.parquet&quot;</span>)</span><br><span class="line">df.select(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;favorite_color&quot;</span>).write.save(<span class="string">&quot;namesAndFavColors.parquet&quot;</span>)</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在加载和保存时，通过参数指定数据源类型</li>
</ol>
<p>我们可以在保存和读取时指定要使用的数据源以及希望传递给数据源的其他参数。数据源由它们的全限定名，也可以使用它们的名称，比如json、parquet、jdbc、orc、libsvm、csv、text等后面将一一介绍。从任何数据源类型的数据都可以使用这种语法转换为其他类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = spark.read.load(<span class="string">&quot;examples/src/main/resources/people.json&quot;</span>, <span class="built_in">format</span>=<span class="string">&quot;json&quot;</span>)</span><br><span class="line">df.select(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>).write.save(<span class="string">&quot;namesAndAges.parquet&quot;</span>, <span class="built_in">format</span>=<span class="string">&quot;parquet&quot;</span>)</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在读取文件的的时候直接运行SQL</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = spark.sql(<span class="string">&quot;SELECT * FROM parquet.`examples/src/main/resources/users.parquet`&quot;</span>)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<ol start="4">
<li>保存数据的模式</li>
</ol>
<table>
<thead>
<tr>
<th>模式类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>error(default)</td>
<td>如果保存数据的时候，数据已经存在，将会抛出错误说明</td>
</tr>
<tr>
<td>append</td>
<td>如果保存数据的时候，数据已经存在，将会把数据追加保存</td>
</tr>
<tr>
<td>overwrite</td>
<td>如果保存数据的时候，数据已经存在，将会把数据重新保存</td>
</tr>
<tr>
<td>ignore</td>
<td>如果保存数据的时候，数据已经存在，将不会对已有数据进行操作，就像SQL语句<em>CREATE TABLE IF NOT EXISTS</em></td>
</tr>
</tbody></table>
<ol start="5">
<li>保存到持久表</li>
</ol>
<p>我们还可以使用<strong>saveAsTable</strong>命令将<strong>DataFrames</strong>永久保存到<strong>Hive metastore</strong>中。大家一想到要保存的Hive中，就要部署一套Hive，其实使用此特性不需要现有的Hive部署。Spark将使用Derby本地自动创建一个Hive metastore。与<code>createOrReplaceTempView</code>命令不同的是<code>saveAsTable</code>将实现DataFrame的内容，并创建指向Hive metastore中的数据的指针。即使在Spark程序重新启动之后，持久表仍然存在。可以通过在带有表名的<code>SparkSession</code>上调用表方法来创建持久表的DataFrame。</p>
<p>对于基于文件的数据源，例如文本、parquet、json等，可以通过path选项指定自定义表路径，例如<code>df.write.option(&quot;path&quot;、&quot;/some/path&quot;).saveAsTable(&#39;t&#39;)</code>。删除表时，自定义表路径不会被删除，表数据仍然存在。如果没有指定自定义表路径，Spark将把数据写到仓库目录下的默认表路径。删除表时，默认的表路径也将被删除。</p>
<p>从Spark 2.1开始，持久数据源表的每个分区元数据存储在’Hive metastore’中。这带来了几个好处:</p>
<ul>
<li><p>由于转移点只能返回查询所需的分区，因此不再需要将第一个查询中的所有分区都发现到表中。</p>
</li>
<li><p>Hive DDLs例如<code>ALTER TABLE PARTITION ... SET LOCATION</code>现在对使用数据源API创建的表可用。</p>
</li>
</ul>
<p>注意，在创建外部数据源表(带有’path’选项的表)时，默认情况下不会收集分区信息。要在metastore同步分区信息，可以调用<code>MSCK REPAIR TABLE</code>。</p>
<ol start="6">
<li>嵌套、排序和分区</li>
</ol>
<p>对于基于文件的数据源，在保存时可以进行嵌套、排序或分区。但是套接和排序只适用于持久表:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.write.bucketBy(<span class="number">42</span>, <span class="string">&quot;name&quot;</span>).sortBy(<span class="string">&quot;age&quot;</span>).saveAsTable(<span class="string">&quot;people_bucketed&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>当使用数据集api时，分区可以与save和saveAsTable一起使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.write.partitionBy(<span class="string">&quot;favorite_color&quot;</span>).<span class="built_in">format</span>(<span class="string">&quot;parquet&quot;</span>).save(<span class="string">&quot;namesPartByColor.parquet&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>可以对单表同时使用分区和嵌套:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = spark.read.parquet(<span class="string">&quot;examples/src/main/resources/users.parquet&quot;</span>)</span><br><span class="line">(df</span><br><span class="line">    .write</span><br><span class="line">    .partitionBy(<span class="string">&quot;favorite_color&quot;</span>)</span><br><span class="line">    .bucketBy(<span class="number">42</span>, <span class="string">&quot;name&quot;</span>)</span><br><span class="line">    .saveAsTable(<span class="string">&quot;people_partitioned_bucketed&quot;</span>))</span><br></pre></td></tr></table></figure>
<p><strong>partitionBy</strong> 创建一个目录结构目录结构下面的有所介绍。因此，它对具有高基数的列的适用性有限。相比之下，<strong>bucketBy</strong> 将数据分布在固定数量的bucket上，并且可以在许多惟一值是无界的情况下使用。</p>
<h3 id="parquet文件"><a href="#parquet文件" class="headerlink" title="parquet文件"></a>parquet文件</h3><p>parquet是一种列式的格式，它受到许多其他数据处理系统的支持。Spark SQL支持读取和写入parquet文件，这些文件自动保存原始数据的模式。在保存parquet文件时，出于兼容性的原因，所有列都自动转换为可空列。关于parquet更多信息，请查看本人的<a href="https://javyxu.cn/bigdata/parquet/">Parquet简介</a>。</p>
<ol>
<li>使用Python加载数据</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">peopleDF = spark.read.json(<span class="string">&quot;examples/src/main/resources/people.json&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># DataFrames can be saved as Parquet files, maintaining the schema information.</span></span><br><span class="line">peopleDF.write.parquet(<span class="string">&quot;people.parquet&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Read in the Parquet file created above.</span></span><br><span class="line"><span class="comment"># Parquet files are self-describing so the schema is preserved.</span></span><br><span class="line"><span class="comment"># The result of loading a parquet file is also a DataFrame.</span></span><br><span class="line">parquetFile = spark.read.parquet(<span class="string">&quot;people.parquet&quot;</span>)</span><br><span class="line"></span><br><span class="line">parquetFile.createOrReplaceTempView(<span class="string">&quot;parquetFile&quot;</span>)</span><br><span class="line">teenagers = spark.sql(<span class="string">&quot;SELECT name FROM parquetFile WHERE age &gt;= 13 AND age &lt;= 19&quot;</span>)</span><br><span class="line">teenagers.show()</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>探索分区</li>
</ol>
<p>表分区是Hive等系统中常用的优化方法。在分区表中，数据通常存储在不同的目录中，分区列值编码在每个分区目录的路径中。所有内置的文件源(包括text、CSV、JSON、ORC、Parquet)都能够自动发现和推断分区信息。例如，我们可以使用以下目录结构将所有以前使用的人口数据存储到分区表中，其中两个额外的列，<code>gender</code>和<code>country</code>作为分区列:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">path</span><br><span class="line">└── to</span><br><span class="line">    └── table</span><br><span class="line">        ├── gender&#x3D;male</span><br><span class="line">        │   ├── ...</span><br><span class="line">        │   │</span><br><span class="line">        │   ├── country&#x3D;US</span><br><span class="line">        │   │   └── data.parquet</span><br><span class="line">        │   ├── country&#x3D;CN</span><br><span class="line">        │   │   └── data.parquet</span><br><span class="line">        │   └── ...</span><br><span class="line">        └── gender&#x3D;female</span><br><span class="line">            ├── ...</span><br><span class="line">            │</span><br><span class="line">            ├── country&#x3D;US</span><br><span class="line">            │   └── data.parquet</span><br><span class="line">            ├── country&#x3D;CN</span><br><span class="line">            │   └── data.parquet</span><br><span class="line">            └── ...</span><br></pre></td></tr></table></figure>
<p>通过<code>path/to/table</code>使用<code>SparkSession.read.parquet``或SparkSession.read.load</code>，Spark SQL将自动从路径中提取分区信息。现在返回的DataFrame的模式变成:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root</span><br><span class="line">|-- name: string (nullable &#x3D; true)</span><br><span class="line">|-- age: long (nullable &#x3D; true)</span><br><span class="line">|-- gender: string (nullable &#x3D; true)</span><br><span class="line">|-- country: string (nullable &#x3D; true)</span><br></pre></td></tr></table></figure>
<p>注意，分区列的数据类型是自动推断的。目前，支持数字数据类型、日期、时间戳和字符串类型。有时用户可能不希望自动推断分区列的数据类型。对于这些用例，可以通过<code>spark.sql.sources.partitionColumnTypeInference.enabled</code>自动推断类型，默认为true。当为false时，分区列将使用string类型。</p>
<p>从Spark 1.6.0开始，默认情况下，分区发现只能在给定路径下找到分区。对于上面的例子，如果用户将path/to/table/gender=male传递给任何一个<code>SparkSession.read.parquet</code>或<code>SparkSession.read.load</code>时，<code>gender</code>将不会视为分区列。如果用户需要指定分区发现应该开始的基本路径，他们可以在数据源选项中设置basePath。例如，当path/to/table/gender=male是数据的路径，用户将basePath设置为path/to/table/时，gender将是一个分区列。</p>
<h4 id="模式合并"><a href="#模式合并" class="headerlink" title="模式合并"></a>模式合并</h4><p>像ProtocolBuffer、Avro和Thrift一样，Parquet也支持模式演化。用户可以从一个简单的模式开始，然后根据需要逐渐向该模式添加更多的列。这样，用户可能会得到多个具有不同但相互兼容的模式的Parquet文件。Parquet数据源现在能够自动检测这种情况并合并所有这些文件的模式。</p>
<p>由于模式合并是一个相对昂贵的操作，而且在大多数情况下不是必需的，因此我们从1.5.0开始默认关闭它。你可以通过</p>
<ol>
<li><p>读取parquet文件时，将数据源选项<code>mergeSchema</code>设置为<code>true</code>(如下面的示例所示)，或</p>
</li>
<li><p>设置全局SQL选项<code>spark.sql.parquet.mergeSchema</code>为<code>true</code>。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> Row</span><br><span class="line"></span><br><span class="line"><span class="comment"># spark is from the previous example.</span></span><br><span class="line"><span class="comment"># Create a simple DataFrame, stored into a partition directory</span></span><br><span class="line">sc = spark.sparkContext</span><br><span class="line"></span><br><span class="line">squaresDF = spark.createDataFrame(sc.parallelize(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>))</span><br><span class="line">                                  .<span class="built_in">map</span>(<span class="keyword">lambda</span> i: Row(single=i, double=i ** <span class="number">2</span>)))</span><br><span class="line">squaresDF.write.parquet(<span class="string">&quot;data/test_table/key=1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create another DataFrame in a new partition directory,</span></span><br><span class="line"><span class="comment"># adding a new column and dropping an existing column</span></span><br><span class="line">cubesDF = spark.createDataFrame(sc.parallelize(<span class="built_in">range</span>(<span class="number">6</span>, <span class="number">11</span>))</span><br><span class="line">                                .<span class="built_in">map</span>(<span class="keyword">lambda</span> i: Row(single=i, triple=i ** <span class="number">3</span>)))</span><br><span class="line">cubesDF.write.parquet(<span class="string">&quot;data/test_table/key=2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Read the partitioned table</span></span><br><span class="line">mergedDF = spark.read.option(<span class="string">&quot;mergeSchema&quot;</span>, <span class="string">&quot;true&quot;</span>).parquet(<span class="string">&quot;data/test_table&quot;</span>)</span><br><span class="line">mergedDF.printSchema()</span><br><span class="line"></span><br><span class="line"><span class="comment"># The final schema consists of all 3 columns in the Parquet files together</span></span><br><span class="line"><span class="comment"># with the partitioning column appeared in the partition directory paths.</span></span><br><span class="line"><span class="comment"># root</span></span><br><span class="line"><span class="comment">#  |-- double: long (nullable = true)</span></span><br><span class="line"><span class="comment">#  |-- single: long (nullable = true)</span></span><br><span class="line"><span class="comment">#  |-- triple: long (nullable = true)</span></span><br><span class="line"><span class="comment">#  |-- key: integer (nullable = true)</span></span><br></pre></td></tr></table></figure>
<h4 id="Hive-metastore转换为parquet表"><a href="#Hive-metastore转换为parquet表" class="headerlink" title="Hive metastore转换为parquet表"></a>Hive metastore转换为parquet表</h4><p>在从Hive metastore parquet table读取和写入数据时，Spark SQL将尝试使用自己的parquet，而不是Hive SerDe，以获得更好的性能。这个行为由<code>spark.sql.hive.convertMetastoreParquet</code>配置，并在默认情况下打开。</p>
<h5 id="Hive-Parquet-Schema协调"><a href="#Hive-Parquet-Schema协调" class="headerlink" title="Hive/Parquet Schema协调"></a>Hive/Parquet Schema协调</h5><p>从表模式处理的角度来看，Hive和Parquet有两个关键的区别。</p>
<ol>
<li><p>Hive是不区分大小写的，而parquet区分。</p>
</li>
<li><p>Hive认为所有的列都是可空的，而在parquet中的可空性是很重要的</p>
</li>
</ol>
<p>因此，在将<code>Hive metastore parquet table</code>转换为<code>Spark SQL parquet table</code>时，我们必须将<code>Hive metastore parquet table</code>与<code>Parquet</code>模式进行协调。协调规则如下:</p>
<ol>
<li><p>无论是否为空，两个模式中具有相同名称的字段必须具有相同的数据类型。协调字段应该具有parquet的数据类型，以便考虑可空性。</p>
</li>
<li><p>协调模式正好包含在Hive metastore模式中定义的字段。</p>
</li>
</ol>
<ul>
<li><p>在parquet模式中的任何字段都将被删除在协调模式中。</p>
</li>
<li><p>只出现在Hive metastore模式中的任何字段都作为可空字段添加到协调模式中。</p>
</li>
</ul>
<h5 id="元数据刷新"><a href="#元数据刷新" class="headerlink" title="元数据刷新"></a>元数据刷新</h5><p>Spark SQL缓存parquet元数据以获得更好的性能。当启用Hive metastore parquet table转换时，这些转换表的元数据也会被缓存。如果这些表是由Hive或其他外部工具更新的，则需要手动刷新它们，以确保一致的元数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># spark is an existing SparkSession</span></span><br><span class="line">spark.catalog.refreshTable(<span class="string">&quot;my_table&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>可以使用SparkSession上的<code>setConf</code>方法或使用SQL运行<code>SET key=value</code>命令来配置parquet。</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>spark.sql.parquet.binaryAsString</td>
<td>false</td>
<td>其他一些生成Parquet的系统，特别是Impala、Hive和Spark SQL的旧版本，在编写Parquet模式时不区分二进制数据和字符串。这个标志告诉Spark SQL将二进制数据解释为字符串，以提供与这些系统的兼容性。</td>
</tr>
<tr>
<td>spark.sql.parquet.int96AsTimestamp</td>
<td>true</td>
<td>一些parquet生产系统，特别是Impala和Hive，将时间戳存储到INT96中。这个标志告诉Spark SQL将INT96数据解释为一个时间戳，以提供与这些系统的兼容性。</td>
</tr>
<tr>
<td>spark.sql.parquet.cacheMetadata</td>
<td>true</td>
<td>打开parquet模式元数据的缓存。可以加速静态数据的查询。snappy设置编写拼花文件时使用的压缩编解码器。可接受的值包括:uncompression、snappy、gzip、lzo。</td>
</tr>
<tr>
<td>spark.sql.parquet.filterPushdown</td>
<td>true</td>
<td>设置为true时，启用parquet过滤下推优化</td>
</tr>
<tr>
<td>spark.sql.hive.convertMetastoreParquet</td>
<td>true</td>
<td>当设置为false时，Spark SQL将对拼花表使用Hive SerDe，而不是内置支持。</td>
</tr>
<tr>
<td>spark.sql.parquet.mergeSchema</td>
<td>false</td>
<td>如果为真，Parquet数据源将合并从所有数据文件收集的模式，否则将从总结文件中选择模式，如果没有总结文件可用，则从随机数据文件中选择模式。</td>
</tr>
<tr>
<td>spark.sql.optimizer.metadataOnly</td>
<td>true</td>
<td>如果为真，则启用仅使用表的元数据来生成分区列而不是表扫描的元数据查询优化。当扫描的所有列都是分区列且查询具有满足不同语义的聚合操作符时，该方法将适用。</td>
</tr>
</tbody></table>
<h3 id="json数据集"><a href="#json数据集" class="headerlink" title="json数据集"></a>json数据集</h3><p>Spark SQL可以自动推断JSON数据集的模式，并将其作为DataFrame加载。可以使用<code>SparkSession.read.json</code>读取json文件。</p>
<p>注意，作为json文件提供的文件不是典型的json文件。每行必须包含一个单独的、自包含的有效JSON对象。有关更多信息请查看<a href="http://jsonlines.org/">JSON行文本格式，也称为以新行分隔的JSON</a></p>
<p>对于常规的多行JSON文件，将多行参数设置为True。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># spark is from the previous example.</span></span><br><span class="line">sc = spark.sparkContext</span><br><span class="line"></span><br><span class="line"><span class="comment"># A JSON dataset is pointed to by path.</span></span><br><span class="line"><span class="comment"># The path can be either a single text file or a directory storing text files</span></span><br><span class="line">path = <span class="string">&quot;examples/src/main/resources/people.json&quot;</span></span><br><span class="line">peopleDF = spark.read.json(path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># The inferred schema can be visualized using the printSchema() method</span></span><br><span class="line">peopleDF.printSchema()</span><br><span class="line"><span class="comment"># root</span></span><br><span class="line"><span class="comment">#  |-- age: long (nullable = true)</span></span><br><span class="line"><span class="comment">#  |-- name: string (nullable = true)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Creates a temporary view using the DataFrame</span></span><br><span class="line">peopleDF.createOrReplaceTempView(<span class="string">&quot;people&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># SQL statements can be run by using the sql methods provided by spark</span></span><br><span class="line">teenagerNamesDF = spark.sql(<span class="string">&quot;SELECT name FROM people WHERE age BETWEEN 13 AND 19&quot;</span>)</span><br><span class="line">teenagerNamesDF.show()</span><br><span class="line"><span class="comment"># +------+</span></span><br><span class="line"><span class="comment"># |  name|</span></span><br><span class="line"><span class="comment"># +------+</span></span><br><span class="line"><span class="comment"># |Justin|</span></span><br><span class="line"><span class="comment"># +------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Alternatively, a DataFrame can be created for a JSON dataset represented by</span></span><br><span class="line"><span class="comment"># an RDD[String] storing one JSON object per string</span></span><br><span class="line">jsonStrings = [<span class="string">&#x27;&#123;&quot;name&quot;:&quot;Yin&quot;,&quot;address&quot;:&#123;&quot;city&quot;:&quot;Columbus&quot;,&quot;state&quot;:&quot;Ohio&quot;&#125;&#125;&#x27;</span>]</span><br><span class="line">otherPeopleRDD = sc.parallelize(jsonStrings)</span><br><span class="line">otherPeople = spark.read.json(otherPeopleRDD)</span><br><span class="line">otherPeople.show()</span><br><span class="line"><span class="comment"># +---------------+----+</span></span><br><span class="line"><span class="comment"># |        address|name|</span></span><br><span class="line"><span class="comment"># +---------------+----+</span></span><br><span class="line"><span class="comment"># |[Columbus,Ohio]| Yin|</span></span><br><span class="line"><span class="comment"># +---------------+----+</span></span><br></pre></td></tr></table></figure>
<h3 id="Hive表"><a href="#Hive表" class="headerlink" title="Hive表"></a>Hive表</h3><p>Spark SQL还支持读取和写入存储在<a href="http://hive.apache.org/">Apache Hive</a>中的数据。然而，由于Hive有大量的依赖项，这些依赖项并不包含在默认的Spark发行版中。如果可以在类路径中找到Hive依赖项，Spark将自动加载它们。请注意，这些Hive依赖项还必须出现在所有工作节点上，因为它们需要访问Hive序列化和反序列化库(SerDes)，以便访问存储在Hive中的数据。</p>
<p>Hive的配置是通过放置Hive站点来完成的: 配置在<code>conf</code>下的hive-site.xml, core-site.xml(用于安全配置)和hdfs-site.conf(用于HDFS配置)文件。</p>
<p>在使用Hive时，必须使用Hive支持实例化<code>SparkSession</code>，包括连接到持久的Hive转移、支持Hive serdes和Hive user-defined的函数。用户仍然可以启用Hive支持在没有Hive部署的机器上。当没有配置<code>hive-site.xml</code>时。上下文会在当前目录中自动创建metastore_db，并创建一个由<code>spark.sql.warehouse.dir</code>。默认为启动Spark应用程序的当前目录中的Spark-warehouse目录。注意<code>hive.metastore.warehouse.dir</code>从Spark 2.0.0开始，<code>hive-site.xml</code>就被弃用了。相反,使用<code>spark.sql.warehouse.dir</code>指定数据库在仓库中的默认位置。您可能需要将写权限授予启动Spark应用程序的用户。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> os.path <span class="keyword">import</span> expanduser, join, abspath</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession</span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> Row</span><br><span class="line"></span><br><span class="line"><span class="comment"># warehouse_location points to the default location for managed databases and tables</span></span><br><span class="line">warehouse_location = abspath(<span class="string">&#x27;spark-warehouse&#x27;</span>)</span><br><span class="line"></span><br><span class="line">spark = SparkSession \</span><br><span class="line">    .builder \</span><br><span class="line">    .appName(<span class="string">&quot;Python Spark SQL Hive integration example&quot;</span>) \</span><br><span class="line">    .config(<span class="string">&quot;spark.sql.warehouse.dir&quot;</span>, warehouse_location) \</span><br><span class="line">    .enableHiveSupport() \</span><br><span class="line">    .getOrCreate()</span><br><span class="line"></span><br><span class="line"><span class="comment"># spark is an existing SparkSession</span></span><br><span class="line">spark.sql(<span class="string">&quot;CREATE TABLE IF NOT EXISTS src (key INT, value STRING) USING hive&quot;</span>)</span><br><span class="line">spark.sql(<span class="string">&quot;LOAD DATA LOCAL INPATH &#x27;examples/src/main/resources/kv1.txt&#x27; INTO TABLE src&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Queries are expressed in HiveQL</span></span><br><span class="line">spark.sql(<span class="string">&quot;SELECT * FROM src&quot;</span>).show()</span><br><span class="line"><span class="comment"># +---+-------+</span></span><br><span class="line"><span class="comment"># |key|  value|</span></span><br><span class="line"><span class="comment"># +---+-------+</span></span><br><span class="line"><span class="comment"># |238|val_238|</span></span><br><span class="line"><span class="comment"># | 86| val_86|</span></span><br><span class="line"><span class="comment"># |311|val_311|</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Aggregation queries are also supported.</span></span><br><span class="line">spark.sql(<span class="string">&quot;SELECT COUNT(*) FROM src&quot;</span>).show()</span><br><span class="line"><span class="comment"># +--------+</span></span><br><span class="line"><span class="comment"># |count(1)|</span></span><br><span class="line"><span class="comment"># +--------+</span></span><br><span class="line"><span class="comment"># |    500 |</span></span><br><span class="line"><span class="comment"># +--------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The results of SQL queries are themselves DataFrames and support all normal functions.</span></span><br><span class="line">sqlDF = spark.sql(<span class="string">&quot;SELECT key, value FROM src WHERE key &lt; 10 ORDER BY key&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># The items in DataFrames are of type Row, which allows you to access each column by ordinal.</span></span><br><span class="line">stringsDS = sqlDF.rdd.<span class="built_in">map</span>(<span class="keyword">lambda</span> row: <span class="string">&quot;Key: %d, Value: %s&quot;</span> % (row.key, row.value))</span><br><span class="line"><span class="keyword">for</span> record <span class="keyword">in</span> stringsDS.collect():</span><br><span class="line">    print(record)</span><br><span class="line"><span class="comment"># Key: 0, Value: val_0</span></span><br><span class="line"><span class="comment"># Key: 0, Value: val_0</span></span><br><span class="line"><span class="comment"># Key: 0, Value: val_0</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># You can also use DataFrames to create temporary views within a SparkSession.</span></span><br><span class="line">Record = Row(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>)</span><br><span class="line">recordsDF = spark.createDataFrame([Record(i, <span class="string">&quot;val_&quot;</span> + <span class="built_in">str</span>(i)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">101</span>)])</span><br><span class="line">recordsDF.createOrReplaceTempView(<span class="string">&quot;records&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Queries can then join DataFrame data with data stored in Hive.</span></span><br><span class="line">spark.sql(<span class="string">&quot;SELECT * FROM records r JOIN src s ON r.key = s.key&quot;</span>).show()</span><br><span class="line"><span class="comment"># +---+------+---+------+</span></span><br><span class="line"><span class="comment"># |key| value|key| value|</span></span><br><span class="line"><span class="comment"># +---+------+---+------+</span></span><br><span class="line"><span class="comment"># |  2| val_2|  2| val_2|</span></span><br><span class="line"><span class="comment"># |  4| val_4|  4| val_4|</span></span><br><span class="line"><span class="comment"># |  5| val_5|  5| val_5|</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<h4 id="指定Hive表的存储格式"><a href="#指定Hive表的存储格式" class="headerlink" title="指定Hive表的存储格式"></a>指定Hive表的存储格式</h4><p>在创建Hive表时，需要定义这个表应该如何向文件系统读写数据，即”输入格式”和”输出格式”。您还需要定义这个表应该如何将数据反序列化为行，或将行序列化为数据，即”serde”。以下选项可用于指定存储格式(“serde”、”input format”、”output format”)，例如<code>CREATE TABLE src(id int) USING hive OPTIONS(fileFormat &#39;parquet&#39;).</code>。默认情况下，我们将以纯文本的形式读取表文件。注意，在创建表时还不支持Hive存储处理程序，您可以使用Hive侧的存储处理程序创建表，并使用Spark SQL读取它。</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>fileFormat</td>
<td>fileFormat是一种存储格式规范的包，包括”serde”、”input format”和”output format”。目前我们支持6种文件格式:”sequencefile”，”rcfile”，”orc”，”parquet”，”textfile”和”avro”。</td>
</tr>
<tr>
<td>inputFormat, outputFormat</td>
<td>这两个选项将对应的”InputFormat”和”OutputFormat”类的名称指定为字符串文本，例如。”org.apache.hadoop.hive.ql.io.orc.OrcInputFormat”。这两个选项必须成对出现，如果已经指定了”fileFormat”选项，则不能指定它们。</td>
</tr>
<tr>
<td>serde</td>
<td>此选项指定serde类的名称。指定”fileFormat”选项时，如果给定的”fileFormat”已经包含serde的信息，则不要指定此选项。目前”sequencefile”、”textfile”和”rcfile”不包含serde信息，您可以在这三种文件格式中使用此选项。</td>
</tr>
<tr>
<td>fieldDelim, escapeDelim, collectionDelim, mapkeyDelim, lineDelim</td>
<td>此选项只能与”textfile”文件格式一起使用。它们定义如何将带分隔符的文件读入行。</td>
</tr>
</tbody></table>
<p>使用<code>OPTIONS</code>定义的所有其他属性将被视为Hive serde属性。</p>
<h4 id="与不同版本的Hive-Metastore相互作用"><a href="#与不同版本的Hive-Metastore相互作用" class="headerlink" title="与不同版本的Hive Metastore相互作用"></a>与不同版本的Hive Metastore相互作用</h4><p>Spark SQL的Hive支持中最重要的部分之一是与Hive metastore的交互，这使得Spark SQL能够访问Hive表的元数据。从Spark 1.4.0开始，Spark SQL的一个二进制构建可以使用下面描述的配置来查询不同版本的Hive metastores。注意，独立于用于与metastore通信的Hive版本，内部Spark SQL将针对Hive 1.2.1编译，并将这些类用于内部执行(serdes、udf、udf等)。</p>
<p>以下选项可用于配置用于检索元数据的Hive版本:</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>spark.sql.hive.metastore.version</td>
<td>1.2.1</td>
<td>Hive metastore版本号。 蜂巢转移。可用选项从0.12.0到1.2.1</td>
</tr>
<tr>
<td>spark.sql.hive.metastore.jars</td>
<td>builtin</td>
<td>用于实例化HiveMetastoreClient的jar的位置。此属性可以是三个选项之一:<strong>builtin：</strong> 使用Hive 1.2.1，当启用-Phive时，它与Spark程序集绑定在一起。当选择此选项时，spark.sq .hive.metastore。版本必须是1.2.1或未定义。<strong>maven：</strong> 用从Maven存储库下载的指定版本的Hive jar。一般不建议将此配置用于生产部署。 JVM标准格式的类路径。这个类路径必须包括所有Hive及其依赖项，包括正确的Hadoop版本。这些jar只需要出现在驱动程序上，但是如果您在yarn集群模式下运行，那么您必须确保它们与您的应用程序一起打包。</td>
</tr>
<tr>
<td>spark.sql.hive.metastore.sharedPrefixes</td>
<td>com.mysql.jdbc, org.postgresql, com.microsoft.sqlserver, oracle.jdbc</td>
<td>类前缀的逗号分隔列表，应该使用在Spark SQL和特定版本的Hive之间共享的类加载器加载这些前缀。应该共享的类的一个例子是JDBC驱动程序，它需要与转移服务器进行通信。需要共享的其他类是那些与已经共享的类交互的类。例如，log4j使用的自定义appender。</td>
</tr>
<tr>
<td>spark.sql.hive.metastore.barrierPrefixes</td>
<td>(empty)</td>
<td>Spark SQL正在与之通信的每个Hive版本都应该显式地重新加载类前缀的逗号分隔列表。例如，Hive udf声明在一个通常会被共享的前缀中(即org.apache.spark.*)。</td>
</tr>
</tbody></table>
<h3 id="通过JDBC来连接其他的关系型数据库"><a href="#通过JDBC来连接其他的关系型数据库" class="headerlink" title="通过JDBC来连接其他的关系型数据库"></a>通过JDBC来连接其他的关系型数据库</h3><p>Spark SQL还包括一个数据源，可以使用JDBC从其他数据库读取数据。与使用<a href="https://spark.apache.org/docs/2.2.2/api/scala/index.html#org.apache.spark.rdd.JdbcRDD">JdbcRDD</a>相比，这种功能更可取。这是因为结果是以DataFrame的形式返回的，并且它们可以在Spark SQL中轻松处理或与其他数据源连接。JDBC数据源也更容易从Java或Python中使用，因为它不需要用户提供一个ClassTag。(请注意，这与Spark SQL JDBC服务器不同，后者允许其他应用程序使用Spark SQL运行查询)。</p>
<p>首先，您需要在spark类路径中包含特定数据库的JDBC驱动程序。例如，要从Spark Shell连接到postgres,对于postgres的按照查看<a href="https://javyxu.cn/postgresql/install_postgres/">此处</a>，需要运行以下命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;spark-shell --driver-class-path postgresql-9.4.1207.jar --jars postgresql-9.4.1207.jar</span><br></pre></td></tr></table></figure>
<p>可以使用数据源API将远程数据库中的表加载为DataFrame或Spark SQL临时视图。用户可以在数据源选项中指定JDBC连接属性。用户和密码通常作为登录数据源的连接属性提供。除了连接属性，Spark还支持以下不区分大小写的选项:</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>url</td>
<td>要连接的JDBC URL。特定于源代码的连接属性可以在URL中指定。例如： <code>jdbc:postgresql://localhost/test?user=fred&amp;password=secret</code></td>
</tr>
<tr>
<td>dbtable</td>
<td>应该读取的JDBC表。注意，可以使用SQL查询的FROM子句中有效的任何内容。例如，您也可以使用圆括号中的子查询来代替完整的表。</td>
</tr>
<tr>
<td>driver</td>
<td>用于连接此URL的JDBC驱动程序的类名。</td>
</tr>
<tr>
<td>partitionColumn, lowerBound, upperBound</td>
<td>如果指定了这些选项中的任何一个，则必须指定所有这些选项。此外，必须指定numpartition。它们描述了当从多个worker并行读取数据时如何对表进行分区。partitionColumn必须是表中的数字列。注意，下界和上界仅用于决定分区步幅，而不是用于过滤表中的行。因此，表中的所有行都将被分区并返回。此选项仅适用于阅读。</td>
</tr>
<tr>
<td>numPartitions</td>
<td>用于表读写并行性的分区的最大数目。这也决定了并发JDBC连接的最大数量。如果要写入的分区数量超过此限制，则在写入之前调用coalesce(numPartitions)将其减少到此限制。</td>
</tr>
<tr>
<td>fetchsize</td>
<td>JDBC获取大小，它决定每次往返要获取多少行。这有助于JDBC驱动程序的性能，JDBC驱动程序默认为低获取大小(例如。Oracle有10行)。此选项仅适用于阅读。</td>
</tr>
<tr>
<td>batchsize</td>
<td>JDBC批处理大小，它决定每个往返要插入多少行。这可以帮助JDBC驱动程序的性能。此选项仅适用于写入。默认值是1000。</td>
</tr>
<tr>
<td>isolationLevel</td>
<td>事务隔离级别，适用于当前连接。它可以是NONE、READ_COMMITTED、READ_UNCOMMITTED、REPEATABLE_READ或SERIALIZABLE之一，对应于JDBC的连接对象定义的标准事务隔离级别，默认为READ_UNCOMMITTED。此选项仅适用于写入。请参考java.sql.Connection中的文档。</td>
</tr>
<tr>
<td>truncate</td>
<td>这是一个JDBC编写器相关的选项。当SaveMode。启用覆盖后，此选项将导致Spark截断现有表，而不是删除和重新创建该表。这可以更有效地防止表元数据(例如索引)被删除。但是，在某些情况下，例如新数据具有不同的模式时，它将不起作用。它默认为false。此选项仅适用于写入。</td>
</tr>
<tr>
<td>createTableOptions</td>
<td>这是一个JDBC编写器相关的选项。如果指定，该选项允许在创建表时设置特定于数据库的表和分区选项(例如，CREATE table t (name string) ENGINE=InnoDB.)。此选项仅适用于写入。</td>
</tr>
<tr>
<td>createTableColumnTypes</td>
<td>创建表时要使用的数据库列数据类型，而不是默认值。数据类型信息应该以与CREATE TABLE columns语法(e。g:”name CHAR(64)， comments VARCHAR(1024)”)。指定的类型应该是有效的spark sql数据类型。此选项仅适用于写入。</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Note: JDBC loading and saving can be achieved via either the load/save or jdbc methods</span></span><br><span class="line"><span class="comment"># Loading data from a JDBC source</span></span><br><span class="line">jdbcDF = spark.read \</span><br><span class="line">    .<span class="built_in">format</span>(<span class="string">&quot;jdbc&quot;</span>) \</span><br><span class="line">    .option(<span class="string">&quot;url&quot;</span>, <span class="string">&quot;jdbc:postgresql:dbserver&quot;</span>) \</span><br><span class="line">    .option(<span class="string">&quot;dbtable&quot;</span>, <span class="string">&quot;schema.tablename&quot;</span>) \</span><br><span class="line">    .option(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;username&quot;</span>) \</span><br><span class="line">    .option(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;password&quot;</span>) \</span><br><span class="line">    .load()</span><br><span class="line"></span><br><span class="line">jdbcDF2 = spark.read \</span><br><span class="line">    .jdbc(<span class="string">&quot;jdbc:postgresql:dbserver&quot;</span>, <span class="string">&quot;schema.tablename&quot;</span>,</span><br><span class="line">          properties=&#123;<span class="string">&quot;user&quot;</span>: <span class="string">&quot;username&quot;</span>, <span class="string">&quot;password&quot;</span>: <span class="string">&quot;password&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Saving data to a JDBC source</span></span><br><span class="line">jdbcDF.write \</span><br><span class="line">    .<span class="built_in">format</span>(<span class="string">&quot;jdbc&quot;</span>) \</span><br><span class="line">    .option(<span class="string">&quot;url&quot;</span>, <span class="string">&quot;jdbc:postgresql:dbserver&quot;</span>) \</span><br><span class="line">    .option(<span class="string">&quot;dbtable&quot;</span>, <span class="string">&quot;schema.tablename&quot;</span>) \</span><br><span class="line">    .option(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;username&quot;</span>) \</span><br><span class="line">    .option(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;password&quot;</span>) \</span><br><span class="line">    .save()</span><br><span class="line"></span><br><span class="line">jdbcDF2.write \</span><br><span class="line">    .jdbc(<span class="string">&quot;jdbc:postgresql:dbserver&quot;</span>, <span class="string">&quot;schema.tablename&quot;</span>,</span><br><span class="line">          properties=&#123;<span class="string">&quot;user&quot;</span>: <span class="string">&quot;username&quot;</span>, <span class="string">&quot;password&quot;</span>: <span class="string">&quot;password&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Specifying create table column data types on write</span></span><br><span class="line">jdbcDF.write \</span><br><span class="line">    .option(<span class="string">&quot;createTableColumnTypes&quot;</span>, <span class="string">&quot;name CHAR(64), comments VARCHAR(1024)&quot;</span>) \</span><br><span class="line">    .jdbc(<span class="string">&quot;jdbc:postgresql:dbserver&quot;</span>, <span class="string">&quot;schema.tablename&quot;</span>,</span><br><span class="line">          properties=&#123;<span class="string">&quot;user&quot;</span>: <span class="string">&quot;username&quot;</span>, <span class="string">&quot;password&quot;</span>: <span class="string">&quot;password&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>
<p><em>在Spark repo的”examples/src/main/python/sql/datasource.py”中找到完整的示例</em>。</p>
<h4 id="故障排除"><a href="#故障排除" class="headerlink" title="故障排除"></a>故障排除</h4><ul>
<li><p>JDBC驱动程序类必须对客户机会话和所有执行程序上的原始类装入器可见。这是因为Java的DriverManager类做了一个安全检查，当打开一个连接时，它会忽略所有原始类装入器不可见的驱动程序。一种方便的方法是修改compute_classpath。在所有工作节点上使用sh来包含驱动程序jar。</p>
</li>
<li><p>有些数据库，如H2，将所有名称转换为大写。您需要使用大写字母来引用Spark SQL中的这些名称。</p>
</li>
</ul>
<p><strong>要想了解更多关于Spark的使用，请查看本人下面博客：</strong></p>
<ol>
<li><a href="https://javyxu.cn/bigdata/using_spark/">Spark的使用</a></li>
<li><a href="https://javyxu.cn/bigdata/spark_datasources/">Python处理各种Spark数据源</a></li>
<li><a href="https://javyxu.cn/bigdata/spark_performance/">Spark性能优化</a></li>
</ol>
]]></content>
      <categories>
        <category>BigData</category>
      </categories>
      <tags>
        <tag>BigData</tag>
      </tags>
  </entry>
  <entry>
    <title>Python性能优化建议</title>
    <url>/python/python_optimizing_performance/</url>
    <content><![CDATA[<h2 id="Python性能优化建议"><a href="#Python性能优化建议" class="headerlink" title="Python性能优化建议"></a>Python性能优化建议</h2><h3 id="优化算法时间复杂度"><a href="#优化算法时间复杂度" class="headerlink" title="优化算法时间复杂度"></a>优化算法时间复杂度</h3><p>算法的时间复杂度对程序的执行效率影响最大，在Python中可以通过选择合适的数据结构来优化时间复杂度，如list和set查找某一个元素的时间复杂度分别是O(n)和O(1)。不同的场景有不同的优化方式，总得来说，一般有分治，分支界限，贪心，动态规划等思想。</p>
<h3 id="减少冗余数据"><a href="#减少冗余数据" class="headerlink" title="减少冗余数据"></a>减少冗余数据</h3><p>如用上三角或下三角的方式去保存一个大的对称矩阵。在0元素占大多数的矩阵里使用稀疏矩阵表示。</p>
<h3 id="使用性能分析工具"><a href="#使用性能分析工具" class="headerlink" title="使用性能分析工具"></a>使用性能分析工具</h3><a id="more"></a>
<ul>
<li>ipython的timeit</li>
</ul>
<p>使用方式：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%timeit -n <span class="number">10</span> copy.copy(a)</span><br></pre></td></tr></table></figure>
<p>说明：-n表示运行的次数，后两行对应的是两个timeit的输出</p>
<ul>
<li>cProfile</li>
</ul>
<p>cProfile的使用方式也非常简单：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -m cProfile filename.py</span><br></pre></td></tr></table></figure>
<p>说明： <strong>filename.py</strong> 是要运行程序的文件名，可以在标准输出中看到每一个函数被调用的次数和运行的时间。</p>
<p>通过这样的方式我们可以找到程序的性能瓶颈，然后可以有针对性地优化。</p>
<h3 id="合理使用copy与deepcopy"><a href="#合理使用copy与deepcopy" class="headerlink" title="合理使用copy与deepcopy"></a>合理使用copy与deepcopy</h3><p>对于dict和list等数据结构的对象，直接赋值使用的是引用的方式。而有些情况下需要复制整个对象，这时可以使用copy包里的copy和deepcopy，这两个函数的不同之处在于后者是递归复制的。</p>
<h3 id="lambda的使用并不会带来效率上的改变"><a href="#lambda的使用并不会带来效率上的改变" class="headerlink" title="lambda的使用并不会带来效率上的改变"></a>lambda的使用并不会带来效率上的改变</h3><h3 id="使用dict或set查找元素"><a href="#使用dict或set查找元素" class="headerlink" title="使用dict或set查找元素"></a>使用dict或set查找元素</h3><p>python dict和set都是使用hash表来实现(类似c++11标准库中unordered_map)，查找元素的时间复杂度是O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">range</span>(<span class="number">1000</span>)</span><br><span class="line">s = <span class="built_in">set</span>(a)</span><br><span class="line">d = <span class="built_in">dict</span>((i,<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> a)</span><br><span class="line">%timeit -n <span class="number">10000</span> <span class="number">100</span> <span class="keyword">in</span> d</span><br><span class="line">%timeit -n <span class="number">10000</span> <span class="number">100</span> <span class="keyword">in</span> s</span><br><span class="line"></span><br><span class="line"><span class="number">42.4</span> ns ± <span class="number">0.953</span> ns per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">10000</span> loops each)</span><br><span class="line"><span class="number">43.4</span> ns ± <span class="number">5.23</span> ns per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">10000</span> loops each)</span><br></pre></td></tr></table></figure>
<p>dict的效率略高(占用的空间也多一些)。</p>
<h3 id="合理使用生成器（generator）和yield"><a href="#合理使用生成器（generator）和yield" class="headerlink" title="合理使用生成器（generator）和yield"></a>合理使用生成器（generator）和yield</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: %timeit -n <span class="number">100</span> a = (i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000</span>))</span><br><span class="line">   ...: %timeit -n <span class="number">100</span> b = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000</span>)]</span><br><span class="line"></span><br><span class="line"><span class="number">100</span> loops, best of <span class="number">3</span>: <span class="number">1.54</span> ms per loop</span><br><span class="line"><span class="number">100</span> loops, best of <span class="number">3</span>: <span class="number">4.56</span> ms per loop</span><br></pre></td></tr></table></figure>
<p>使用()得到的是一个generator对象，所需要的内存空间与列表的大小无关，所以效率会高一些。在具体应用上，比如set(i for i in range(100000))会比set([i for i in range(100000)])快。</p>
<p>但是对于需要循环遍历的情况：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: %timeit -n <span class="number">10</span> <span class="keyword">for</span> x <span class="keyword">in</span> (i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000</span>)): <span class="keyword">pass</span></span><br><span class="line">   ...: %timeit -n <span class="number">10</span> <span class="keyword">for</span> x <span class="keyword">in</span> [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000</span>)]: <span class="keyword">pass</span></span><br><span class="line"><span class="number">10</span> loops, best of <span class="number">3</span>: <span class="number">6.51</span> ms per loop</span><br><span class="line"><span class="number">10</span> loops, best of <span class="number">3</span>: <span class="number">5.54</span> ms per loop</span><br></pre></td></tr></table></figure>
<p>后者的效率反而更高，但是如果循环里有break,用generator的好处是显而易见的。yield也是用于创建generator：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">yield_func</span>(<span class="params">ls</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> ls:</span><br><span class="line">        <span class="keyword">yield</span> i+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">not_yield_func</span>(<span class="params">ls</span>):</span></span><br><span class="line">    <span class="keyword">return</span> [i+<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> ls]</span><br><span class="line"></span><br><span class="line">ls = <span class="built_in">range</span>(<span class="number">1000000</span>)</span><br><span class="line">%timeit -n <span class="number">10</span> <span class="keyword">for</span> i <span class="keyword">in</span> yield_func(ls):<span class="keyword">pass</span></span><br><span class="line">%timeit -n <span class="number">10</span> <span class="keyword">for</span> i <span class="keyword">in</span> not_yield_func(ls):<span class="keyword">pass</span></span><br><span class="line"><span class="number">10</span> loops, best of <span class="number">3</span>: <span class="number">63.8</span> ms per loop</span><br><span class="line"><span class="number">10</span> loops, best of <span class="number">3</span>: <span class="number">62.9</span> ms per loop</span><br></pre></td></tr></table></figure>
<p>对于内存不是非常大的list，可以直接返回一个list，但是可读性yield更佳(人个喜好)。</p>
<h3 id="优化循环"><a href="#优化循环" class="headerlink" title="优化循环"></a>优化循环</h3><p>循环之外能做的事不要放在循环内，比如下面的优化可以快一倍：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">2</span>]: a = <span class="built_in">range</span>(<span class="number">10000</span>)</span><br><span class="line">   ...: size_a = <span class="built_in">len</span>(a)</span><br><span class="line">   ...: %timeit -n <span class="number">1000</span> <span class="keyword">for</span> i <span class="keyword">in</span> a: k = <span class="built_in">len</span>(a)</span><br><span class="line">   ...: %timeit -n <span class="number">1000</span> <span class="keyword">for</span> i <span class="keyword">in</span> a: k = size_a</span><br><span class="line"></span><br><span class="line"><span class="number">922</span> µs ± <span class="number">39.2</span> µs per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">1000</span> loops each)</span><br><span class="line"><span class="number">360</span> µs ± <span class="number">10.7</span> µs per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">1000</span> loops each)</span><br></pre></td></tr></table></figure>
<h3 id="优化包含多个判断表达式的顺序"><a href="#优化包含多个判断表达式的顺序" class="headerlink" title="优化包含多个判断表达式的顺序"></a>优化包含多个判断表达式的顺序</h3><p>对于and，应该把满足条件少的放在前面，对于or，把满足条件多的放在前面。如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">3</span>]: a = <span class="built_in">range</span>(<span class="number">2000</span>)</span><br><span class="line">   ...: %timeit -n <span class="number">100</span> [i <span class="keyword">for</span> i <span class="keyword">in</span> a <span class="keyword">if</span> <span class="number">10</span> &lt; i &lt; <span class="number">20</span> <span class="keyword">or</span> <span class="number">1000</span> &lt; i &lt; <span class="number">2000</span>]</span><br><span class="line">   ...: %timeit -n <span class="number">100</span> [i <span class="keyword">for</span> i <span class="keyword">in</span> a <span class="keyword">if</span> <span class="number">1000</span> &lt; i &lt; <span class="number">2000</span> <span class="keyword">or</span> <span class="number">100</span> &lt; i &lt; <span class="number">20</span>]</span><br><span class="line">   ...: %timeit -n <span class="number">100</span> [i <span class="keyword">for</span> i <span class="keyword">in</span> a <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">and</span> i &gt; <span class="number">1900</span>]</span><br><span class="line">   ...: %timeit -n <span class="number">100</span> [i <span class="keyword">for</span> i <span class="keyword">in</span> a <span class="keyword">if</span> i &gt; <span class="number">1900</span> <span class="keyword">and</span> i % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="number">220</span> µs ± <span class="number">9.16</span> µs per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">100</span> loops each)</span><br><span class="line"><span class="number">178</span> µs ± <span class="number">10.5</span> µs per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">100</span> loops each)</span><br><span class="line"><span class="number">138</span> µs ± <span class="number">12.1</span> µs per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">100</span> loops each)</span><br><span class="line"><span class="number">84.2</span> µs ± <span class="number">5.34</span> µs per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">100</span> loops each)</span><br></pre></td></tr></table></figure>
<h3 id="使用join合并迭代器中的字符串"><a href="#使用join合并迭代器中的字符串" class="headerlink" title="使用join合并迭代器中的字符串"></a>使用join合并迭代器中的字符串</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">4</span>]: %%timeit</span><br><span class="line">   ...: s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">   ...: <span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">   ...:         s += i</span><br><span class="line">   ...:</span><br><span class="line"><span class="number">10000</span> loops, best of <span class="number">3</span>: <span class="number">59.8</span> µs per loop</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: %%timeit</span><br><span class="line">s = <span class="string">&#x27;&#x27;</span>.join(a)</span><br><span class="line">   ...:</span><br><span class="line"><span class="number">100000</span> loops, best of <span class="number">3</span>: <span class="number">11.8</span> µs per loop</span><br></pre></td></tr></table></figure>
<p><code>join</code>对于累加的方式，有大约5倍的提升。</p>
<h3 id="选择合适的格式化字符方式"><a href="#选择合适的格式化字符方式" class="headerlink" title="选择合适的格式化字符方式"></a>选择合适的格式化字符方式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">6</span>]: s1, s2 = <span class="string">&#x27;ax&#x27;</span>, <span class="string">&#x27;bx&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: %timeit -n <span class="number">100000</span> <span class="string">&#x27;abc%s%s&#x27;</span> % (s1, s2)</span><br><span class="line">    ...: %timeit -n <span class="number">100000</span> <span class="string">&#x27;abc&#123;0&#125;&#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(s1, s2)</span><br><span class="line">    ...: %timeit -n <span class="number">100000</span> <span class="string">&#x27;abc&#x27;</span> + s1 + s2</span><br><span class="line"><span class="number">221</span> ns ± <span class="number">6.26</span> ns per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">100000</span> loops each)</span><br><span class="line"><span class="number">145</span> ns ± <span class="number">8.2</span> ns per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">100000</span> loops each)</span><br><span class="line"><span class="number">132</span> ns ± <span class="number">5.18</span> ns per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">100000</span> loops each)</span><br></pre></td></tr></table></figure>
<p>三种情况中，%的方式是最慢的，但是三者的差距并不大（都非常快）。(个人觉得format的可读性最好)</p>
<h3 id="不借助中间变量交换两个变量的值"><a href="#不借助中间变量交换两个变量的值" class="headerlink" title="不借助中间变量交换两个变量的值"></a>不借助中间变量交换两个变量的值</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">8</span>]: %%timeit -n <span class="number">10000</span></span><br><span class="line">    a,b=<span class="number">1</span>,<span class="number">2</span></span><br><span class="line">   ....: c=a;a=b;b=c;</span><br><span class="line">   ....:</span><br><span class="line"><span class="number">10000</span> loops, best of <span class="number">3</span>: <span class="number">172</span> ns per loop</span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: %%timeit -n <span class="number">10000</span></span><br><span class="line">a,b=<span class="number">1</span>,<span class="number">2</span></span><br><span class="line">a,b=b,a</span><br><span class="line">   ....:</span><br><span class="line"><span class="number">10000</span> loops, best of <span class="number">3</span>: <span class="number">86</span> ns per loop</span><br></pre></td></tr></table></figure>
<p>使用a,b=b,a而不是c=a;a=b;b=c;来交换a,b的值，可以快1倍以上。</p>
<h3 id="使用if-is"><a href="#使用if-is" class="headerlink" title="使用if is"></a>使用if is</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">10</span>]: a = <span class="built_in">range</span>(<span class="number">10000</span>)</span><br><span class="line">    ...: %timeit -n <span class="number">100</span> [i <span class="keyword">for</span> i <span class="keyword">in</span> a <span class="keyword">if</span> i == <span class="literal">True</span>]</span><br><span class="line">    ...: %timeit -n <span class="number">100</span> [i <span class="keyword">for</span> i <span class="keyword">in</span> a <span class="keyword">if</span> i <span class="keyword">is</span> <span class="literal">True</span>]</span><br><span class="line"></span><br><span class="line"><span class="number">416</span> µs ± <span class="number">14.3</span> µs per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">100</span> loops each)</span><br><span class="line"><span class="number">316</span> µs ± <span class="number">7.83</span> µs per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">100</span> loops each)</span><br></pre></td></tr></table></figure>
<h3 id="使用级联比较x-lt-y-lt-z"><a href="#使用级联比较x-lt-y-lt-z" class="headerlink" title="使用级联比较x &lt; y &lt; z"></a>使用级联比较x &lt; y &lt; z</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">11</span>]: x, y, z = <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br><span class="line">In [<span class="number">12</span>]: timeit -n <span class="number">1000000</span> <span class="keyword">if</span> x &lt; y &lt; z:<span class="keyword">pass</span></span><br><span class="line">    ...: %timeit -n <span class="number">1000000</span> <span class="keyword">if</span> x &lt; y <span class="keyword">and</span> y &lt; z:<span class="keyword">pass</span></span><br><span class="line"><span class="number">76.9</span> ns ± <span class="number">2.24</span> ns per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">1000000</span> loops each)</span><br><span class="line"><span class="number">82.9</span> ns ± <span class="number">1.18</span> ns per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">1000000</span> loops each)</span><br></pre></td></tr></table></figure>
<p>x &lt; y &lt; z效率略高，而且可读性更好。</p>
<h3 id="使用-而不是pow"><a href="#使用-而不是pow" class="headerlink" title="使用**而不是pow"></a>使用**而不是pow</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">13</span>]: %timeit -n <span class="number">10000</span> c = <span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">20</span>)</span><br><span class="line">    ...: %timeit -n <span class="number">10000</span> c = <span class="number">2</span>**<span class="number">20</span></span><br><span class="line"><span class="number">363</span> ns ± <span class="number">20.3</span> ns per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">10000</span> loops each)</span><br><span class="line"><span class="number">13.4</span> ns ± <span class="number">3.02</span> ns per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">10000</span> loops each)</span><br></pre></td></tr></table></figure>
<p><code>**</code>就是快10倍以上！</p>
<h3 id="使用-cProfile-cStringIO-和-cPickle等用c实现相同功能（分别对应profile-StringIO-pickle）的包"><a href="#使用-cProfile-cStringIO-和-cPickle等用c实现相同功能（分别对应profile-StringIO-pickle）的包" class="headerlink" title="使用 cProfile, cStringIO 和 cPickle等用c实现相同功能（分别对应profile, StringIO, pickle）的包"></a>使用 cProfile, cStringIO 和 cPickle等用c实现相同功能（分别对应profile, StringIO, pickle）的包</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">14</span>]: <span class="keyword">import</span> cPickle</span><br><span class="line">In [<span class="number">15</span>]: <span class="keyword">import</span> pickle</span><br><span class="line">In [<span class="number">16</span>]: a = <span class="built_in">range</span>(<span class="number">10000</span>)</span><br><span class="line">    ...: %timeit -n <span class="number">100</span> x = cPickle.dumps(a)</span><br><span class="line">    ...: %timeit -n <span class="number">100</span> x = pickle.dumps(a)</span><br><span class="line"></span><br><span class="line"><span class="number">100</span> loops, best of <span class="number">3</span>: <span class="number">1.58</span> ms per loop</span><br><span class="line"><span class="number">100</span> loops, best of <span class="number">3</span>: <span class="number">17</span> ms per loop</span><br></pre></td></tr></table></figure>
<p>由c实现的包，速度快10倍以上！</p>
<h3 id="使用最佳的反序列化方式"><a href="#使用最佳的反序列化方式" class="headerlink" title="使用最佳的反序列化方式"></a>使用最佳的反序列化方式</h3><p>下面比较了eval, cPickle, json方式三种对相应字符串反序列化的效率：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">17</span>]: <span class="keyword">import</span> json</span><br><span class="line">    ...: <span class="keyword">import</span> cPickle</span><br><span class="line">    ...: a = <span class="built_in">range</span>(<span class="number">10000</span>)</span><br><span class="line">    ...: s1 = <span class="built_in">str</span>(a)</span><br><span class="line">    ...: s2 = cPickle.dumps(a)</span><br><span class="line">    ...: s3 = json.dumps(a)</span><br><span class="line">    ...: %timeit -n <span class="number">100</span> x = <span class="built_in">eval</span>(s1)</span><br><span class="line">    ...: %timeit -n <span class="number">100</span> x = cPickle.loads(s2)</span><br><span class="line">    ...: %timeit -n <span class="number">100</span> x = json.loads(s3)</span><br><span class="line"><span class="number">100</span> loops, best of <span class="number">3</span>: <span class="number">16.8</span> ms per loop</span><br><span class="line"><span class="number">100</span> loops, best of <span class="number">3</span>: <span class="number">2.02</span> ms per loop</span><br><span class="line"><span class="number">100</span> loops, best of <span class="number">3</span>: <span class="number">798</span> µs per loop</span><br></pre></td></tr></table></figure>
<p>可见json比cPickle快近3倍，比eval快20多倍。</p>
<h3 id="使用C扩展-Extension"><a href="#使用C扩展-Extension" class="headerlink" title="使用C扩展(Extension)"></a>使用C扩展(Extension)</h3><p>目前主要有CPython(python最常见的实现的方式)原生API, ctypes,Cython，cffi三种方式，它们的作用是使得Python程序可以调用由C编译成的动态链接库，其特点分别是：</p>
<p><strong>CPython原生API:</strong> 通过引入Python.h头文件，对应的C程序中可以直接使用Python的数据结构。实现过程相对繁琐，但是有比较大的适用范围。</p>
<p><strong>ctypes:</strong> 通常用于封装(wrap)C程序，让纯Python程序调用动态链接库（Windows中的dll或Unix中的so文件）中的函数。如果想要在python中使用已经有C类库，使用ctypes是很好的选择，有一些基准测试下，python2+ctypes是性能最好的方式。</p>
<p><strong>Cython:</strong> Cython是CPython的超集，用于简化编写C扩展的过程。Cython的优点是语法简洁，可以很好地兼容numpy等包含大量C扩展的库。Cython的使得场景一般是针对项目中某个算法或过程的优化。在某些测试中，可以有几百倍的性能提升。</p>
<p><strong>cffi:</strong> cffi的就是ctypes在pypy（详见下文）中的实现，同进也兼容CPython。cffi提供了在python使用C类库的方式，可以直接在python代码中编写C代码，同时支持链接到已有的C类库。</p>
<p>使用这些优化方式一般是针对已有项目性能瓶颈模块的优化，可以在少量改动原有项目的情况下大幅度地提高整个程序的运行效率。</p>
<h3 id="并行编程"><a href="#并行编程" class="headerlink" title="并行编程"></a>并行编程</h3><p>因为GIL的存在，Python很难充分利用多核CPU的优势。但是，可以通过内置的模块multiprocessing实现下面几种并行模式：</p>
<p><strong>多进程：</strong> 对于CPU密集型的程序，可以使用multiprocessing的Process,Pool等封装好的类，通过多进程的方式实现并行计算。但是因为进程中的通信成本比较大，对于进程之间需要大量数据交互的程序效率未必有大的提高。</p>
<p><strong>多线程：</strong> 对于IO密集型的程序，multiprocessing.dummy模块使用multiprocessing的接口封装threading，使得多线程编程也变得非常轻松(比如可以使用Pool的map接口，简洁高效)。</p>
<p><strong>分布式：</strong> multiprocessing中的Managers类提供了可以在不同进程之共享数据的方式，可以在此基础上开发出分布式的程序。</p>
<p>不同的业务场景可以选择其中的一种或几种的组合实现程序性能的优化。对于详细情况可以查看本人博客<a href="https://javyxu.cn/python/python_multprogram/">Python并行编程</a></p>
<h3 id="终级大杀器：PyPy"><a href="#终级大杀器：PyPy" class="headerlink" title="终级大杀器：PyPy"></a>终级大杀器：PyPy</h3><p>PyPy是用RPython(CPython的子集)实现的Python，根据官网的基准测试数据，它比CPython实现的Python要快6倍以上。快的原因是使用了Just-in-Time(JIT)编译器，即动态编译器，与静态编译器(如gcc,javac等)不同，它是利用程序运行的过程的数据进行优化。由于历史原因，目前pypy中还保留着GIL，不过正在进行的STM项目试图将PyPy变成没有GIL的Python。</p>
<p>如果python程序中含有C扩展(非cffi的方式)，JIT的优化效果会大打折扣，甚至比CPython慢（比Numpy）。所以在PyPy中最好用纯Python或使用cffi扩展。</p>
<p>随着STM，Numpy等项目的完善，相信PyPy将会替代CPython。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python并行编程</title>
    <url>/python/python_multprogram/</url>
    <content><![CDATA[<h3 id="Python并行编程"><a href="#Python并行编程" class="headerlink" title="Python并行编程"></a>Python并行编程</h3><p>由于GIL的存在，Python很难充分利用多核CPU的优势。但是，可以通过内置的模块multiprocessing实现下面几种并行模式：</p>
<ul>
<li>多进程</li>
</ul>
<p>对于CPU密集型的程序，可以使用multiprocessing的Process,Pool等封装好的类，通过多进程的方式实现并行计算。但是因为进程中的通信成本比较大，对于进程之间需要大量数据交互的程序效率未必有大的提高。</p>
<ul>
<li>多线程</li>
</ul>
<p>对于IO密集型的程序，multiprocessing.dummy模块使用multiprocessing的接口封装threading，使得多线程编程也变得非常轻松(比如可以使用Pool的map接口，简洁高效)。</p>
<ul>
<li>分布式</li>
</ul>
<p>multiprocessing中的Managers类提供了可以在不同进程之共享数据的方式，可以在此基础上开发出分布式的程序。</p>
<p>下面对Python的多进程、多线程等进行一一介绍：</p>
<h3 id="Python线程与进程简介"><a href="#Python线程与进程简介" class="headerlink" title="Python线程与进程简介"></a>Python线程与进程简介</h3><a id="more"></a>
<h4 id="进程与线程的历史"><a href="#进程与线程的历史" class="headerlink" title="进程与线程的历史"></a>进程与线程的历史</h4><p>我们都知道计算机是由硬件和软件组成的。硬件中的CPU是计算机的核心，它承担计算机的所有任务。操作系统是运行在硬件之上的软件，是计算机的管理者，它负责资源的管理和分配、任务的调度。程序是运行在系统上的具有某种功能的软件，比如说浏览器，音乐播放器等。每次执行程序的时候，都会完成一定的功能，比如说浏览器帮我们打开网页，为了保证其独立性，就需要一个专门的管理和控制执行程序的数据结构——进程控制块。进程就是一个程序在一个数据集上的一次动态执行过程。进程一般由程序、数据集、进程控制块三部分组成。我们编写的程序用来描述进程要完成哪些功能以及如何完成；数据集则是程序在执行过程中所需要使用的资源；进程控制块用来记录进程的外部特征，描述进程的执行变化过程，系统可以利用它来控制和管理进程，它是系统感知进程存在的唯一标志。</p>
<p>在早期的操作系统里，计算机只有一个核心，进程执行程序的最小单位，任务调度采用时间片轮转的抢占式方式进行进程调度。每个进程都有各自的一块独立的内存，保证进程彼此间的内存地址空间的隔离。随着计算机技术的发展，进程出现了很多弊端，一是进程的创建、撤销和切换的开销比较大，二是由于对称多处理机（对称多处理机（SymmetricalMulti-Processing）又叫SMP，是指在一个计算机上汇集了一组处理器(多CPU)，各CPU之间共享内存子系统以及总线结构）的出现，可以满足多个运行单位，而多进程并行开销过大。 这个时候就引入了线程的概念。线程也叫轻量级进程，它是一个基本的CPU执行单元，也是程序执行过程中的最小单元，由线程ID、程序计数器、寄存器集合 和堆栈共同组成。线程的引入减小了程序并发执行时的开销，提高了操作系统的并发性能。线程没有自己的系统资源，只拥有在运行时必不可少的资源。但线程可以与同属与同一进程的其他线程共享进程所拥有的其他资源。</p>
<h4 id="进程与线程之间的关系"><a href="#进程与线程之间的关系" class="headerlink" title="进程与线程之间的关系"></a>进程与线程之间的关系</h4><p>线程是属于进程的，线程运行在进程空间内，同一进程所产生的线程共享同一内存空间，当进程退出时该进程所产生的线程都会被强制退出并清除。线程可与属于同一进程的其它线程共享进程所拥有的全部资源，但是其本身基本上不拥有系统资源，只拥有一点在运行中必不可少的信息(如程序计数器、一组寄存器和栈)。</p>
<h4 id="Python进程"><a href="#Python进程" class="headerlink" title="Python进程"></a>Python进程</h4><p>multiprocessing是python的多进程管理包。</p>
<h5 id="multiprocessing模块"><a href="#multiprocessing模块" class="headerlink" title="multiprocessing模块"></a>multiprocessing模块</h5><p>直接从侧面用subprocesses替换线程使用GIL的方式，由于这一点，multiprocessing模块可以让程序员在给定的机器上充分的利用CPU。在multiprocessing中，通过创建Process对象生成进程，然后调用它的start()方法，具体实现请看下面代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">name</span>):</span></span><br><span class="line">  print(<span class="string">&#x27;hello&#x27;</span>, name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">  p = Process(target=func, args=(<span class="string">&#x27;test&#x27;</span>,))</span><br><span class="line">  p.start()</span><br><span class="line">  p.join()  <span class="comment"># 等待进程执行完毕</span></span><br></pre></td></tr></table></figure>
<p>在使用并发设计的时候最好尽可能的避免共享数据，尤其是在使用多进程的时候。 如果你真有需要要共享数据， multiprocessing提供了两种方式。</p>
<ol>
<li><p>multiprocessing，Array,Value</p>
<p>数据可以用Value或Array存储在一个共享内存map里，如下：</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Array, Value, Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    a.value = <span class="number">3.333333333333333</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(b)):</span><br><span class="line">        b[i] = -b[i]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    num = Value(<span class="string">&#x27;d&#x27;</span>, <span class="number">0.0</span>)</span><br><span class="line">    arr = Array(<span class="string">&#x27;i&#x27;</span>, <span class="built_in">range</span>(<span class="number">11</span>))</span><br><span class="line"></span><br><span class="line">    c = Process(target=func, args=(num, arr))</span><br><span class="line">    d= Process(target=func, args=(num, arr))</span><br><span class="line">    c.start()</span><br><span class="line">    d.start()</span><br><span class="line">    c.join()</span><br><span class="line">    d.join()</span><br><span class="line"></span><br><span class="line">    print(num.value)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">        print(i)</span><br><span class="line">输出：</span><br><span class="line">　　<span class="number">3.1415927</span></span><br><span class="line">　　[<span class="number">0</span>, -<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">3</span>, -<span class="number">4</span>, -<span class="number">5</span>, -<span class="number">6</span>, -<span class="number">7</span>, -<span class="number">8</span>, -<span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<p>  创建num和arr时，”d”和”i”参数由Array模块使用的typecodes创建：”d”表示一个双精度的浮点数，”i”表示一个有符号的整数，这些共享对象将被线程安全的处理。</p>
<p>  Array(‘i’, range(10))中的’i’参数：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;c&#39;: ctypes.c_char　　　　 &#39;u&#39;: ctypes.c_wchar　　　　&#39;b&#39;: ctypes.c_byte　　　　 &#39;B&#39;: ctypes.c_ubyte</span><br><span class="line">&#39;h&#39;: ctypes.c_short　　　  &#39;H&#39;: ctypes.c_ushort　　  &#39;i&#39;: ctypes.c_int　　　　　 &#39;I&#39;: ctypes.c_uint</span><br><span class="line">&#39;l&#39;: ctypes.c_long,　　　　&#39;L&#39;: ctypes.c_ulong　　　　&#39;f&#39;: ctypes.c_float　　　　&#39;d&#39;: ctypes.c_double</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>multiprocessing，Manager</p>
<p>由Manager()返回的manager提供list, dict, Namespace, Lock, RLock, Semaphore, BoundedSemaphore, Condition, Event, Barrier, Queue, Value and Array类型的支持。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Manager</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">d, l</span>):</span></span><br><span class="line">    d[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;test&quot;</span></span><br><span class="line">    d[<span class="string">&quot;age&quot;</span>] = <span class="number">18</span></span><br><span class="line">    d[<span class="string">&quot;Job&quot;</span>] = <span class="string">&quot;pythoner&quot;</span></span><br><span class="line">    l.reverse()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">with</span> Manager() <span class="keyword">as</span> man:</span><br><span class="line">        d = man.<span class="built_in">dict</span>()</span><br><span class="line">        l = man.<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">        p = Process(target=f, args=(d, l))</span><br><span class="line">        p.start()</span><br><span class="line">        p.join()</span><br><span class="line"></span><br><span class="line">        print(d)</span><br><span class="line">        print(l)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">　　&#123;<span class="number">0.25</span>: <span class="literal">None</span>, <span class="number">1</span>: <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line">　　[<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>  Server process manager比shared memory更灵活，因为它可以支持任意的对象类型。另外，一个单独的manager可以通过进程在网络上不同的计算机之间共享，不过他比shared memory要慢。</p>
<h5 id="进程池（Using-a-pool-of-workers）"><a href="#进程池（Using-a-pool-of-workers）" class="headerlink" title="进程池（Using a pool of workers）"></a>进程池（Using a pool of workers）</h5><p>Pool类描述了一个工作进程池，他有几种不同的方法让任务卸载工作进程。</p>
<p>进程池内部维护一个进程序列，当使用时，则去进程池中获取一个进程，如果进程池序列中没有可供使用的进进程，那么程序就会等待，直到进程池中有可用进程为止。</p>
<p>我们可以用Pool类创建一个进程池，展开提交的任务给进程池。比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment">#apply</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span>(<span class="params">i</span>):</span></span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    print(i)</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    pool = Pool(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">31</span>):</span><br><span class="line">        pool.apply(func=f1, args=(i,))</span><br><span class="line"></span><br><span class="line"><span class="comment">#apply_async</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span>(<span class="params">i</span>):</span></span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    print(i)</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span>(<span class="params">arg</span>):</span></span><br><span class="line">    print(arg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    pool = Pool(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">31</span>):</span><br><span class="line">        pool.apply_async(func=f1, args=(i,), callback=f2)</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br></pre></td></tr></table></figure>
<p>一个进程池对象可以控制工作进程池的哪些工作可以被提交，它支持超时和回调的异步结果，有一个类似map的实现。</p>
<ul>
<li><p>processes: 使用的工作进程的数量，如果processes是None那么使用os.cpu_count()返回的数量。</p>
</li>
<li><p>initializer: 如果initializer是None，那么每一个工作进程在开始的时候会调用initializer(*initargs)。</p>
</li>
<li><p>maxtasksperchild: 工作进程退出之前可以完成的任务数，完成后用一个心的工作进程来替代原进程，来让闲置的资源被释放。maxtasksperchild默认是None，意味着只要Pool存在工作进程就会一直存活。</p>
</li>
<li><p>context: 用在制定工作进程启动时的上下文，一般使用multiprocessing.Pool()或者一个context对象的Pool()方法来创建一个池，两种方法都适当的设置了context</p>
</li>
</ul>
<h5 id="进程池的方法"><a href="#进程池的方法" class="headerlink" title="进程池的方法"></a>进程池的方法</h5><ul>
<li><p>apply(func[, args[, kwds]])</p>
<p>使用arg和kwds参数调用func函数，结果返回前会一直阻塞，由于这个原因，apply_async()更适合并发执行，另外，func函数仅被pool中的一个进程运行。</p>
</li>
<li><p>apply_async(func[, args[, kwds[, callback[, error_callback]]]])</p>
<p>apply()方法的一个变体，会返回一个结果对象。如果callback被指定，那么callback可以接收一个参数然后被调用，当结果准备好回调时会调用callback，调用失败时，则用error_callback替换callback。Callbacks应被立即完成，否则处理结果的线程会被阻塞。</p>
</li>
<li><p>close()</p>
<p>阻止更多的任务提交到pool，待任务完成后，工作进程会退出。</p>
</li>
<li><p>terminate()</p>
<p>不管任务是否完成，立即停止工作进程。在对pool对象进程垃圾回收的时候，会立即调用terminate()。</p>
</li>
<li><p>join()</p>
<p>wait工作线程的退出，在调用join()前，必须调用close()或者terminate()。这样是因为被终止的进程需要被父进程调用wait（join等价与wait），否则进程会成为僵尸进程。</p>
</li>
<li><p>map(func, iterable[, chunksize])</p>
</li>
<li><p>map_async(func, iterable[, chunksize[, callback[, error_callback]]])</p>
</li>
<li><p>imap(func, iterable[, chunksize])</p>
</li>
<li><p>imap_unordered(func, iterable[, chunksize])</p>
</li>
<li><p>starmap(func, iterable[, chunksize])</p>
</li>
<li><p>starmap_async(func, iterable[, chunksize[, callback[, error_back]]])</p>
</li>
</ul>
<h4 id="Python线程"><a href="#Python线程" class="headerlink" title="Python线程"></a>Python线程</h4><p>Threading用于提供线程相关的操作，线程是应用程序中工作的最小单元。</p>
<h5 id="threading模块"><a href="#threading模块" class="headerlink" title="threading模块"></a>threading模块</h5><p>threading模块建立在_thread模块之上。thread模块以低级、原始的方式来处理和控制线程，而threading模块通过对thread进行二次封装，提供了更方便的api来处理线程。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    thread worker function</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">&quot;The num is  %d&quot;</span> % num)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">    t = threading.Thread(target=worker, args=(i,)，name=<span class="string">&quot;t.%d&quot;</span> % i)</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure>
<p>上述代码创建了20个”前台”线程，然后控制器就交给了CPU，CPU根据指定算法进行调度，分片执行指令。</p>
<p><strong>Thread方法说明:</strong></p>
<ul>
<li><p>t.start(): 激活线程，</p>
</li>
<li><p>t.getName(): 获取线程的名称</p>
</li>
<li><p>t.setName()： 设置线程的名称 </p>
</li>
<li><p>t.name: 获取或设置线程的名称</p>
</li>
<li><p>t.is_alive()： 判断线程是否为激活状态</p>
</li>
<li><p>t.isAlive()：判断线程是否为激活状态</p>
</li>
<li><p>t.setDaemon(): 设置为后台线程或前台线程（默认：False）;通过一个布尔值设置线程是否为守护线程，必须在执行start()方法之后才可以使用。如果是后台线程，主线程执行过程中，后台线程也在进行，主线程执行完毕后，后台线程不论成功与否，均停止；如果是前台线程，主线程执行过程中，前台线程也在进行，主线程执行完毕后，等待前台线程也执行完成后，程序停止</p>
</li>
<li><p>t.isDaemon(): 判断是否为守护线程</p>
</li>
<li><p>t.ident: 获取线程的标识符。线程标识符是一个非零整数，只有在调用了start()方法之后该属性才有效，否则它只返回None。</p>
</li>
<li><p>t.join(): 逐个执行每个线程，执行完毕后继续往下执行，该方法使得多线程变得无意义</p>
</li>
<li><p>t.run(): 线程被cpu调度后自动执行线程对象的run方法</p>
</li>
</ul>
<h5 id="线程锁threading-RLock和threading-Lock"><a href="#线程锁threading-RLock和threading-Lock" class="headerlink" title="线程锁threading.RLock和threading.Lock"></a>线程锁threading.RLock和threading.Lock</h5><p>由于线程之间是进行随机调度，并且每个线程可能只执行n条执行之后，CPU接着执行其他线程。为了保证数据的准确性，引入了锁的概念。所以，可能出现如下问题：</p>
<p>例：假设列表A的所有元素就为0，当一个线程从前向后打印列表的所有元素，另外一个线程则从后向前修改列表的元素为1,那么输出的时候，列表的元素就会一部分为0，一部分为1,这就导致了数据的不一致。锁的出现解决了这个问题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">global_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">lock = threading.RLock()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Func</span>():</span></span><br><span class="line">    lock.acquire()  <span class="comment"># 获得锁</span></span><br><span class="line">    <span class="keyword">global</span> global_num</span><br><span class="line">    global_num += <span class="number">1</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(global_num)</span><br><span class="line">    lock.release()  <span class="comment"># 释放锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    t = threading.Thread(target=Func)</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure>
<h5 id="threading-RLock和threading-Lock的区别"><a href="#threading-RLock和threading-Lock的区别" class="headerlink" title="threading.RLock和threading.Lock的区别"></a>threading.RLock和threading.Lock的区别</h5><p>RLock允许在同一线程中被多次acquire。而Lock却不允许这种情况。 如果使用RLock，那么acquire和release必须成对出现，即调用了n次acquire，必须调用n次的release才能真正释放所占用的琐。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">lock = threading.Lock()    <span class="comment">#Lock对象</span></span><br><span class="line">lock.acquire()</span><br><span class="line">lock.acquire()  <span class="comment">#产生了死琐。</span></span><br><span class="line">lock.release()</span><br><span class="line">lock.release()　</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">rLock = threading.RLock()  <span class="comment">#RLock对象</span></span><br><span class="line">rLock.acquire()</span><br><span class="line">rLock.acquire()    <span class="comment">#在同一线程内，程序不会堵塞。</span></span><br><span class="line">rLock.release()</span><br><span class="line">rLock.release()</span><br></pre></td></tr></table></figure>
<h5 id="threading-Event"><a href="#threading-Event" class="headerlink" title="threading.Event"></a>threading.Event</h5><p>python线程的事件用于主线程控制其他线程的执行，事件主要提供了三个方法set、wait、clear。</p>
<p>事件处理的机制: 全局定义了一个”Flag”，如果”Flag”值为False，那么当程序执行 event.wait方法时就会阻塞，如果”Flag”值为True，那么event.wait 方法时便不再阻塞。</p>
<ul>
<li><p>clear：将”Flag”设置为False</p>
</li>
<li><p>set：将”Flag”设置为True</p>
</li>
<li><p>Event.isSet()：判断标识位是否为Ture。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do</span>(<span class="params">event</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line">    event.wait()</span><br><span class="line">    print(<span class="string">&#x27;execute&#x27;</span>)</span><br><span class="line"></span><br><span class="line">event_obj = threading.Event()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    t = threading.Thread(target=do, args=(event_obj,))</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line">event_obj.clear()</span><br><span class="line">inp = <span class="built_in">input</span>(<span class="string">&#x27;input:&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> inp == <span class="string">&#x27;true&#x27;</span>:</span><br><span class="line">    event_obj.<span class="built_in">set</span>()</span><br></pre></td></tr></table></figure>
<p>当线程执行的时候，如果flag为False，则线程会阻塞，当flag为True的时候，线程不会阻塞。它提供了本地和远程的并发性。</p>
<h5 id="threading-Condition"><a href="#threading-Condition" class="headerlink" title="threading.Condition"></a>threading.Condition</h5><p>一个condition变量总是与某些类型的锁相联系，这个可以使用默认的情况或创建一个，当几个condition变量必须共享和同一个锁的时候，是很有用的。锁是conditon对象的一部分：没有必要分别跟踪。</p>
<p>condition变量服从上下文管理协议：with语句块封闭之前可以获取与锁的联系。acquire()和release()会调用与锁相关联的相应的方法。</p>
<p>其他和锁关联的方法必须被调用，wait()方法会释放锁，当另外一个线程使用 notify() or notify_all()唤醒它之前会一直阻塞。一旦被唤醒，wait()会重新获得锁并返回，</p>
<p>Condition类实现了一个conditon变量。这个conditiaon变量允许一个或多个线程等待，直到他们被另一个线程通知。 如果lock参数，被给定一个非空的值，那么他必须是一个lock或者Rlock对象，它用来做底层锁。否则，会创建一个新的Rlock对象，用来做底层锁。</p>
<p>wait(timeout=None)：等待通知，或者等到设定的超时时间。当调用这wait()方法时，如果调用它的线程没有得到锁，那么会抛出一个RuntimeError 异常。wait()释放锁以后，在被调用相同条件的另一个进程用notify()或者notify_all( 叫醒之前 会一直阻塞。wait()还可以指定一个超时时间。<br>如果有等待的线程，notify()方法会唤醒一个在等待conditon变量的线程。notify_all()则会唤醒所有在等待conditon变量的线程。</p>
<p><strong>注意：</strong> notify()和notify_all()不会释放锁，也就是说，线程被唤醒后不会立刻返回他们的wait()调用。除非线程调用notify()和notify_all()之后放弃了锁的所有权。</p>
<p>在典型的设计风格里，利用condition变量用锁去通许访问一些共享状态，线程在获取到它想得到的状态前，会反复调用wait()。修改状态的线程在他们状态改变时调用 notify()或者notify_all()，用这种方式，线程会尽可能的获取到想要的一个等待者状态。 比如：生产者-消费者模型，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>(<span class="params">cond</span>):</span></span><br><span class="line">    <span class="keyword">with</span> cond:</span><br><span class="line">        print(<span class="string">&quot;consumer before wait&quot;</span>)</span><br><span class="line">        cond.wait()</span><br><span class="line">        print(<span class="string">&quot;consumer after wait&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span>(<span class="params">cond</span>):</span></span><br><span class="line">    <span class="keyword">with</span> cond:</span><br><span class="line">        print(<span class="string">&quot;producer before notifyAll&quot;</span>)</span><br><span class="line">        cond.notifyAll()</span><br><span class="line">        print(<span class="string">&quot;producer after notifyAll&quot;</span>)</span><br><span class="line"></span><br><span class="line">condition = threading.Condition()</span><br><span class="line">c1 = threading.Thread(name=<span class="string">&quot;c1&quot;</span>, target=consumer, args=(condition,))</span><br><span class="line">c2 = threading.Thread(name=<span class="string">&quot;c2&quot;</span>, target=consumer, args=(condition,))</span><br><span class="line"></span><br><span class="line">p = threading.Thread(name=<span class="string">&quot;p&quot;</span>, target=producer, args=(condition,))</span><br><span class="line"></span><br><span class="line">c1.start()</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">c2.start()</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">p.start()</span><br></pre></td></tr></table></figure>
<h5 id="queue模块"><a href="#queue模块" class="headerlink" title="queue模块"></a>queue模块</h5><p>Queue就是对队列，它是线程安全的</p>
<p>举例来说，我们去麦当劳吃饭。饭店里面有厨师职位，前台负责把厨房做好的饭卖给顾客，顾客则去前台领取做好的饭。这里的前台就相当于我们的队列。形成管道样，厨师做好饭通过前台传送给顾客，所谓单向队列</p>
<p>这个模型也叫生产者-消费者模型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line">q = queue.Queue(maxsize=<span class="number">0</span>)  <span class="comment"># 构造一个先进显出队列，maxsize指定队列长度，为0 时，表示队列长度无限制。</span></span><br><span class="line"></span><br><span class="line">q.join()    <span class="comment"># 等到队列为kong的时候，在执行别的操作</span></span><br><span class="line">q.qsize()   <span class="comment"># 返回队列的大小 （不可靠）</span></span><br><span class="line">q.empty()   <span class="comment"># 当队列为空的时候，返回True 否则返回False （不可靠）</span></span><br><span class="line">q.full()    <span class="comment"># 当队列满的时候，返回True，否则返回False （不可靠）</span></span><br><span class="line">q.put(item, block=<span class="literal">True</span>, timeout=<span class="literal">None</span>) <span class="comment"># 将item放入Queue尾部，item必须存在，可以参数block默认为True,表示当队列满时，会等待队列给出可用位置，为False时为非阻塞，此时如果队列已满，会引发queue.Full 异常。 可选参数timeout，表示 会阻塞设置的时间，过后， 如果队列无法给出放入item的位置，则引发 queue.Full 异常</span></span><br><span class="line"></span><br><span class="line">q.get(block=<span class="literal">True</span>, timeout=<span class="literal">None</span>) <span class="comment"># 移除并返回队列头部的一个值，可选参数block默认为True，表示获取值的时候，如果队列为空，则阻塞，为False时，不阻塞，若此时队列为空，则引发 queue.Empty异常。 可选参数timeout，表示会阻塞设置的时候，过后，如果队列为空，则引发Empty异常。</span></span><br><span class="line">q.put_nowait(item) <span class="comment"># 等效于 put(item,block=False)</span></span><br><span class="line">q.get_nowait() <span class="comment"># 等效于 get(item,block=False)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">message = Queue.Queue(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span>(<span class="params">i</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        message.put(i)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>(<span class="params">i</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        msg = message.get()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):</span><br><span class="line">    t = threading.Thread(target=producer, args=(i,))</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    t = threading.Thread(target=consumer, args=(i,))</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure>
<p>现在我们自己做个线程池：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 简单往队列中传输线程数</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Threadingpool</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,max_num = <span class="number">10</span></span>):</span></span><br><span class="line">        self.queue = queue.Queue(max_num)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_num):</span><br><span class="line">            self.queue.put(threading.Thread)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getthreading</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.queue.get()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addthreading</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.queue.put(threading.Thread)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">p, i</span>):</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(i)</span><br><span class="line">    p.addthreading()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    p = Threadingpool()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">        thread = p.getthreading()</span><br><span class="line">        t = thread(target = func, args = (p,i))</span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 往队列中无限添加任务</span></span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> contextlib</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">StopEvent = <span class="built_in">object</span>()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, max_num</span>):</span></span><br><span class="line">        self.q = queue.Queue()</span><br><span class="line">        self.max_num = max_num</span><br><span class="line"></span><br><span class="line">        self.terminal = <span class="literal">False</span></span><br><span class="line">        self.generate_list = []</span><br><span class="line">        self.free_list = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, func, args, callback=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        线程池执行一个任务</span></span><br><span class="line"><span class="string">        :param func: 任务函数</span></span><br><span class="line"><span class="string">        :param args: 任务函数所需参数</span></span><br><span class="line"><span class="string">        :param callback: 任务执行失败或成功后执行的回调函数，回调函数有两个参数1、任务函数执行状态；2、任务函数返回值（默认为None，即：不执行回调函数）</span></span><br><span class="line"><span class="string">        :return: 如果线程池已经终止，则返回True否则None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.free_list) == <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(self.generate_list) &lt; self.max_num:</span><br><span class="line">            self.generate_thread()</span><br><span class="line">        w = (func, args, callback,)</span><br><span class="line">        self.q.put(w)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate_thread</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        创建一个线程</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        t = threading.Thread(target=self.call)</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        循环去获取任务函数并执行任务函数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        current_thread = threading.currentThread</span><br><span class="line">        self.generate_list.append(current_thread)</span><br><span class="line"></span><br><span class="line">        event = self.q.get()  <span class="comment"># 获取线程</span></span><br><span class="line">        <span class="keyword">while</span> event != StopEvent:   <span class="comment"># 判断获取的线程数不等于全局变量</span></span><br><span class="line">            func, arguments, callback = event   <span class="comment"># 拆分元祖，获得执行函数，参数，回调函数</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                result = func(*arguments)   <span class="comment"># 执行函数</span></span><br><span class="line">                status = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:    <span class="comment"># 函数执行失败</span></span><br><span class="line">                status = <span class="literal">False</span></span><br><span class="line">                result = e</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> callback <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    callback(status, result)</span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># self.free_list.append(current_thread)</span></span><br><span class="line">            <span class="comment"># event = self.q.get()</span></span><br><span class="line">            <span class="comment"># self.free_list.remove(current_thread)</span></span><br><span class="line">            <span class="keyword">with</span> self.work_state():</span><br><span class="line">                event = self.q.get()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.generate_list.remove(current_thread)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        关闭线程，给传输全局非元祖的变量来进行关闭</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.generate_list)):</span><br><span class="line">            self.q.put(StopEvent)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">terminate</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        突然关闭线程</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.terminal = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">while</span> self.generate_list:</span><br><span class="line">            self.q.put(StopEvent)</span><br><span class="line">        self.q.empty()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @contextlib.contextmanager</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work_state</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.free_list.append(threading.currentThread)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">yield</span></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            self.free_list.remove(threading.currentThread)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span>(<span class="params">i</span>):</span></span><br><span class="line">    print(i)</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span> <span class="comment"># 返回给回调函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span>(<span class="params">ret</span>):</span></span><br><span class="line">    print(ret)</span><br><span class="line"></span><br><span class="line">pool = ThreadPool(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">    pool.run(func=work, args=(item,), callback=callback)</span><br><span class="line"></span><br><span class="line">pool.terminate()</span><br><span class="line"><span class="comment"># pool.close()</span></span><br></pre></td></tr></table></figure>
<h4 id="python协程"><a href="#python协程" class="headerlink" title="python协程"></a>python协程</h4><p>线程和进程的操作是由程序触发系统接口，最后的执行者是系统；协程的操作则是程序员。</p>
<p>协程存在的意义：对于多线程应用，CPU通过切片的方式来切换线程间的执行，线程切换时需要耗时（保存状态，下次继续）。协程，则只使用一个线程，在一个线程中规定某个代码块执行顺序。</p>
<p>协程的适用场景：当程序中存在大量不需要CPU的操作时（IO），适用于协程；</p>
<p>event loop是协程执行的控制点，如果你希望执行协程，就需要用到它们。</p>
<p>event loop提供了如下的特性：</p>
<ul>
<li><p>注册、执行、取消延时调用(异步函数)</p>
</li>
<li><p>创建用于通信的client和server协议(工具)</p>
</li>
<li><p>创建和别的程序通信的子进程和协议(工具)</p>
</li>
<li><p>把函数调用送入线程池中</p>
</li>
</ul>
<p>代码示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">cor1</span>():</span></span><br><span class="line">    print(<span class="string">&quot;COR1 start&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> cor2()</span><br><span class="line">    print(<span class="string">&quot;COR1 end&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">cor2</span>():</span></span><br><span class="line">    print(<span class="string">&quot;COR2&quot;</span>)</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(cor1())</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure>
<p>最后三行是重点。</p>
<ul>
<li><p>asyncio.get_event_loop(): asyncio启动默认的event loop</p>
</li>
<li><p>run_until_complete(): 这个函数是阻塞执行的，知道所有的异步函数执行完成，</p>
</li>
<li><p>close(): 关闭event loop。</p>
</li>
</ul>
<ol>
<li>greenlet</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> greenlet</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun1</span>():</span></span><br><span class="line">    print(<span class="string">&quot;12&quot;</span>)</span><br><span class="line">    gr2.switch()</span><br><span class="line">    print(<span class="string">&quot;56&quot;</span>)</span><br><span class="line">    gr2.switch()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun2</span>():</span></span><br><span class="line">    print(<span class="string">&quot;34&quot;</span>)</span><br><span class="line">    gr1.switch()</span><br><span class="line">    print(<span class="string">&quot;78&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gr1 = greenlet.greenlet(fun1)</span><br><span class="line">gr2 = greenlet.greenlet(fun2)</span><br><span class="line">gr1.switch()</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>gevent</li>
</ol>
<p>gevent属于第三方模块需要下载安装包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip3 install --upgrade pip3</span><br><span class="line"></span><br><span class="line">pip3 install gevent</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun1</span>():</span></span><br><span class="line">    print(<span class="string">&quot;www.baidu.com&quot;</span>)   <span class="comment"># 第一步</span></span><br><span class="line">    gevent.sleep(<span class="number">0</span>)</span><br><span class="line">    print(<span class="string">&quot;end the baidu.com&quot;</span>)  <span class="comment"># 第三步</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun2</span>():</span></span><br><span class="line">    print(<span class="string">&quot;www.zhihu.com&quot;</span>)   <span class="comment"># 第二步</span></span><br><span class="line">    gevent.sleep(<span class="number">0</span>)</span><br><span class="line">    print(<span class="string">&quot;end th zhihu.com&quot;</span>)  <span class="comment"># 第四步</span></span><br><span class="line"></span><br><span class="line">gevent.joinall([</span><br><span class="line">    gevent.spawn(fun1),</span><br><span class="line">    gevent.spawn(fun2),</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>遇到IO操作自动切换</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">url</span>):</span></span><br><span class="line">    print(<span class="string">&quot;get: %s&quot;</span>%url)</span><br><span class="line">    gevent.sleep(<span class="number">0</span>)</span><br><span class="line">    date =requests.get(url)</span><br><span class="line">    ret = date.text</span><br><span class="line">    print(url,<span class="built_in">len</span>(ret))</span><br><span class="line"></span><br><span class="line">gevent.joinall([</span><br><span class="line">    gevent.spawn(func, <span class="string">&#x27;https://www.python.org/&#x27;</span>),</span><br><span class="line">    gevent.spawn(func, <span class="string">&#x27;https://www.yahoo.com/&#x27;</span>),</span><br><span class="line">    gevent.spawn(func, <span class="string">&#x27;https://github.com/&#x27;</span>),</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<p><strong>更多参考：</strong></p>
<ul>
<li><p><a href="https://docs.python.org/3/library/threading.html">threading — Thread-based parallelism — Python 3.7.2 documentation</a></p>
</li>
<li><p><a href="https://www.tutorialspoint.com/python/python_multithreading.htm">Python Multithreaded Programming</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>旋转数组</title>
    <url>/leetcode/leetcode_rotate_array/</url>
    <content><![CDATA[<h2 id="旋转数组"><a href="#旋转数组" class="headerlink" title="旋转数组"></a>旋转数组</h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。<br><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4,5,6,7] 和 k &#x3D; 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右旋转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右旋转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [-1,-100,3,99] 和 k &#x3D; 2</span><br><span class="line">输出: [3,99,-1,-100]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: [99,-1,-100,3]</span><br><span class="line">向右旋转 2 步: [3,99,-1,-100]</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ul>
<li>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。</li>
<li>要求使用空间复杂度为O(1)的原地算法。<a id="more"></a>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">self, nums, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, k + <span class="number">1</span>):</span><br><span class="line">            temp = nums[<span class="built_in">len</span>(nums) - <span class="number">1</span>]</span><br><span class="line">            nums[<span class="number">1</span>:] = nums[:<span class="built_in">len</span>(nums) - <span class="number">1</span>]</span><br><span class="line">            nums[<span class="number">0</span>] = temp</span><br></pre></td></tr></table></figure>
<h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">self, nums, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        l = <span class="built_in">len</span>(nums)</span><br><span class="line">        nums[:l-k] = <span class="built_in">reversed</span>(nums[:l-k])</span><br><span class="line">        nums[l-k:] = <span class="built_in">reversed</span>(nums[l-k:])</span><br><span class="line">        nums[:] = <span class="built_in">reversed</span>(nums)</span><br></pre></td></tr></table></figure></li>
<li>*注：** 由于旋转k次与旋转k % n次的结果是一样的（n为数组长度），减小k，交换前n-k个数与后面k个数<h4 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">self, nums, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        k = k % n</span><br><span class="line">        nums[:] = nums[n-k:] + nums[:n-k]</span><br></pre></td></tr></table></figure></li>
<li>*说明：** 如果您有更好的解决方案或者本人写的有什么问题，请多多指教！</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>旋转图像</title>
    <url>/leetcode/leetcode_rotate_image/</url>
    <content><![CDATA[<h2 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a>旋转图像</h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给定一个 n×n 的二维矩阵表示一个图像。</p>
<p>将图像顺时针旋转90度。</p>
<p>你必须在<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a>旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong>使用另一个矩阵来旋转图像。<br><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 matrix &#x3D;</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 matrix &#x3D;</span><br><span class="line">[</span><br><span class="line">  [ 5, 1, 9,11],</span><br><span class="line">  [ 2, 4, 8,10],</span><br><span class="line">  [13, 3, 6, 7],</span><br><span class="line">  [15,14,12,16]</span><br><span class="line">],</span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [15,13, 2, 5],</span><br><span class="line">  [14, 3, 4, 1],</span><br><span class="line">  [12, 6, 8, 9],</span><br><span class="line">  [16, 7,10,11]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li><p>先变换最外层，逐渐向内深入，同时旋转90度。具体实现方式如下：</p>
<h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">self, matrix</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        length = <span class="built_in">len</span>(matrix)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, length):</span><br><span class="line">                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            matrix[i] = matrix[i][::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">matrix[:] = <span class="built_in">map</span>(<span class="built_in">list</span>, <span class="built_in">zip</span>(*matrix[::-<span class="number">1</span>]))</span><br></pre></td></tr></table></figure>
<p> <strong>注：</strong></p>
<ul>
<li><p>Map</p>
<p>map(function, iterable, …)</p>
<p>Apply function to every item of iterable and return a list of the results. If additional iterable arguments are passed, function must take that many arguments and is applied to the items from all iterables in parallel. If one iterable is shorter than another it is assumed to be extended with None items. If function isNone, the identity function is assumed; if there are multiple arguments, map() returns a list consisting of tuples containing the corresponding items from all iterables (a kind of transpose operation). <br>The iterable arguments may be a sequence or any iterable object; the result is always a list.</p>
</li>
<li><p>zip</p>
<p>zip(seq1 [, seq2 […]]) -&gt; [(seq1[0], seq2[0] …), (…)]</p>
<p>Return a list of tuples, where each tuple contains the i-th element from each of the argument sequences.  The returned list is truncated in length to the length of the shortest argument sequence.</p>
<p>总之，zip([seql, …])接受一系列可迭代对象作为参数，将对象中对应的元素打包成一个个tuple（元组），然后返回由这些tuples组成的list（列表）。若传入参数的长度不等，则返回list的长度和参数中长度最短的对象相同。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>zip_test = <span class="built_in">zip</span>(*[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test1 = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">      <span class="keyword">try</span>:</span><br><span class="line">          val = <span class="built_in">next</span>(zip_test)</span><br><span class="line">          <span class="comment"># print(val)</span></span><br><span class="line">          test1.append(val)</span><br><span class="line">      <span class="keyword">except</span> StopIteration:</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test1</span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>), (<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>), (<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map_test = <span class="built_in">map</span>(<span class="built_in">list</span>,<span class="built_in">zip</span>(*[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test2 = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">      <span class="keyword">try</span>:</span><br><span class="line">          val = <span class="built_in">next</span>(map_test)</span><br><span class="line">          <span class="comment"># print(val)</span></span><br><span class="line">          test2.append(val)</span><br><span class="line">      <span class="keyword">except</span> StopIteration:</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test2</span><br><span class="line">[[<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>], [<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>], [<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>]]</span><br></pre></td></tr></table></figure>
<p>矩阵的顺时针旋转:先把矩阵上下翻转，然后在转置一下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">matrix[:] = <span class="built_in">map</span>(<span class="built_in">list</span>, <span class="built_in">zip</span>(*matrix[::-<span class="number">1</span>]))</span><br></pre></td></tr></table></figure>
<p>矩阵的逆时针旋转:先把矩阵转置一下，然后在上下翻转:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">matrix[:] = <span class="built_in">map</span>(<span class="built_in">list</span>, <span class="built_in">zip</span>(*matrix))[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<p><strong>说明：</strong> 如果您有更好的解决方案或者本人写的有什么问题，请多多指教！</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>验证数独是否有效</title>
    <url>/leetcode/leetcode_sudoku_valid/</url>
    <content><![CDATA[<h2 id="验证数独是否有效"><a href="#验证数独是否有效" class="headerlink" title="验证数独是否有效"></a>验证数独是否有效</h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>判断一个9x9的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。</p>
<ol>
<li>数字 1-9 在每一行只能出现一次。</li>
<li>数字 1-9 在每一列只能出现一次。</li>
<li>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。<br><img src="Leetcode_sudoku_valid/sample.png" alt="sample"></li>
</ol>
<p><em>上图是一个部分填充的有效的数独。</em><br>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</p>
<a id="more"></a>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>本题主要是思想就是满足每行、每列和每个单元中不存在重复的数就可以，具体实现方式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidSudoku</span>(<span class="params">self, board</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type board: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> board <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化rows、colunms和cells</span></span><br><span class="line">        rows = [&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;]</span><br><span class="line">        columns = [&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;]</span><br><span class="line">        cells = [&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board[i])):</span><br><span class="line">                <span class="comment"># 计算cell的位置</span></span><br><span class="line">                cell = <span class="number">3</span> * (i // <span class="number">3</span>) + j // <span class="number">3</span></span><br><span class="line">                val = board[i][j]</span><br><span class="line">                <span class="keyword">if</span> val == <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> val <span class="keyword">not</span> <span class="keyword">in</span> rows[i] <span class="keyword">and</span> val <span class="keyword">not</span> <span class="keyword">in</span> columns[j] <span class="keyword">and</span> val <span class="keyword">not</span> <span class="keyword">in</span> cells[cell]:</span><br><span class="line">                    rows[i][val] = <span class="number">1</span></span><br><span class="line">                    columns[j][val] = <span class="number">1</span></span><br><span class="line">                    cells[cell][val] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong> 如果您有更好的解决方案或者本人写的有什么问题，请多多指教！</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>使你的Python代码更优雅</title>
    <url>/python/python_code_elegant/</url>
    <content><![CDATA[<h2 id="使你的Python代码更优雅"><a href="#使你的Python代码更优雅" class="headerlink" title="使你的Python代码更优雅"></a>使你的Python代码更优雅</h2><p><strong>注：</strong> 本人代码主要以Python3为主。</p>
<h3 id="遍历一个范围的数字"><a href="#遍历一个范围的数字" class="headerlink" title="遍历一个范围的数字"></a>遍历一个范围的数字</h3><ol>
<li><p>Python2的普通写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]:</span><br><span class="line">    <span class="built_in">print</span> i ** <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    <span class="built_in">print</span> i ** <span class="number">2</span></span><br></pre></td></tr></table></figure></li>
<li><p>Python2最好的优雅的写法是</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">6</span>):</span><br><span class="line">    <span class="built_in">print</span> i ** <span class="number">2</span></span><br></pre></td></tr></table></figure></li>
<li><p>在Python3中的优雅写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    print(i ** <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>xrange会返回一个迭代器，用来一次一个值地遍历一个范围。这种方式会比range更省内存。xrange在Python3中已经改名为range。</p>
</li>
</ol>
<h3 id="遍历一个集合"><a href="#遍历一个集合" class="headerlink" title="遍历一个集合"></a>遍历一个集合</h3><a id="more"></a>
<ol>
<li><p>普通的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">colors = [<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(colors)):</span><br><span class="line">    print(colors[i])</span><br></pre></td></tr></table></figure></li>
<li><p>优雅的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> color <span class="keyword">in</span> colors:</span><br><span class="line">    print(color)</span><br></pre></td></tr></table></figure>
<h3 id="反向遍历"><a href="#反向遍历" class="headerlink" title="反向遍历"></a>反向遍历</h3></li>
<li><p>普通的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">colors = [<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(colors) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    print(colors[i])</span><br></pre></td></tr></table></figure></li>
<li><p>优雅的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> color <span class="keyword">in</span> <span class="built_in">reversed</span>(colors):</span><br><span class="line">    print(color)</span><br></pre></td></tr></table></figure>
<h3 id="遍历一个集合及其下标"><a href="#遍历一个集合及其下标" class="headerlink" title="遍历一个集合及其下标"></a>遍历一个集合及其下标</h3></li>
<li><p>普通的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">colors = [<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(colors)):</span><br><span class="line">    print(i， <span class="string">&#x27;---&gt;&#x27;</span>, colors[i])</span><br></pre></td></tr></table></figure></li>
<li><p>优雅的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, color <span class="keyword">in</span> <span class="built_in">enumerate</span>(colors):</span><br><span class="line">    print(i, <span class="string">&#x27;---&gt;&#x27;</span>, color)</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>说明：</strong> 这种写法效率高，优雅，而且可以省去亲自创建和自增下标。当你发现你在操作集合的下标时，你很有可能在做错事。</p>
<h3 id="遍历两个集合"><a href="#遍历两个集合" class="headerlink" title="遍历两个集合"></a>遍历两个集合</h3><ol>
<li><p>Python2普通的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names = [<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>]</span><br><span class="line">colors = [<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"></span><br><span class="line">n = <span class="built_in">min</span>(<span class="built_in">len</span>(names), <span class="built_in">len</span>(colors))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="built_in">print</span> names[i]， <span class="string">&#x27;---&gt;&#x27;</span>, colors[i]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, color <span class="keyword">in</span> <span class="built_in">zip</span>(names, colors):</span><br><span class="line">    <span class="built_in">print</span> name, <span class="string">&#x27;---&gt;&#x27;</span>, color</span><br></pre></td></tr></table></figure></li>
<li><p>Python2优雅的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> name, color <span class="keyword">in</span> izip(names, colors):</span><br><span class="line">    print(name, <span class="string">&#x27;---&gt;&#x27;</span>, color)</span><br></pre></td></tr></table></figure></li>
<li><p>Python3中优雅的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> name, color <span class="keyword">in</span> <span class="built_in">zip</span>(names, colors):</span><br><span class="line">    print(name, <span class="string">&#x27;---&gt;&#x27;</span>, color)</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>说明：</strong> zip在内存中生成一个新的列表，需要更多的内存。izip比zip效率更高。但是在Python3中，izip改名为zip，并替换了原来的zip成为内置函数。</p>
<h3 id="有序地遍历"><a href="#有序地遍历" class="headerlink" title="有序地遍历"></a>有序地遍历</h3><ol>
<li><p>优雅的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="built_in">sorted</span>(colors, key=<span class="built_in">len</span>))</span><br></pre></td></tr></table></figure>
<h3 id="调用一个函数直到遇到标记值"><a href="#调用一个函数直到遇到标记值" class="headerlink" title="调用一个函数直到遇到标记值"></a>调用一个函数直到遇到标记值</h3></li>
<li><p>普通的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">blocks = []</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    block = f.read(<span class="number">32</span>)</span><br><span class="line">    <span class="keyword">if</span> block == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    block.append(block)</span><br></pre></td></tr></table></figure></li>
<li><p>优雅的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line">blocks = []</span><br><span class="line"><span class="keyword">for</span> block <span class="keyword">in</span> <span class="built_in">iter</span>(functools.partial(f.read, <span class="number">32</span>), <span class="string">&#x27;&#x27;</span>):</span><br><span class="line">    blocks.append(block)</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>说明：</strong> 这个例子里不太能看出来方法二的优势，甚至觉得partial让代码可读性更差了。方法二的优势在于iter的返回值是个迭代器，迭代器能用在各种地方，se、sorte、mi、max、heapq、sum……</p>
<h3 id="在循环内识别多个退出点"><a href="#在循环内识别多个退出点" class="headerlink" title="在循环内识别多个退出点"></a>在循环内识别多个退出点</h3><ol>
<li><p>普通的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">seq, target</span>):</span></span><br><span class="line">    flag = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(seq):</span><br><span class="line">        <span class="keyword">if</span> value == target:</span><br><span class="line">            flag = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure></li>
<li><p>优雅的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">seq, target</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(seq):</span><br><span class="line">        <span class="keyword">if</span> value == target:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure></li>
</ol>
<p>  <strong>说明</strong>：此函数将在for执行完所有的循环后就会执行else。本人也是刚刚了解<code>for-else</code>语法，在什么情况下会执行到else里。这里有两种方法去理解else。</p>
<ul>
<li><p>把for看作if，当for后面的条件为False时执行else。其实条件为False时，就是for循环没被break出去，把所有循环都跑完的时候。</p>
</li>
<li><p>把else记成nobreak，当for没有被break，那么循环结束时会进入到else。</p>
</li>
</ul>
<h3 id="遍历字典的key"><a href="#遍历字典的key" class="headerlink" title="遍历字典的key"></a>遍历字典的key</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;x&#x27;</span>: <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;y&#x27;</span>: <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;z&#x27;</span>:<span class="string">&#x27;b&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> d:</span><br><span class="line">  print(k)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">list</span>(d.keys()):</span><br><span class="line">  <span class="keyword">if</span> k.startwith(y):</span><br><span class="line">      <span class="keyword">del</span> d[k]</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong> 什么时候应该使用第二种而不是第一种方法？当你需要修改字典的时候。</p>
<p>如果你在迭代一个东西的时候修改它，那就是在冒天下之大不韪，接下来发生什么都活该。</p>
<p>list(d.keys())把字典里所有的key都复制到一个列表里。然后你就可以修改字典了。</p>
<h3 id="遍历一个字典的key和value"><a href="#遍历一个字典的key和value" class="headerlink" title="遍历一个字典的key和value"></a>遍历一个字典的key和value</h3><ol>
<li><p>Python2普通的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 并不快，每次必须要重新哈希并做一次查找</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> d:</span><br><span class="line">    <span class="built_in">print</span> k, <span class="string">&#x27;---&gt;&#x27;</span>, d[k]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 产生一个很大的列表</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> d.items():</span><br><span class="line">    <span class="built_in">print</span> k, <span class="string">&#x27;---&gt;&#x27;</span>, v</span><br></pre></td></tr></table></figure></li>
<li><p>Python2优雅的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> d.iteritems():</span><br><span class="line">    <span class="built_in">print</span> k, <span class="string">&#x27;---&gt;&#x27;</span>, v</span><br></pre></td></tr></table></figure></li>
<li><p>Python3优雅的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> d.items():</span><br><span class="line">    print(k, <span class="string">&#x27;---&gt;&#x27;</span>, v)</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>说明：</strong> Python3已经没有iteritems()了，items()的行为和iteritems()很接近。详情请看文档。</p>
<h3 id="用key-value对构建字典"><a href="#用key-value对构建字典" class="headerlink" title="用key-value对构建字典"></a>用key-value对构建字典</h3>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names = [<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>]</span><br><span class="line">colors = [<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"></span><br><span class="line">d = <span class="built_in">dict</span>(<span class="built_in">zip</span>(names, colors))</span><br></pre></td></tr></table></figure>
<h3 id="用字典计数"><a href="#用字典计数" class="headerlink" title="用字典计数"></a>用字典计数</h3><ol>
<li><p>普通的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">colors = [<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"></span><br><span class="line">d = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> color <span class="keyword">in</span> colors:</span><br><span class="line">    <span class="keyword">if</span> color <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">        d[color] == <span class="number">0</span></span><br><span class="line">    d[color] += <span class="number">1</span></span><br></pre></td></tr></table></figure></li>
<li><p>优雅的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">colors = [<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> color <span class="keyword">in</span> colors:</span><br><span class="line">    d[color] = d.get(color, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 稍微潮点的方法，但有些坑需要注意，适合熟练的老手。</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">d = defaultdict(<span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">for</span> color <span class="keyword">in</span> colors:</span><br><span class="line">    d[color] += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="用字典分组"><a href="#用字典分组" class="headerlink" title="用字典分组"></a>用字典分组</h3></li>
<li><p>普通的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names = [<span class="string">&#x27;raymond&#x27;</span>, <span class="string">&#x27;rachel&#x27;</span>, <span class="string">&#x27;matthew&#x27;</span>, <span class="string">&#x27;roger&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;betty&#x27;</span>, <span class="string">&#x27;melissa&#x27;</span>, <span class="string">&#x27;judith&#x27;</span>, <span class="string">&#x27;charlie&#x27;</span>]</span><br><span class="line">d = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">    key = <span class="built_in">len</span>(name)</span><br><span class="line">    <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">        d[key] = []</span><br><span class="line">    d[key].append(name)</span><br><span class="line"></span><br><span class="line">d = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">    key = <span class="built_in">len</span>(name)</span><br><span class="line">    d.setdefault(key, []).append(name)</span><br></pre></td></tr></table></figure></li>
<li><p>优雅的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = defaultdict(<span class="built_in">list</span>)</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">    key = <span class="built_in">len</span>(name)</span><br><span class="line">    d[key].append(name)</span><br></pre></td></tr></table></figure>
<h3 id="连接字典"><a href="#连接字典" class="headerlink" title="连接字典"></a>连接字典</h3></li>
<li><p>普通的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">defaults =  &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;user&#x27;</span>: <span class="string">&#x27;x&#x27;</span>&#125;</span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-u&#x27;</span>, <span class="string">&#x27;--user&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;--color&#x27;</span>)</span><br><span class="line">namespace = parser.parse_args([])</span><br><span class="line">command_line_args = &#123;k:v <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">vars</span>(namespace).items() <span class="keyword">if</span> v&#125;</span><br><span class="line"></span><br><span class="line">d = defaults.copy()</span><br><span class="line">d.update(os.environ)</span><br><span class="line">d.update(command_line_args)</span><br></pre></td></tr></table></figure></li>
<li><p>优雅的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> ChainMap</span><br><span class="line">d = ChainMap(command_line_args, os.environ, defaults)</span><br></pre></td></tr></table></figure>
<h3 id="提高可读性"><a href="#提高可读性" class="headerlink" title="提高可读性"></a>提高可读性</h3></li>
</ol>
<ul>
<li><p>位置参数和下标很漂亮</p>
</li>
<li><p>但关键字和名称更好</p>
</li>
<li><p>第一种方法对于计算机来说很便利</p>
</li>
<li><p>第二种方法和人类思考方式一致</p>
</li>
</ul>
<ol>
<li><p>普通的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">search(<span class="string">&#x27;@obama&#x27;</span>, <span class="literal">False</span>, <span class="number">20</span>, <span class="literal">True</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>优雅的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">search(<span class="string">&#x27;@obama&#x27;</span>, retweets=<span class="literal">False</span>, numtweets=<span class="number">20</span>, popular=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>第二种方法稍微(微秒级)慢一点，但为了代码的可读性和开发时间，值得。</p>
</li>
</ol>
<h3 id="使用namedtuple提高多个返回值的可读性"><a href="#使用namedtuple提高多个返回值的可读性" class="headerlink" title="使用namedtuple提高多个返回值的可读性"></a>使用namedtuple提高多个返回值的可读性</h3><ol>
<li><p>普通的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">doctest.testmod()</span><br></pre></td></tr></table></figure></li>
<li><p>优雅的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line">TestResults = namedTuple(<span class="string">&#x27;TestResults&#x27;</span>, [<span class="string">&#x27;failed&#x27;</span>, <span class="string">&#x27;attempted&#x27;</span>])</span><br></pre></td></tr></table></figure>
<h3 id="unpack序列"><a href="#unpack序列" class="headerlink" title="unpack序列"></a>unpack序列</h3></li>
<li><p>普通的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = <span class="string">&#x27;Raymond&#x27;</span>, <span class="string">&#x27;Hettinger&#x27;</span>, <span class="number">0x30</span>, <span class="string">&#x27;python@example.com&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其它语言的常用方法/习惯</span></span><br><span class="line"></span><br><span class="line">fname = p[<span class="number">0</span>]</span><br><span class="line">lname = p[<span class="number">1</span>]</span><br><span class="line">age = p[<span class="number">2</span>]</span><br><span class="line">email = p[<span class="number">3</span>]</span><br></pre></td></tr></table></figure></li>
<li><p>优雅的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fname, lname, age, email = p</span><br></pre></td></tr></table></figure>
<h3 id="更新多个变量的状态"><a href="#更新多个变量的状态" class="headerlink" title="更新多个变量的状态"></a>更新多个变量的状态</h3></li>
<li><p>普通的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibnacci</span>(<span class="params">n</span>):</span></span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    y = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        print(x)</span><br><span class="line">        t = y</span><br><span class="line">        y = x + y</span><br><span class="line">        x = t</span><br></pre></td></tr></table></figure></li>
<li><p>优雅的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibnacci</span>(<span class="params">n</span>):</span></span><br><span class="line">    x, y = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        print(x)</span><br><span class="line">        x, y = y, x + y</span><br></pre></td></tr></table></figure>
<p>第一种方法的问题</p>
</li>
</ol>
<ul>
<li><p>x和y是状态，状态应该在一次操作中更新，分几行的话状态会互相对不上，这经常是bug的源头。</p>
</li>
<li><p>操作有顺序要求</p>
</li>
<li><p>太底层太细节</p>
</li>
</ul>
<p>第二种方法抽象层级更高，没有操作顺序出错的风险而且更效率更高。</p>
<h3 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h3><ol>
<li><p>普通的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names = [<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>]</span><br><span class="line">s = names[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names[<span class="number">1</span>:]:</span><br><span class="line">    s += <span class="string">&#x27;,&#x27;</span> + name</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure></li>
<li><p>优雅的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&#x27;,&#x27;</span>.join(names))</span><br></pre></td></tr></table></figure>
<h3 id="更新序列"><a href="#更新序列" class="headerlink" title="更新序列"></a>更新序列</h3></li>
<li><p>普通的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names = [<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> names[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></li>
<li><p>优雅的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">names = deque([<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用deque更有效率</span></span><br><span class="line"><span class="keyword">del</span> names[<span class="number">0</span>]</span><br><span class="line">names.popleft()</span><br><span class="line">names.appendleft(<span class="string">&#x27;mark&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="装饰器和上下文管理"><a href="#装饰器和上下文管理" class="headerlink" title="装饰器和上下文管理"></a>装饰器和上下文管理</h3></li>
</ol>
<ul>
<li><p>用于把业务和管理的逻辑分开</p>
</li>
<li><p>分解代码和提高代码重用性的干净优雅的好工具</p>
</li>
<li><p>起个好名字很关键</p>
</li>
<li><p>记住蜘蛛侠的格言：能力越大，责任越大</p>
</li>
</ul>
<h4 id="使用装饰器分离出管理逻辑"><a href="#使用装饰器分离出管理逻辑" class="headerlink" title="使用装饰器分离出管理逻辑"></a>使用装饰器分离出管理逻辑</h4><ol>
<li><p>普通的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">web_lookup</span>(<span class="params">url, saved=&#123;&#125;</span>):</span></span><br><span class="line">    <span class="keyword">if</span> url <span class="keyword">in</span> saved:</span><br><span class="line">        <span class="keyword">return</span> saved[url]</span><br><span class="line"></span><br><span class="line">    page = urllib.urlopen(url).read()</span><br><span class="line">    saved[url] = page</span><br><span class="line">    <span class="keyword">return</span> page</span><br></pre></td></tr></table></figure></li>
<li><p>优雅的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@cache</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">web_lookup</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="keyword">return</span> urllib.urlopen(url).read()</span><br></pre></td></tr></table></figure>
<h4 id="分离临时上下文"><a href="#分离临时上下文" class="headerlink" title="分离临时上下文"></a>分离临时上下文</h4></li>
<li><p>普通的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 保存旧的，创建新的</span></span><br><span class="line">old_context = getcontext().copy()</span><br><span class="line">getcontext().prec = <span class="number">50</span></span><br><span class="line">print(Decimal(<span class="number">355</span>) / Decimal(<span class="number">113</span>))</span><br><span class="line">setcontext(old_context)</span><br></pre></td></tr></table></figure></li>
<li><p>优雅的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> localcontext(Context(prec=<span class="number">50</span>)):</span><br><span class="line">    print(Decimal(<span class="number">355</span>) / Decimal(<span class="number">113</span>))</span><br></pre></td></tr></table></figure>
<h4 id="如何打开关闭文件"><a href="#如何打开关闭文件" class="headerlink" title="如何打开关闭文件"></a>如何打开关闭文件</h4></li>
<li><p>普通的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;data.txt&#x27;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    data = f.read()</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure></li>
<li><p>优雅的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.txt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.read()</span><br></pre></td></tr></table></figure>
<h4 id="如何使用锁"><a href="#如何使用锁" class="headerlink" title="如何使用锁"></a>如何使用锁</h4></li>
<li><p>普通的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建锁</span></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用锁的老方法</span></span><br><span class="line">lock.acquire()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(<span class="string">&#x27;Section 1&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;Section 2&#x27;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    lock.releae()</span><br></pre></td></tr></table></figure></li>
<li><p>优雅的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lock = threading.Lock()</span><br><span class="line"><span class="keyword">with</span> lock:</span><br><span class="line">    print(<span class="string">&#x27;Section 1&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;Section 2&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="分离出临时的上下文"><a href="#分离出临时的上下文" class="headerlink" title="分离出临时的上下文"></a>分离出临时的上下文</h4></li>
<li><p>普通的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    os.remove(<span class="string">&#x27;somefile.tmp&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> OSError:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li>
<li><p>优雅的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> ignore(OSError):</span><br><span class="line">    os.remove(<span class="string">&#x27;somefile.tmp&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="简洁的单句表达"><a href="#简洁的单句表达" class="headerlink" title="简洁的单句表达"></a>简洁的单句表达</h3></li>
</ol>
<h4 id="两个冲突的原则"><a href="#两个冲突的原则" class="headerlink" title="两个冲突的原则"></a>两个冲突的原则</h4><ul>
<li><p>一行不要有太多逻辑</p>
</li>
<li><p>不要把单一的想法拆分成多个部分</p>
</li>
</ul>
<h4 id="Raymond的原则"><a href="#Raymond的原则" class="headerlink" title="Raymond的原则"></a>Raymond的原则</h4><ul>
<li>一行代码的逻辑等于一句自然语句</li>
</ul>
<h4 id="列表解析和生成器"><a href="#列表解析和生成器" class="headerlink" title="列表解析和生成器"></a>列表解析和生成器</h4><ol>
<li><p>普通的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    s = i ** <span class="number">2</span></span><br><span class="line">    result.append(s)</span><br><span class="line">print(<span class="built_in">sum</span>(result))</span><br></pre></td></tr></table></figure></li>
<li><p>优雅的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="built_in">sum</span>(i ** <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)))</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Parquet简介</title>
    <url>/bigdata/parquet/</url>
    <content><![CDATA[<h2 id="Parquet简介"><a href="#Parquet简介" class="headerlink" title="Parquet简介"></a>Parquet简介</h2><p>创建Parquet是为了让Hadoop生态系统中的任何项目都可以使用压缩的、高效的列式数据表示。</p>
<p>parquet是在考虑复杂嵌套数据结构的基础上，采用Dremel论文中描述的记录分解和装配算法构建的。我们认为这种方法优于简单地扁平化嵌套名称空间。</p>
<p>parquet支持非常有效的压缩和编码方案。多个项目已经证明了对数据应用正确的压缩和编码方案对性能的影响。parquet允许在每一列水平上指定压缩方案，并且在发明和实现时允许添加更多的编码，这是对未来的证明。</p>
<p>parquet是供任何人使用的。Hadoop生态系统拥有丰富的数据处理框架，我们不感兴趣。我们认为，一个高效的、实现良好的柱状存储底层应该对所有框架都有用，而不需要花费大量的成本，也不需要建立依赖关系。</p>
<h3 id="Parquet的组成"><a href="#Parquet的组成" class="headerlink" title="Parquet的组成"></a>Parquet的组成</h3><p>Parquet仅仅是一种存储格式，它是语言、平台无关的，并且不需要和任何一种数据处理框架绑定，目前能够和Parquet适配的组件包括下面这些，可以看出基本上通常使用的查询引擎和计算框架都已适配，并且可以很方便的将其它序列化工具生成的数据转换成Parquet格式。</p>
<p><strong>Parquet适配多种计算框架</strong></p>
<a id="more"></a>
<p>Parquet 是语言无关的，而且不与任何一种数据处理框架绑定在一起，适配多种语言和组件，能够与 Parquet 配合的组件有：</p>
<ul>
<li><p>计算框架</p>
<p>MapReduce, Spark, Cascading, Crunch, Scalding, Kite等</p>
</li>
<li><p>查询引擎支</p>
<p>Hive, Impala, Pig, Presto, Drill, Tajo, HAWQ, IBM Big SQL等，并且它是语言和平台无关的。</p>
</li>
<li><p>数据模型</p>
<p>Avro, Thrift, Protocol Buffers, POJOs</p>
</li>
</ul>
<h3 id="项目组成"><a href="#项目组成" class="headerlink" title="项目组成"></a>项目组成</h3><p>Parquet项目由以下几个子项目组成:</p>
<ul>
<li><p><strong>parquet-format</strong>项目由java实现，它定义了所有Parquet元数据对象，Parquet的元数据是使用Apache Thrift进行序列化并存储在Parquet文件的尾部。</p>
</li>
<li><p><strong>parquet-format</strong>项目由java实现，它包括多个模块，包括实现了读写Parquet文件的功能，并且提供一些和其它组件适配的工具，例如Hadoop Input/Output Formats、Hive Serde(目前Hive已经自带Parquet了)、Pig loaders等。</p>
</li>
<li><p><strong>parquet-compatibility</strong>项目，包含不同编程语言之间(JAVA和C/C++)读写文件的测试代码。</p>
</li>
<li><p><strong>parquet-cpp</strong>项目，它是用于用于读写Parquet文件的C++库。</p>
</li>
</ul>
<p>下图展示了Parquet各个组件的层次以及从上到下交互的方式。</p>
<ol>
<li><p>数据存储层：定义了Parquet的文件格式，其中元数据在parquet-format中定义，包括Parquet原始类型定义、Page类型、编码类型、压缩类型等等。</p>
</li>
<li><p>对象转换层: 完成其他对象模型与Parquet内部数据模型的映射和转换，Parquet的编码方式使用的是striping and assembly算法。</p>
</li>
<li><p>对象模型层: 定义了如何读取Parquet文件的内容，这一层转换包括Avro、Thrift、PB等序列化格式、Hive serde等的适配。并且为了帮助大家理解和使用，Parquet提供了org.apache.parquet.example包实现了java对象和Parquet文件的转换。</p>
</li>
</ol>
<h3 id="使用Parquet列式存储格式的优势"><a href="#使用Parquet列式存储格式的优势" class="headerlink" title="使用Parquet列式存储格式的优势"></a>使用Parquet列式存储格式的优势</h3><ul>
<li><p>更有效的压缩：因为数据以列的形式存储，所以能将完全不同的值一起存在内存中。因此，它为存储的数据提供了更高的压缩率。Big SQL推荐对Parquet文件格式采用两种压缩类型：snappy（默认的压缩类型）和 gzip。</p>
</li>
<li><p>减少了I/O操作：只需扫描部分列，所以减少了I/O操作。</p>
</li>
<li><p>编码模式：列式存储在压缩选项外提供了一种高效方式来存储数据。</p>
</li>
</ul>
<h3 id="parquet数据压缩算法的使用"><a href="#parquet数据压缩算法的使用" class="headerlink" title="parquet数据压缩算法的使用"></a>parquet数据压缩算法的使用</h3><p>列式存储给数据压缩也提供了更大的发挥空间，除了我们常见的 snappy, gzip 等压缩方法以外，由于列式存储同一列的数据类型是一致的，所以可以使用更多的压缩算法。</p>
<table>
<thead>
<tr>
<th>压缩算法</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>Run Length Encoding</td>
<td>重复数据</td>
</tr>
<tr>
<td>Delta Encoding</td>
<td>有序数据集，例如timestamp，自动生成的 ID，以及监控的各种 metrics</td>
</tr>
<tr>
<td>Dictionary Encoding</td>
<td>小规模的数据集合，例如IP地址</td>
</tr>
<tr>
<td>Prefix Encoding</td>
<td>Delta Encoding for strings</td>
</tr>
</tbody></table>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>Parquet列式存储带来的性能上的提高在业内已经得到了充分的认可，特别是当你们的表非常宽（column 非常多）的时候，Parquet无论在资源利用率还是性能上都优势明显。具体的性能指标详见参考文档。</p>
<p>Spark已经将Parquet设为默认的文件存储格式，Cloudera投入了很多工程师到 Impala+Parquet 相关开发中，Hive/Pig都原生支持Parquet。Parquet现在为Twitter至少节省了1/3的存储空间，同时节省了大量的表扫描和反序列化的时间。这两方面直接反应就是节约成本和提高性能。</p>
]]></content>
      <categories>
        <category>BigData</category>
      </categories>
      <tags>
        <tag>BigData</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop和Spark大数据框架</title>
    <url>/bigdata/hadoop_spark/</url>
    <content><![CDATA[<h2 id="Hadoop和Spark大数据框架"><a href="#Hadoop和Spark大数据框架" class="headerlink" title="Hadoop和Spark大数据框架"></a>Hadoop和Spark大数据框架</h2><h3 id="Hadoop是什么"><a href="#Hadoop是什么" class="headerlink" title="Hadoop是什么"></a>Hadoop是什么</h3><p>Hadoop分布式文件系统(HDFS)，它将文件以Hadoop本机格式存储并在集群中并行化，包括：</p>
<ul>
<li><p><strong>YARN</strong>：协调应用程序运行时的调度程序</p>
</li>
<li><p><strong>MapReduce</strong>：并行处理数据的算法</p>
</li>
<li><p><strong>Sqoop</strong>：它将关系数据移入HDFS</p>
</li>
<li><p><strong>Hive</strong>：一种类似SQL的接口，允许用户在HDFS上运行查询</p>
</li>
<li><p><strong>Mahout</strong>：可以实现机器学习。</p>
</li>
</ul>
<p>除了将HDFS用于文件存储之外，Hadoop现在还可以配置使用S3 buckets或Azure blob作为输入。</p>
<p>Hadoop使用Java编程语言构建，其上的应用程序也可以使用其他语言编写。通过一个Thrift客户端，用户可以编写MapReduce或者Python代码。</p>
<p><strong>hadoop的安装部署</strong>可以点击本人博客<a href="https://javyxu.cn/bigdata/install_hadoop/">CentOS下安装Hadoop</a></p>
<h3 id="Spark是什么"><a href="#Spark是什么" class="headerlink" title="Spark是什么"></a>Spark是什么</h3><a id="more"></a>
<p>Spark是一个较新的项目，最初于2012年诞生在加州大学伯克利分校的AMPLab。它也是一个顶级Apache项目，专注于在集群中并行处理数据，最大的区别在于它在内存中运行。</p>
<p>类似于Hadoop读取和写入文件到HDFS的概念，Spark使用RDD(弹性分布式数据集)处理RAM中的数据。Spark以独立模式运行，Hadoop集群可用作数据源，也可与Mesos一起运行。在后一种情况下，Mesos主站将取代Spark主站或YARN以进行调度。</p>
<p>Spark是围绕Spark Core构建的，Spark Core是驱动调度，优化和RDD抽象的引擎，并将Spark连接到正确的文件系统(HDFS，S3，RDBM或Elasticsearch)。Spark Core上还运行了几个库，包括Spark SQL，允许用户在分布式数据集上运行类似SQL的命令，用于机器学习的MLLib，用于解决图形问题的GraphX以及允许输入连续流式日志数据的Streaming。</p>
<p>Spark有几个API。原始界面是用Scala编写的，并且由于大量数据科学家的使用，还添加了Python和R接口。Java是编写Spark作业的另一种选择。</p>
<p><strong>spark的安装部署</strong>可以点击本人博客<a href="https://javyxu.cn/bigdata/install_spark/">CentOS下安装Spark</a></p>
<h3 id="架构比较"><a href="#架构比较" class="headerlink" title="架构比较"></a>架构比较</h3><h4 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h4><p><img src="hadoop_spark/hadoop_arch.png" alt="hadoop_arch"></p>
<p>首先，所有传入HDFS的文件都被分割成块。根据配置的块大小和复制因子，每个块在集群中被复制指定的次数。该信息被传递给NameNode，它跟踪集群中的所有内容。NameNode将这些文件分配给多个数据节点，然后将这些文件写入其中。在2012年被实施的高可用性允许NameNode故障转移到备份节点上，以跟踪集群中的所有文件。</p>
<p>MapReduce算法位于HDFS之上，由JobTracker组成。一旦应用程序以其中一种语言编写，Hadoop接受JobTracker，然后分配工作(可包括计算单词和清理日志文件等内容，以及在Hive仓库数据集之上运行HiveQL查询)到侦听其他节点的TaskTracker。</p>
<p><img src="hadoop_spark/hadoop_cal.png" alt="hadoop_cal"></p>
<p>YARN分配JobTracker加速并监控它们的资源，以提高效率。然后将所有来自MapReduce阶段的结果汇总并写入HDFS中的磁盘之上。</p>
<h4 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h4><p><img src="hadoop_spark/spark_arch.png" alt="spark_arch"></p>
<p>Spark的计算过程在内存中执行并在内存中存储，直到用户保存为止。除此之外，Spark处理工作的方式基本与Hadoop类似。最初，Spark从HDFS，S3或其他文件存储系统读取到名为SparkContext的程序执行入口。除此之外，Spark创建了一个名为RDD(弹性分布式数据集)的结构，它表示一组可并行操作元素的不可变集合。</p>
<p>随着RDD和相关操作的创建，Spark还创建了一个DAG(有向无环图)，以便可视化DAG中的操作顺序和操作之间的关系。每个DAG都有确定的阶段和步骤。</p>
<p>用户可以在RDD上执行转换，中间操作或最终步骤。给定转换的结果进入DAG，不会保留到磁盘，但每一步操作都会将内存中的所有数据保留到磁盘。</p>
<p>Spark RDD顶部的一个新抽象是DataFrames，它是在Spark 2.0中作为RDD配套接口开发的。这两者非常相似，但DataFrames将数据组织成命名列，类似于Python的pandas或R包。这使得它们比RDD更方便，RDD没有类似的一系列列级标题引用。SparkSQL还允许用户像存储关系数据的SQL表一样查询DataFrame。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>Spark在内存中运行速度比Hadoop快100倍，在磁盘上运行速度快10倍。众所周知，Spark在数量只有十分之一的机器上，对100TB数据进行排序的速度比Hadoop MapReduce快3倍。此外，Spark在机器学习应用中的速度同样更快，例如Naive Bayes和k-means。</p>
<p>由处理速度衡量的Spark性能之所以比Hadoop更优，原因如下：</p>
<ol>
<li><p>每次运行MapReduce任务时，Spark都不会受到输入输出的限制。事实证明，应用程序的速度要快得多。</p>
</li>
<li><p>park的DAG可以在各个步骤之间进行优化。Hadoop在MapReduce步骤之间没有任何周期性连接，这意味着在该级别不会发生性能调整。</p>
</li>
</ol>
<p>但是，如果Spark与其他共享服务在YARN上运行，则性能可能会降低并导致RAM开销内存泄漏。出于这个原因，如果用户有批处理的诉求，Hadoop被认为是更高效的系统。</p>
<h3 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h3><p>Spark和Hadoop都可以作为开源Apache项目免费获得，这意味着用户都可以零成本安装运行。但是，考虑总体拥有成本才是最重要的，比如维护、硬件和软件购买，雇佣集群管理团队的开销。内部安装的一般经验法则是Hadoop需要更多的磁盘内存，而Spark需要更多的RAM，这意味着设置Spark集群可能会更加昂贵。此外，由于Spark是较新的系统，因此它的专家更为稀少，成本更高。</p>
<h3 id="容错和安全性"><a href="#容错和安全性" class="headerlink" title="容错和安全性"></a>容错和安全性</h3><p>Hadoop具有高度容错性，因为它旨在跨多个节点复制数据。每个文件都被分割成块，并在许多机器上复制无数次，以确保如果单台机器停机，可以从其他块重建文件。</p>
<p>Spark的容错主要是通过RDD操作来实现。最初，静态数据存储在HDFS中，通过Hadoop的体系结构进行容错。随着RDD的建立，它记住了数据集是如何构建的，由于它是不可变的，如果需要可以从头开始重建。跨Spark分区的数据也可以基于DAG跨数据节点重建。数据在执行器节点之间复制，如果执行器和驱动程序之间的节点通信失败，通常可能会损坏数据。</p>
<p>Spark和Hadoop都可以支持Kerberos身份验证，但Hadoop对HDFS具有更加细化的安全控制。Apache Sentry是一个用于执行细粒度元数据访问的系统，是另一个专门用于HDFS级别安全性的项目。<br>Spark的安全模型目前很少，但允许通过共享密钥进行身份验证。</p>
<h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><p>Hadoop使用Mahout来处理数据。Mahout包括集群，分类和基于批处理的协作过滤，所有这些都在MapReduce之上运行。目前正在逐步推出支持Scala和DSL语言的Samsara(类似R的矢量数学环境)，允许用户进行内存和代数操作，并允许用户自己编写算法。</p>
<p>Spark有一个机器学习库叫MLLib，充分利用了Spark快速内存计算,迭代效率高的优势开发机器学习应用程序。它可用于Java，Scala，Python或R，包括分类和回归，以及通过超参数调整构建机器学习管道的能力。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>所以，到底是选Hadoop还是Spark呢?两者都是Apache的顶级项目，经常一起使用，并且有相似之处，但Spark并不是离不开Hadoop，目前已有超过20%的Spark独立于Hadoop运行，并且这一比例还在增加。从性能、成本、高可用性、易用性、安全性和机器学习诸多方面参考，Spark都略胜一筹!</p>
]]></content>
      <categories>
        <category>BigData</category>
      </categories>
      <tags>
        <tag>BigData</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS下安装Hadoop集群</title>
    <url>/bigdata/install_hadoop/</url>
    <content><![CDATA[<h2 id="CentOS下安装Hadoop集群"><a href="#CentOS下安装Hadoop集群" class="headerlink" title="CentOS下安装Hadoop集群"></a>CentOS下安装Hadoop集群</h2><!-- TOC -->

<ul>
<li><a href="#centos%E4%B8%8B%E5%AE%89%E8%A3%85hadoop%E9%9B%86%E7%BE%A4">CentOS下安装Hadoop集群</a><ul>
<li><a href="#%E5%AE%89%E8%A3%85%E5%89%8D%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%94%A8%E6%88%B7%E9%85%8D%E7%BD%AE">安装前系统和用户配置</a></li>
<li><a href="#%E9%A2%84%E5%A4%84%E7%90%86">预处理</a><ul>
<li><a href="#hadoop%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E4%BB%8B%E7%BB%8D">Hadoop集群环境介绍</a></li>
<li><a href="#hostname%E4%BF%AE%E6%94%B9">Hostname修改</a></li>
<li><a href="#%E4%BF%AE%E6%94%B9hosts%E6%96%87%E4%BB%B6">修改Hosts文件</a></li>
<li><a href="#%E8%AE%BE%E7%BD%AE%E6%97%A0%E5%AF%86%E7%99%BB%E5%BD%95">设置无密登录</a></li>
<li><a href="#%E9%85%8D%E7%BD%AEjdk%E7%8E%AF%E5%A2%83">配置JDK环境</a></li>
</ul>
</li>
<li><a href="#zookeeper%E9%83%A8%E7%BD%B2">Zookeeper部署</a><ul>
<li><a href="#%E4%B8%8B%E8%BD%BD">下载</a></li>
<li><a href="#%E9%85%8D%E7%BD%AE">配置</a></li>
<li><a href="#%E5%90%AF%E5%8A%A8%E5%92%8C%E5%81%9C%E6%AD%A2">启动和停止</a></li>
</ul>
</li>
<li><a href="#%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AEhadoop%E9%9B%86%E7%BE%A4">安装和配置Hadoop集群</a><ul>
<li><a href="#%E4%B8%8B%E8%BD%BD-1">下载</a></li>
<li><a href="#%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">修改配置文件</a></li>
<li><a href="#%E5%90%AF%E5%8A%A8hadoop%E9%9B%86%E7%BE%A4">启动Hadoop集群</a></li>
</ul>
</li>
<li><a href="#hadoop%E9%9B%86%E7%BE%A4%E6%B5%8B%E8%AF%95">Hadoop集群测试</a></li>
<li><a href="#%E9%83%A8%E7%BD%B2%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98">部署过程中遇到的问题</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h3 id="安装前系统和用户配置"><a href="#安装前系统和用户配置" class="headerlink" title="安装前系统和用户配置"></a>安装前系统和用户配置</h3><ol>
<li>Centos 7系统更新 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install epel-release</span><br><span class="line">yum update</span><br></pre></td></tr></table></figure></li>
<li>创建用户并切换用户(可不用) <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adduser hadoop</span><br><span class="line">passwd hadoop</span><br></pre></td></tr></table></figure>
 vi /etc/sudoers <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Allow root to run any commands anywhere</span></span></span><br><span class="line">root    ALL=(ALL)       ALL</span><br><span class="line">hadoop   ALL=(ALL)       ALL</span><br></pre></td></tr></table></figure>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su - hadoop</span><br><span class="line">mkdir /home/hadoop/Downloads</span><br></pre></td></tr></table></figure>
<h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><h4 id="Hadoop集群环境介绍"><a href="#Hadoop集群环境介绍" class="headerlink" title="Hadoop集群环境介绍"></a>Hadoop集群环境介绍</h4><a id="more"></a>
<table>
<thead>
<tr>
<th>IP</th>
<th>hostname</th>
<th>部署路径</th>
<th>部署规划</th>
</tr>
</thead>
<tbody><tr>
<td>10.0.2.176</td>
<td>host2176</td>
<td>/data</td>
<td>ZK</td>
</tr>
<tr>
<td>10.0.2.177</td>
<td>host2177</td>
<td>/data</td>
<td>ZK</td>
</tr>
<tr>
<td>10.0.2.180</td>
<td>host2180</td>
<td>/data</td>
<td>ZK</td>
</tr>
</tbody></table>
<h4 id="Hostname修改"><a href="#Hostname修改" class="headerlink" title="Hostname修改"></a>Hostname修改</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hostnamectl set-hostname host2176</span><br><span class="line">hostnamectl set-hostname host2177</span><br><span class="line">hostnamectl set-hostname host2180</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>注意：</strong> 在对应的机器上执行</p>
<h4 id="修改Hosts文件"><a href="#修改Hosts文件" class="headerlink" title="修改Hosts文件"></a>修改Hosts文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/hosts</span><br><span class="line"></span><br><span class="line">10.0.2.176    host2176</span><br><span class="line">10.0.2.177    host2177</span><br><span class="line">10.0.2.180    host2180</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 在所有机器上执行</p>
<h4 id="设置无密登录"><a href="#设置无密登录" class="headerlink" title="设置无密登录"></a>设置无密登录</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install openssh-server</span><br><span class="line">ssh-keygen -t rsa   # 一直回车</span><br><span class="line">cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong> 在所有机器上执行。然后将其中一台<code>~/.ssh</code>下的文件通过<code>scp -r ~/.ssh</code>拷贝到另外两台机器</p>
<h4 id="配置JDK环境"><a href="#配置JDK环境" class="headerlink" title="配置JDK环境"></a>配置JDK环境</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">JAVA_JDK_JRE</span></span><br><span class="line">export JAVA_HOME=/data/jdk1.8.0_201 # 需要自己下载jdk1.8.0_201并解压</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"></span><br><span class="line">source /etc/profile # 及时生效</span><br><span class="line">echo $JAVA_HOME</span><br></pre></td></tr></table></figure>
<h3 id="Zookeeper部署"><a href="#Zookeeper部署" class="headerlink" title="Zookeeper部署"></a>Zookeeper部署</h3><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>下载<a href="https://archive.apache.org/dist/zookeeper/zookeeper-3.4.14/zookeeper-3.4.14.tar.gz">zookeeper-3.4.14</a>到<code>/data</code>目录下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://archive.apache.org/dist/zookeeper/zookeeper-3.4.14/zookeeper-3.4.14.tar.gz</span><br><span class="line">tar -zxvf zookeeper-3.4.14.tar.gz</span><br><span class="line"></span><br><span class="line">cd zookeeper-3.4.14</span><br><span class="line">mkdir data log</span><br><span class="line"></span><br><span class="line">cd data</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在data里建立myid的文件，里面按顺序填写数字且不能重复，测试环境为3台机器，myid为1；2；3</span></span><br><span class="line">vi myid </span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 三台机器都要创建，且myid数字不一样</p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp /data/zookeeper-3.4.14/conf/zoo_sample.cfg /data/zookeeper-3.4.14/conf/zoo.cfg</span><br><span class="line"></span><br><span class="line">vi zoo.cfg</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改以下文件</span></span><br><span class="line">tickTime=2000</span><br><span class="line">initLimit=10</span><br><span class="line">syncLimit=5</span><br><span class="line">dataDir=/data/zookeeper-3.4.14/data # 此处可根据自己情况</span><br><span class="line">dataLogDir=/data/zookeeper-3.4.14/log # 此处可根据自己情况</span><br><span class="line">clientPort=2181</span><br><span class="line">server.1=10.0.2.176:2888:3888  # 此处的1与myid文件中的对应</span><br><span class="line">server.2=10.0.2.177:2888:3888  # 此处的2与myid文件中的对应</span><br><span class="line">server.3=10.0.2.180:2888:3888  # 此处的3与myid文件中的对应</span><br></pre></td></tr></table></figure>
<h4 id="启动和停止"><a href="#启动和停止" class="headerlink" title="启动和停止"></a>启动和停止</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/data/zookeeper-3.4.14/bin/zkServer.sh start # 启动zk</span><br><span class="line">/data/zookeeper-3.4.14/bin/zkServer.sh status # 查看启动状态，一般为一个leader两个follower</span><br><span class="line">/data/zookeeper-3.4.14/bin/zkServer.sh stop # 停止zk</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 三台机器都要执行</p>
<h3 id="安装和配置Hadoop集群"><a href="#安装和配置Hadoop集群" class="headerlink" title="安装和配置Hadoop集群"></a>安装和配置Hadoop集群</h3><h4 id="下载-1"><a href="#下载-1" class="headerlink" title="下载"></a>下载</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://archive.apache.org/dist/hadoop/core/hadoop-2.7.7/hadoop-2.7.7.tar.gz</span><br><span class="line">tar -zxvf hadoop-2.7.7.tar.gz</span><br><span class="line">mv hadoop-2.7.7.tar.gz hadoop</span><br><span class="line">cd hadoop</span><br><span class="line">mkdir data logs tmp # 注意修改权限和别的hadoop文件一致</span><br><span class="line">chown -R hadoop:hadoop</span><br></pre></td></tr></table></figure>
<h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><ol>
<li><p>在<code>/etc/profile</code>文件中添加Hadoop</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/profile</span><br><span class="line"></span><br><span class="line">export HADOOP_HOME=/data/hadoop</span><br><span class="line">export HADOOP_SSH_OPTS=&quot;-p 36000&quot; # 如果您机器修改了连接端口，此处要进行设置</span><br><span class="line">export PATH=$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$PATH</span><br></pre></td></tr></table></figure></li>
<li><p>修改<code>core-site.xml</code>文件</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi ./etc/hadoop/core-site.xml</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;/data/hadoop/tmp&lt;/value&gt;</span><br><span class="line">    &lt;description&gt;Abase for other temporary directories.&lt;/description&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;hdfs://host2176:9000&lt;/value&gt;  ## 查看端口是否被占用</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;io.file.buffer.size&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;4096&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;hadoop.proxyuser.u0.hosts&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;*&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;hadoop.proxyuser.u0.groups&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;*&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>修改<code>hdfs-site.xm</code>文件</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi ./etc/hadoop/hdfs-site.xml</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;1&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;file:/data/bigdata/hadoop/data&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;mapreduce_shuffle&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.http.address&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;0.0.0.0:50070&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">      &lt;name&gt;dfs.permissions&lt;/name&gt;</span><br><span class="line">      &lt;value&gt;false&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>修改<code>mapred-site.xml</code>文件</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp ./etc/hadoop/mapred-site.xml.template ./etc/hadoop/mapred-site.xml</span><br><span class="line">vi ./etc/hadoop/mapred-site.xml</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;mapreduce.framework.name&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;yarn&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>配置<code>hadoop-env.sh</code>文件</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi ./etc/hadoop/hadoop-env.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> JAVA_HOME</span></span><br><span class="line">export JAVA_HOME=/data/jdk1.8.0_201    </span><br></pre></td></tr></table></figure>
<p> <strong>注意：</strong> 如果配置了JAVA_HOME还是不可以的话，请修改此处。</p>
</li>
<li><p>修改<code>slaves</code>文件</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi slaves</span><br><span class="line"></span><br><span class="line">host2176</span><br><span class="line">host2177</span><br><span class="line">host2180</span><br></pre></td></tr></table></figure>
<h4 id="启动Hadoop集群"><a href="#启动Hadoop集群" class="headerlink" title="启动Hadoop集群"></a>启动Hadoop集群</h4></li>
<li><p>启动journalnode</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./sbin/hadoop-daemon.sh start journalnode</span><br></pre></td></tr></table></figure>
<p> <strong>注意：</strong> 在三台机器上都执行。</p>
</li>
<li><p>格式化</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/hdfs namenode -format</span><br></pre></td></tr></table></figure>
<p> <strong>注意：</strong> 将配置好的master节点的hadoop文件夹，拷贝到其他机器上.</p>
</li>
<li><p>启动Hadoop集群</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./sbin/start-all.sh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line">./sbin/start-dfs.sh</span><br><span class="line">./sbin/start-yarn.sh</span><br></pre></td></tr></table></figure>
<p> <strong>注意：</strong> 在master节点执行即可</p>
</li>
<li><p>停止Hadoop集群</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./sbin/stop-all.sh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line">./sbin/stop-dfs.sh</span><br><span class="line">./sbin/stop-yarn.sh</span><br></pre></td></tr></table></figure>
<p> <strong>注意：</strong> 在master节点执行即可</p>
</li>
</ol>
<h3 id="Hadoop集群测试"><a href="#Hadoop集群测试" class="headerlink" title="Hadoop集群测试"></a>Hadoop集群测试</h3><p>可以通过<code>http://10.0.2.176:50070</code>查看Hadoop集群情况。</p>
<h3 id="部署过程中遇到的问题"><a href="#部署过程中遇到的问题" class="headerlink" title="部署过程中遇到的问题"></a>部署过程中遇到的问题</h3><ol>
<li>执行<code>create table</code>时，一直卡住不动 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安全模式</span></span><br><span class="line">./bin/hdfs dfsadmin -safemode leave</span><br></pre></td></tr></table></figure></li>
<li>查看节点启动情况，如果出现datanode没启动情况 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看节点启动情况</span></span><br><span class="line">./bin/hdfs dfsadmin -report</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重新启动节点</span></span><br><span class="line">./bin/hdfs dfsadmin -refreshNodes</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>后续补充高可用方案</strong></p>
<p><strong>说明：</strong> 如果本人写的有什么问题，请多多指教！</p>
]]></content>
      <categories>
        <category>BigData</category>
      </categories>
      <tags>
        <tag>BigData</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS下安装Spark</title>
    <url>/bigdata/install_spark/</url>
    <content><![CDATA[<h2 id="CentOS下安装Spark"><a href="#CentOS下安装Spark" class="headerlink" title="CentOS下安装Spark"></a>CentOS下安装Spark</h2><h3 id="安装前系统和用户配置"><a href="#安装前系统和用户配置" class="headerlink" title="安装前系统和用户配置"></a>安装前系统和用户配置</h3><ol>
<li><p>Centos 7系统更新</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install epel-release</span><br><span class="line">yum update</span><br></pre></td></tr></table></figure></li>
<li><p>创建用户并切换用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adduser spark</span><br><span class="line">passwd spark</span><br></pre></td></tr></table></figure>
<p>vi /etc/sudoers</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## Allow root to run any commands anywhere</span><br><span class="line">root    ALL&#x3D;(ALL)       ALL</span><br><span class="line">spark   ALL&#x3D;(ALL)       ALL</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su - spark</span><br><span class="line">mkdir &#x2F;home&#x2F;spark&#x2F;Downloads</span><br></pre></td></tr></table></figure>
<h3 id="安装spark"><a href="#安装spark" class="headerlink" title="安装spark"></a>安装spark</h3></li>
<li><p>安装Python3.6</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install python36 python36-devel</span><br></pre></td></tr></table></figure></li>
<li><p>安装Spark</p>
<p>下载并解压</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;archive.apache.org&#x2F;dist&#x2F;spark&#x2F;spark-2.2.1&#x2F;spark-2.2.2-bin-hadoop2.7.tgz</span><br><span class="line">tar -zxvf spark-2.2.2-bin-hadoop2.7.tgz</span><br><span class="line">cd spark-2.2.1-bin-hadoop2.7</span><br><span class="line">cd .&#x2F;conf</span><br><span class="line">cp spark-env.sh.template spark-env.sh</span><br></pre></td></tr></table></figure></li>
<li><p>修改配置文件</p>
<p>vi ./conf/spark-env.sh</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java</span><br><span class="line">SPARK_MASTER_HOST&#x3D;192.168.231.131 #  实现远程连接</span><br></pre></td></tr></table></figure></li>
<li><p>启动spark</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;sbin&#x2F;start-all.sh  # 启动Spark</span><br></pre></td></tr></table></figure></li>
<li><p>使用</p>
</li>
</ol>
<ul>
<li><p>创建</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.sql.<span class="type">SparkSessionimport</span> org.apache.spark.sql.<span class="type">SparkSession</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> spark = <span class="type">SparkSession</span>.builder().appName(<span class="string">&quot;Spark SQL basic example&quot;</span>).config(<span class="string">&quot;spark.some.config.option&quot;</span>, <span class="string">&quot;some-value&quot;</span>).getOrCreate()</span><br></pre></td></tr></table></figure>
<h3 id="可能存在问题"><a href="#可能存在问题" class="headerlink" title="可能存在问题"></a>可能存在问题</h3><a id="more"></a></li>
<li><p>export: `/usr/lib/jvm/java’: not a valid identifier</p>
<p><code>export JAVA_HOME=/usr/lib/jvm/java</code>: <code>=</code> 号两边不能有空格！</p>
</li>
<li><p>java.net.ConnectException: Connection refused</p>
</li>
<li><p>metastore.ObjectStore: Failed to get database global_temp, returning NoSuchObjectException</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo service hive-metastore status</span><br><span class="line">sudo service hive-server2 status</span><br></pre></td></tr></table></figure></li>
<li><p>org.apache.spark.sql.AnalysisException: Path does not exist: hdfs://localhost:9000/user/spark/examples/src/main/resources/people.json;</p>
</li>
</ul>
]]></content>
      <categories>
        <category>BigData</category>
      </categories>
      <tags>
        <tag>BigData</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Python处理netcdf数据</title>
    <url>/bigdata/python_deal_netcdf/</url>
    <content><![CDATA[<h2 id="利用Python处理netcdf数据"><a href="#利用Python处理netcdf数据" class="headerlink" title="利用Python处理netcdf数据"></a>利用Python处理netcdf数据</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>NetCDF（Network Common Data Format）由UCAR（University Corporation for Atmospheric Research）设计提出，其官方的定义是：NetCDF is a set of software libraries and self-describing, machine-independent data formats that support the creation, access, and sharing of array-oriented scientific data.</p>
<p>NetCDF是面向多维数组的数据集，一个NetCDF文件主要是Dimensions, Variables, Attributes, Data 四个部分组成的：</p>
<ul>
<li><p>Dimension主要是对维度的定义说明，例如：经度，维度，时间等</p>
</li>
<li><p>Variables是对数据表示的现象的说明，例如：温度，湿度，高程等；</p>
</li>
<li><p>Attributes是一些辅助的元信息说明，例如变量的单位等；</p>
</li>
<li><p>Data是主要对现象的观测数据集。</p>
</li>
</ul>
<p>NetCDF有两个数据模型：经典模型（NetCDF3之前模型）和增强模型（NetCDF4）</p>
<p>NetCDF最新版本是NetCDF4，NetCDF4的API接口建立在HDF5之上，和HDF5是兼容的.</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install netCDF4</span><br></pre></td></tr></table></figure>
<h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h3><h4 id="1-创建-打开-关闭netCDF文件"><a href="#1-创建-打开-关闭netCDF文件" class="headerlink" title="1. 创建/打开/关闭netCDF文件"></a>1. 创建/打开/关闭netCDF文件</h4><a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> netCDF4 <span class="keyword">as</span> nc</span><br><span class="line"></span><br><span class="line">rootgrp = nc.Dataset(<span class="string">&#x27;test.nc&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="built_in">format</span>=<span class="string">&#x27;NETCDF4&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> rootgrp.data_model</span><br><span class="line">rootgrp.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="2-在netCDF文件中的组"><a href="#2-在netCDF文件中的组" class="headerlink" title="2. 在netCDF文件中的组"></a>2. 在netCDF文件中的组</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rootgrp = nc.Dataset(<span class="string">&#x27;test.nc&#x27;</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">fcstgrp = rootgrp.createGroup(<span class="string">&#x27;forecasts&#x27;</span>)</span><br><span class="line">analgrp = rootgrp.createGroup(<span class="string">&#x27;analyses&#x27;</span>)</span><br><span class="line">print(rootgrp.groups)</span><br><span class="line"></span><br><span class="line">//像unix那样创建组</span><br><span class="line">fcstgrp1 = rootgrp.createGroup(<span class="string">&#x27;/forecasts/model1&#x27;</span>)</span><br><span class="line">fcstgrp2 = rootgrp.createGroup(<span class="string">&#x27;/forecasts/model2&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="3-在netCDF文件中的维度"><a href="#3-在netCDF文件中的维度" class="headerlink" title="3. 在netCDF文件中的维度"></a>3. 在netCDF文件中的维度</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">level = rootgrp.createDimension(<span class="string">&#x27;level&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line">time = rootgrp.createDimension(<span class="string">&#x27;time&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line">lat = rootgrp.createDimension(<span class="string">&#x27;lat&#x27;</span>, <span class="number">73</span>)</span><br><span class="line">lon = rootgrp.createDimension(<span class="string">&#x27;lon&#x27;</span>, <span class="number">144</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> rootgrp.dimensions  <span class="comment">#dict</span></span><br><span class="line"></span><br><span class="line">print(<span class="built_in">len</span>(lon))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> lon.isunlimited()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> time.isunlimited()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> dimobj <span class="keyword">in</span> rootgrp.dimensions.values():</span><br><span class="line">    print(dimobj)</span><br></pre></td></tr></table></figure>
<h4 id="4-在netCDF文件中的变量"><a href="#4-在netCDF文件中的变量" class="headerlink" title="4. 在netCDF文件中的变量"></a>4. 在netCDF文件中的变量</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">times = rootgrp.createVariable(<span class="string">&#x27;time&#x27;</span>, <span class="string">&#x27;f8&#x27;</span>, (<span class="string">&#x27;time&#x27;</span>, ))</span><br><span class="line">levels = rootgrp.createVariable(<span class="string">&#x27;level&#x27;</span>, <span class="string">&#x27;i4&#x27;</span>, (<span class="string">&#x27;level&#x27;</span>, ))</span><br><span class="line">latitudes = rootgrp.createVariable(<span class="string">&#x27;lat&#x27;</span>, <span class="string">&#x27;f4&#x27;</span>, (<span class="string">&#x27;lat&#x27;</span>, ))</span><br><span class="line">longitudes = rootgrp.createVariable(<span class="string">&#x27;lon&#x27;</span>, <span class="string">&#x27;f4&#x27;</span>, (<span class="string">&#x27;lon&#x27;</span>, ))</span><br><span class="line"></span><br><span class="line"><span class="comment">#二维</span></span><br><span class="line">temp =rootgrp.createVariable(<span class="string">&#x27;temp&#x27;</span>, <span class="string">&#x27;f4&#x27;</span>, (<span class="string">&#x27;time&#x27;</span>, <span class="string">&#x27;level&#x27;</span>, <span class="string">&#x27;lat&#x27;</span>, <span class="string">&#x27;lon&#x27;</span>,))</span><br><span class="line">ftmp =rootgrp.createVariable(<span class="string">&#x27;/forecasts/model1/temp&#x27;</span>, <span class="string">&#x27;f4&#x27;</span>, (<span class="string">&#x27;time&#x27;</span>, <span class="string">&#x27;level&#x27;</span>, <span class="string">&#x27;lat&#x27;</span>, <span class="string">&#x27;lon&#x27;</span>,))</span><br><span class="line"></span><br><span class="line">print(rootgrp[<span class="string">&#x27;/forecasts/model1&#x27;</span>])</span><br><span class="line"></span><br><span class="line">print(rootgrp[<span class="string">&#x27;/forecasts/model1/temp&#x27;</span>])</span><br><span class="line"></span><br><span class="line">print(rootgrp.variables) <span class="comment">#dict</span></span><br></pre></td></tr></table></figure>
<h4 id="5-netCDF文件的属性"><a href="#5-netCDF文件的属性" class="headerlink" title="5. netCDF文件的属性"></a>5. netCDF文件的属性</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">rootgrp.description = <span class="string">&#x27;bogus example script&#x27;</span></span><br><span class="line">rootgrp.history = <span class="string">&#x27;Create &#x27;</span> + time.ctime(time.time())</span><br><span class="line">rootgrp.source = <span class="string">&#x27;netCDF4 Python module tutorial&#x27;</span></span><br><span class="line">latitudes.units = <span class="string">&#x27;degrees north&#x27;</span></span><br><span class="line">longitudes.units = <span class="string">&#x27;degrees east&#x27;</span></span><br><span class="line">levels.units = <span class="string">&#x27;hPa&#x27;</span></span><br><span class="line">temp.units = <span class="string">&#x27;K&#x27;</span></span><br><span class="line">times.units = <span class="string">&#x27;hours since 0001-01-01 00:00:00.0&#x27;</span></span><br><span class="line">times.calendar = <span class="string">&#x27;gregorian&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> rootgrp.ncattrs():</span><br><span class="line">    print(<span class="string">&#x27;Global attr&#x27;</span>, name, <span class="string">&quot;=&quot;</span>, <span class="built_in">getattr</span>(rootgrp,name))</span><br><span class="line"></span><br><span class="line">print(rootgrp.__dict__)</span><br></pre></td></tr></table></figure>
<h4 id="6-从netCDF变量中读取和恢复数据"><a href="#6-从netCDF变量中读取和恢复数据" class="headerlink" title="6. 从netCDF变量中读取和恢复数据"></a>6. 从netCDF变量中读取和恢复数据</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line">lats = numpy.arange(-<span class="number">90</span>, <span class="number">91</span>, <span class="number">2.5</span>)</span><br><span class="line">lons = numpy.arange(-<span class="number">180</span>, <span class="number">180</span>, <span class="number">2.5</span>)</span><br><span class="line">latitudes[:] = lats</span><br><span class="line">longitudes[:] = lons</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;latitudes =\n&#x27;</span>, latitudes[:])</span><br><span class="line"></span><br><span class="line">nlats = <span class="built_in">len</span>(rootgrp.dimensions[<span class="string">&#x27;lat&#x27;</span>])</span><br><span class="line">nlons = <span class="built_in">len</span>(rootgrp.dimensions[<span class="string">&#x27;lon&#x27;</span>])</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;temp shape before adding data =&#x27;</span>, temp.shape)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> numpy.random <span class="keyword">import</span> uniform</span><br><span class="line">temp[<span class="number">0</span>:<span class="number">5</span>, <span class="number">0</span>:<span class="number">10</span>, :, :] = uniform(size=(<span class="number">5</span>, <span class="number">10</span>, nlats, nlons))</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;temp shape after adding data =&#x27;</span>, temp.shape)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;levels shape after adding pressure data =&#x27;</span>, levels.shape)</span><br><span class="line"></span><br><span class="line">levels[:] = [<span class="number">1000.</span>,<span class="number">850.</span>,<span class="number">700.</span>,<span class="number">500.</span>,<span class="number">300.</span>,<span class="number">250.</span>,<span class="number">200.</span>,<span class="number">150.</span>,<span class="number">100.</span>,<span class="number">50.</span>]</span><br><span class="line"></span><br><span class="line">temp[<span class="number">0</span>, <span class="number">0</span>, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line"></span><br><span class="line">tempdat = temp[::<span class="number">2</span>, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>], lats&gt;<span class="number">0</span>, lons&gt;<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;shape of fancy temp slice = &#x27;</span>, tempdat.shape)</span><br></pre></td></tr></table></figure>
<h4 id="7-处理时间坐标"><a href="#7-处理时间坐标" class="headerlink" title="7. 处理时间坐标"></a>7. 处理时间坐标</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line"><span class="keyword">from</span> netCDF4 <span class="keyword">import</span> num2date, date2num</span><br><span class="line"></span><br><span class="line">dates = [datetime(<span class="number">2001</span>, <span class="number">3</span>, <span class="number">1</span>) + n * timedelta(hours=<span class="number">12</span>)</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(temp.shape[<span class="number">0</span>])]</span><br><span class="line"></span><br><span class="line">times[:] = date2num(dates, units=times.units, calendar=times.calendar)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;time values (in units %s): &#x27;</span> % times.units + <span class="string">&#x27;\n&#x27;</span>, times[:])</span><br><span class="line"></span><br><span class="line"><span class="comment">#time values (in units hours since January 1, 0001) : [ 17533056. 17533068. 17533080. 17533092. 17533104.]</span></span><br><span class="line"></span><br><span class="line">dates = num2date(times[:], units=times.units, calendar=times.calendar)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;dates correspoding to time values:\n&#x27;</span>,dates)</span><br></pre></td></tr></table></figure>
<h4 id="8-从一个netCDF数据集中读取数据"><a href="#8-从一个netCDF数据集中读取数据" class="headerlink" title="8. 从一个netCDF数据集中读取数据"></a>8. 从一个netCDF数据集中读取数据</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> nf <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    f = np.Dataset(<span class="string">&#x27;mftest%s.nc&#x27;</span> % nf, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    f.createDimension(<span class="string">&#x27;x&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line">    x = f.createVariable(<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, (<span class="string">&#x27;x&#x27;</span>,))</span><br><span class="line">    x[<span class="number">0</span>:<span class="number">10</span>] = numpy.arange(nf * <span class="number">10</span>, <span class="number">10</span> * (nf + <span class="number">1</span>))</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> netCDF4 <span class="keyword">import</span> MFDataset</span><br><span class="line">f = MFDataset(<span class="string">&#x27;mftest*nc&#x27;</span>)</span><br><span class="line">print(f.variables[<span class="string">&#x27;x&#x27;</span>][:])</span><br></pre></td></tr></table></figure>
<h4 id="9-关于netCDF变量的有效压缩"><a href="#9-关于netCDF变量的有效压缩" class="headerlink" title="9. 关于netCDF变量的有效压缩"></a>9. 关于netCDF变量的有效压缩</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">temp = rootgrp.createVariable(<span class="string">&#x27;temp&#x27;</span>, <span class="string">&#x27;f4&#x27;</span>, (<span class="string">&#x27;time&#x27;</span>, <span class="string">&#x27;level&#x27;</span>, <span class="string">&#x27;lat&#x27;</span>, <span class="string">&#x27;lon&#x27;</span>,))</span><br><span class="line"></span><br><span class="line">temp = rootgrp.createVariable(<span class="string">&#x27;temp&#x27;</span>, <span class="string">&#x27;f4&#x27;</span>, (<span class="string">&#x27;time&#x27;</span>, <span class="string">&#x27;level&#x27;</span>, <span class="string">&#x27;lat&#x27;</span>, <span class="string">&#x27;lon&#x27;</span>,), zlib=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">temp = rootgrp.createVariable(<span class="string">&#x27;temp&#x27;</span>, <span class="string">&#x27;f4&#x27;</span>, (<span class="string">&#x27;time&#x27;</span>, <span class="string">&#x27;level&#x27;</span>, <span class="string">&#x27;lat&#x27;</span>, <span class="string">&#x27;lon&#x27;</span>,), zlib=<span class="literal">True</span>, least_significantdigis=<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<h4 id="10-除固定类型的同构数组之外的——复合数据类型"><a href="#10-除固定类型的同构数组之外的——复合数据类型" class="headerlink" title="10. 除固定类型的同构数组之外的——复合数据类型"></a>10. 除固定类型的同构数组之外的——复合数据类型</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = nc.Dataset(<span class="string">&#x27;complex.nc&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">size = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">datac = numpy.exp(<span class="number">1j</span> * (<span class="number">1.</span> + numpy.linspace(<span class="number">0</span>, numpy.pi, size)))</span><br><span class="line"></span><br><span class="line">complex128 = numpy.dtype([(<span class="string">&#x27;real&#x27;</span>, numpy.float64), (<span class="string">&#x27;imag&#x27;</span>, numpy.float64)])</span><br><span class="line"></span><br><span class="line">complex128_t = f.createCompoundType(complex128, <span class="string">&#x27;complex128&#x27;</span>)</span><br><span class="line">f.createDimension(<span class="string">&#x27;x_dim&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line">v = createVariable(<span class="string">&#x27;cmplx_var&#x27;</span>, complex128_t, <span class="string">&#x27;x_dim&#x27;</span>)</span><br><span class="line">data = numpy.empty(size, complex128)</span><br><span class="line">data[<span class="string">&#x27;real&#x27;</span>] = datac.real; data[<span class="string">&#x27;imag&#x27;</span>] = datac.imag</span><br><span class="line">v[:] = data</span><br><span class="line">f.close(); f = nc.Dataset(<span class="string">&#x27;complex.nc&#x27;</span>)</span><br><span class="line">v = f.variables[<span class="string">&#x27;cmplx_var&#x27;</span>]</span><br><span class="line">datain = v[:]</span><br><span class="line"></span><br><span class="line">datac2 = numpy.empty(datain.shape, numpy.complex128)</span><br><span class="line"></span><br><span class="line">datac2.real = datain[<span class="string">&#x27;real&#x27;</span>]; datac2.imag = datain[<span class="string">&#x27;imag&#x27;</span>]</span><br><span class="line"></span><br><span class="line">print(datac.dtype, datatc)</span><br><span class="line"></span><br><span class="line">print(datac2.dtype, datac2)</span><br><span class="line"></span><br><span class="line">print(f)</span><br></pre></td></tr></table></figure>
<h4 id="11-可变（vlen）数据类型"><a href="#11-可变（vlen）数据类型" class="headerlink" title="11. 可变（vlen）数据类型"></a>11. 可变（vlen）数据类型</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = nc.Dataset(<span class="string">&quot;tst_vlen.nc&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">vlen_t = f.createVLType(numpy.int32, <span class="string">&#x27;phnoy_vlen&#x27;</span>)</span><br><span class="line"></span><br><span class="line">x = f.createDimension(<span class="string">&#x27;x&#x27;</span>, <span class="number">3</span>)</span><br><span class="line">y = f.createDimension(<span class="string">&#x27;y&#x27;</span>, <span class="number">4</span>)</span><br><span class="line">vlvar = f.createVariable(<span class="string">&#x27;phnoy_vlen_var&#x27;</span>, vlen_t, (<span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;x&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">data = numpy.empty(<span class="built_in">len</span>(y)*<span class="built_in">len</span>(x),<span class="built_in">object</span>)</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(y)*<span class="built_in">len</span>(x)):</span><br><span class="line">   data[n] = numpy.arange(random.randint(<span class="number">1</span>,<span class="number">10</span>),dtype=<span class="string">&quot;int32&quot;</span>)+<span class="number">1</span></span><br><span class="line">data = numpy.reshape(data,(<span class="built_in">len</span>(y),<span class="built_in">len</span>(x)))</span><br><span class="line">vlvar[:] = data</span><br><span class="line">print(<span class="string">&quot;vlen variable =\n&quot;</span>,vlvar[:])</span><br><span class="line"></span><br><span class="line">print(f)</span><br><span class="line"></span><br><span class="line">print(f.variables[<span class="string">&quot;phony_vlen_var&quot;</span>])</span><br><span class="line"></span><br><span class="line">print(f.VLtypes[<span class="string">&quot;phony_vlen&quot;</span>])</span><br><span class="line"></span><br><span class="line">z = f.createDimension(<span class="string">&quot;z&quot;</span>,<span class="number">10</span>)</span><br><span class="line">strvar = rootgrp.createVariable(<span class="string">&quot;strvar&quot;</span>, <span class="built_in">str</span>, <span class="string">&quot;z&quot;</span>)</span><br><span class="line">chars = <span class="string">&quot;1234567890aabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span></span><br><span class="line"></span><br><span class="line">data = numpy.empty(<span class="number">10</span>,<span class="string">&quot;O&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    stringlen = random.randint(<span class="number">2</span>,<span class="number">12</span>)</span><br><span class="line">    data[n] = <span class="string">&quot;&quot;</span>.join([random.choice(chars) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(stringlen)])</span><br><span class="line">strvar[:] = data</span><br><span class="line">print(<span class="string">&quot;variable-length string variable:\n&quot;</span>,strvar[:])</span><br><span class="line"></span><br><span class="line">print(f)</span><br><span class="line"></span><br><span class="line">print(f.variables[<span class="string">&quot;strvar&quot;</span>])</span><br></pre></td></tr></table></figure>
<h4 id="12-枚举数据类型"><a href="#12-枚举数据类型" class="headerlink" title="12. 枚举数据类型"></a>12. 枚举数据类型</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nc = Dataset(<span class="string">&#x27;clouds.nc&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="comment"># python dict with allowed values and their names.</span></span><br><span class="line">enum_dict = &#123;<span class="string">u&#x27;Altocumulus&#x27;</span>: <span class="number">7</span>, <span class="string">u&#x27;Missing&#x27;</span>: <span class="number">255</span>,</span><br><span class="line"><span class="string">u&#x27;Stratus&#x27;</span>: <span class="number">2</span>, <span class="string">u&#x27;Clear&#x27;</span>: <span class="number">0</span>,</span><br><span class="line"><span class="string">u&#x27;Nimbostratus&#x27;</span>: <span class="number">6</span>, <span class="string">u&#x27;Cumulus&#x27;</span>: <span class="number">4</span>, <span class="string">u&#x27;Altostratus&#x27;</span>: <span class="number">5</span>,</span><br><span class="line"><span class="string">u&#x27;Cumulonimbus&#x27;</span>: <span class="number">1</span>, <span class="string">u&#x27;Stratocumulus&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="comment"># create the Enum type called &#x27;cloud_t&#x27;.</span></span><br><span class="line">cloud_type = nc.createEnumType(numpy.uint8,<span class="string">&#x27;cloud_t&#x27;</span>,enum_dict)</span><br><span class="line">print(cloud_type)</span><br><span class="line"></span><br><span class="line">time = nc.createDimension(<span class="string">&#x27;time&#x27;</span>,<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># create a 1d variable of type &#x27;cloud_type&#x27;.</span></span><br><span class="line"><span class="comment"># The fill_value is set to the &#x27;Missing&#x27; named value.</span></span><br><span class="line">cloud_var =</span><br><span class="line">nc.createVariable(<span class="string">&#x27;primary_cloud&#x27;</span>,cloud_type,<span class="string">&#x27;time&#x27;</span>,</span><br><span class="line">fill_value=enum_dict[<span class="string">&#x27;Missing&#x27;</span>])</span><br><span class="line"><span class="comment"># write some data to the variable.</span></span><br><span class="line">cloud_var[:] = [enum_dict[<span class="string">&#x27;Clear&#x27;</span>],enum_dict[<span class="string">&#x27;Stratus&#x27;</span>],</span><br><span class="line">enum_dict[<span class="string">&#x27;Cumulus&#x27;</span>],enum_dict[<span class="string">&#x27;Missing&#x27;</span>],</span><br><span class="line">enum_dict[<span class="string">&#x27;Cumulonimbus&#x27;</span>]]</span><br><span class="line">nc.close()</span><br><span class="line"><span class="comment"># reopen the file, read the data.</span></span><br><span class="line">nc = Dataset(<span class="string">&#x27;clouds.nc&#x27;</span>)</span><br><span class="line">cloud_var = nc.variables[<span class="string">&#x27;primary_cloud&#x27;</span>]</span><br><span class="line">print(cloud_var)</span><br><span class="line"></span><br><span class="line">print(cloud_var.datatype.enum_dict)</span><br><span class="line"></span><br><span class="line">print(cloud_var[:])</span><br></pre></td></tr></table></figure>
<h4 id="13-并行IO"><a href="#13-并行IO" class="headerlink" title="13. 并行IO"></a>13. 并行IO</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mpi4py <span class="keyword">import</span> MPI</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> netCDF4 <span class="keyword">import</span> Dataset</span><br><span class="line">rank = MPI.COMM_WORLD.rank  <span class="comment"># The process ID (integer 0-3 for 4-process run)</span></span><br><span class="line">nc = Dataset(<span class="string">&#x27;parallel_tst.nc&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,parallel=<span class="literal">True</span>)</span><br><span class="line">d = nc.createDimension(<span class="string">&#x27;dim&#x27;</span>,<span class="number">4</span>)</span><br><span class="line">v = nc.createVariable(<span class="string">&#x27;var&#x27;</span>, numpy.<span class="built_in">int</span>, <span class="string">&#x27;dim&#x27;</span>)</span><br><span class="line">v[rank] = rank</span><br><span class="line">nc.close()</span><br></pre></td></tr></table></figure>
<h4 id="14-字符串处理"><a href="#14-字符串处理" class="headerlink" title="14. 字符串处理"></a>14. 字符串处理</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = nc.Dataset(<span class="string">&quot;stringtest.nc&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">format</span>=<span class="string">&#x27;NETCDF4_CLASSIC&#x27;</span>)</span><br><span class="line"></span><br><span class="line">x = f.createDimension(<span class="string">&#x27;nchars&#x27;</span>, <span class="number">3</span>)</span><br><span class="line">y = f.createDimension(<span class="string">&#x27;nstrings&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line">v = f.createVariable(<span class="string">&#x27;strings&#x27;</span>, <span class="string">&#x27;S1&#x27;</span>, (<span class="string">&#x27;nstrings&#x27;</span>, <span class="string">&#x27;nchars&#x27;</span>))</span><br><span class="line">datain = numpy.array([<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>], dtype=<span class="string">&#x27;S3&#x27;</span>)</span><br><span class="line">V[:] = stringtochar(datain)</span><br><span class="line">V[:]</span><br><span class="line">V_Encoding = <span class="string">&#x27;ascii&#x27;</span></span><br><span class="line">V[:] = datain</span><br><span class="line">V[:]</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nc = Dataset(<span class="string">&#x27;compoundstring_example.nc&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">dtype = numpy.dtype([(<span class="string">&#x27;observation&#x27;</span>, <span class="string">&#x27;f4&#x27;</span>),</span><br><span class="line">                  (<span class="string">&#x27;station_name&#x27;</span>,<span class="string">&#x27;S80&#x27;</span>)])</span><br><span class="line">station_data_t = nc.createCompoundType(dtype,<span class="string">&#x27;station_data&#x27;</span>)</span><br><span class="line">nc.createDimension(<span class="string">&#x27;station&#x27;</span>,<span class="literal">None</span>)</span><br><span class="line">statdat = nc.createVariable(<span class="string">&#x27;station_obs&#x27;</span>, station_data_t, (<span class="string">&#x27;station&#x27;</span>,))</span><br><span class="line">data = numpy.empty(<span class="number">2</span>,dtype)</span><br><span class="line">data[<span class="string">&#x27;observation&#x27;</span>][:] = (<span class="number">123.</span>,<span class="number">3.14</span>)</span><br><span class="line">data[<span class="string">&#x27;station_name&#x27;</span>][:] = (<span class="string">&#x27;Boulder&#x27;</span>,<span class="string">&#x27;New York&#x27;</span>)</span><br><span class="line">statdat.dtype <span class="comment"># strings actually stored as character arrays</span></span><br><span class="line">&#123;<span class="string">&#x27;names&#x27;</span>:[<span class="string">&#x27;observation&#x27;</span>,<span class="string">&#x27;station_name&#x27;</span>], <span class="string">&#x27;formats&#x27;</span>:[<span class="string">&#x27;&lt;f4&#x27;</span>,(<span class="string">&#x27;S1&#x27;</span>, (<span class="number">80</span>,))], <span class="string">&#x27;offsets&#x27;</span>:[<span class="number">0</span>,<span class="number">4</span>], <span class="string">&#x27;itemsize&#x27;</span>:<span class="number">84</span>, <span class="string">&#x27;aligned&#x27;</span>:<span class="literal">True</span>&#125;</span><br><span class="line">statdat[:] = data <span class="comment"># strings converted to character arrays internally</span></span><br><span class="line">statdat[:] <span class="comment"># character arrays converted back to strings</span></span><br><span class="line">[(<span class="number">123.</span>  , <span class="string">&#x27;Boulder&#x27;</span>) (  <span class="number">3.14</span>, <span class="string">&#x27;New York&#x27;</span>)]</span><br><span class="line">statdat[:].dtype</span><br><span class="line">&#123;<span class="string">&#x27;names&#x27;</span>:[<span class="string">&#x27;observation&#x27;</span>,<span class="string">&#x27;station_name&#x27;</span>], <span class="string">&#x27;formats&#x27;</span>:[<span class="string">&#x27;&lt;f4&#x27;</span>,<span class="string">&#x27;S80&#x27;</span>], <span class="string">&#x27;offsets&#x27;</span>:[<span class="number">0</span>,<span class="number">4</span>], <span class="string">&#x27;itemsize&#x27;</span>:<span class="number">84</span>, <span class="string">&#x27;aligned&#x27;</span>:<span class="literal">True</span>&#125;</span><br><span class="line">statdat.set_auto_chartostring(<span class="literal">False</span>) <span class="comment"># turn off auto-conversion</span></span><br><span class="line">statdat[:] = data.view(dtype=[(<span class="string">&#x27;observation&#x27;</span>, <span class="string">&#x27;f4&#x27;</span>),(<span class="string">&#x27;station_name&#x27;</span>,<span class="string">&#x27;S1&#x27;</span>,<span class="number">10</span>)])</span><br><span class="line">statdat[:] <span class="comment"># now structured array with char array subtype is returned</span></span><br><span class="line">[(<span class="number">123.</span>  , [<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>])</span><br><span class="line">(  <span class="number">3.14</span>, [<span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;Y&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>])]</span><br><span class="line">nc.close()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>BigData</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python、BigData</tag>
      </tags>
  </entry>
  <entry>
    <title>利用python下载哨兵2(sentinel 2)数据</title>
    <url>/bigdata/download_sentinel_data/</url>
    <content><![CDATA[<h2 id="利用python下载哨兵2-sentinel-2-数据"><a href="#利用python下载哨兵2-sentinel-2-数据" class="headerlink" title="利用python下载哨兵2(sentinel 2)数据"></a>利用python下载哨兵2(sentinel 2)数据</h2><p>近期由于在工作实验室要研究影像数据，所以需要下载欧空局（ESA）的哨兵2（sentinel 2）的再分析数据，本人通过官网上提供的API接口，对哨兵2（sentinel 2）数据进行批量下载。这种下载ECMWF数据的方法在<a href="https://confluence.ecmwf.int/display/WEBAPI/Access+ECMWF+Public+Datasets">官网</a>上有非常详细的介绍。</p>
<h3 id="注册账户并下载数据"><a href="#注册账户并下载数据" class="headerlink" title="注册账户并下载数据"></a>注册账户并下载数据</h3><ol>
<li><p>注册账户</p>
<p>首先，我们需要注册一个欧空局（ESA）的账号，在<a href="https://scihub.copernicus.eu/">官网</a>点击<strong>Open Hub</strong>,然后进行<a href="https://scihub.copernicus.eu/dhus/#/self-registration">注册</a>，如下图所示，进行注册：</p>
<p><img src="download_sentinel_data/main.png" alt="main"></p>
<p>在注册完成后，点击登陆即可，登陆后的界面如下图所示：</p>
<p><img src="download_sentinel_data/maininterface.png" alt="maininterface"></p>
</li>
<li><p>设置查询条件</p>
<p>如下图所示设置查询范围和条件，点击查询按钮进行查询：</p>
<p><img src="download_sentinel_data/selectregion.png" alt="selectregion"></p>
</li>
<li><p>数据下载</p>
<p><img src="download_sentinel_data/selectresult.png" alt="selectresult"><br>此时可以从查询后的结果中，选择需要的影像进行下载。</p>
</li>
</ol>
<h3 id="数据批量下载"><a href="#数据批量下载" class="headerlink" title="数据批量下载"></a>数据批量下载</h3><a id="more"></a>
<ol>
<li><p>API hub</p>
<p>通过API hub可以实现数据的批量下载，如下图所示：</p>
<p><img src="download_sentinel_data/apihub.png" alt="apihub"></p>
</li>
<li><p>安装sentinelsat</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple sentinelsat</span><br></pre></td></tr></table></figure></li>
<li><p>代码展示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sentinelsat.sentinel <span class="keyword">import</span> SentinelAPI, read_geojson, geojson_to_wkt</span><br><span class="line">api = SentinelAPI(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;paswword&#x27;</span>, <span class="string">&#x27;https://scihub.copernicus.eu/dhus&#x27;</span>)</span><br><span class="line"><span class="comment"># search by polygon, time, and Hub query keywords</span></span><br><span class="line">footprint = geojson_to_wkt(read_geojson(<span class="string">&#x27;map.geojson&#x27;</span>)) <span class="comment"># 设置范围</span></span><br><span class="line">products = api.query(footprint,</span><br><span class="line">                     date = (<span class="string">&#x27;20151219&#x27;</span>, date(<span class="number">2015</span>, <span class="number">12</span>, <span class="number">29</span>)),</span><br><span class="line">                     platformname = <span class="string">&#x27;Sentinel-2&#x27;</span>,</span><br><span class="line">                     cloudcoverpercentage = (<span class="number">0</span>, <span class="number">30</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># download all results from the search</span></span><br><span class="line">api.download_all(products, outfolder, , checksum=<span class="literal">False</span>) <span class="comment"># 此处checksum默认为True，本人在下载的时候出现问题，所以设置False</span></span><br></pre></td></tr></table></figure>
<p>更多信息，查看本人<a href="https://github.com/javyxu/download_sentineal_data">GitHub</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>BigData</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python、BigData</tag>
      </tags>
  </entry>
  <entry>
    <title>利用python下载ECMWF数据</title>
    <url>/bigdata/download_ecmwf_data/</url>
    <content><![CDATA[<h2 id="利用python下载ECMWF数据"><a href="#利用python下载ECMWF数据" class="headerlink" title="利用python下载ECMWF数据"></a>利用python下载ECMWF数据</h2><p>近期由于在工作实验室要研究影像数据，所以需要下载ECMWF（欧洲中期天气预报中心）的再分析数据，本人通过官网上提供的API借口，对ECMWF欧洲中心API进行批量下载。这种下载ECMWF数据的方法在<a href="https://confluence.ecmwf.int/display/WEBAPI/Access+ECMWF+Public+Datasets">官网</a>上有非常详细的介绍。</p>
<h3 id="注册账户并获取apiKey"><a href="#注册账户并获取apiKey" class="headerlink" title="注册账户并获取apiKey"></a>注册账户并获取apiKey</h3><ol>
<li><p>注册账户</p>
<p>首先，我们需要注册一个ECMWF的账号，在官网点击<a href="https://apps.ecmwf.int/registration/">注册</a>，如下图所示，进行注册：</p>
<p><img src="download_ecmwf_data/login.png" alt="login"></p>
<p>在注册完成后，点击登陆即可。</p>
</li>
<li><p>获取api key</p>
<p>通过<a href="https://api.ecmwf.int/v1/key/">此地址</a>可以获取API key。</p>
<p><img src="download_ecmwf_data/apikey.png" alt="apikey"></p>
<p>再获取到此信息后，在<code>$HOME</code>下新建**.ecmwfapirc**，并将最后一栏内的信息，保存。</p>
</li>
<li><p>安装ecmwf-api-client-python</p>
<p>点击<a href="https://confluence.ecmwf.int/display/WEBAPI/Web-API+Downloads">此处</a>可以下载合适的ecmwf-api-client-python安装包，进行安装。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install https:&#x2F;&#x2F;software.ecmwf.int&#x2F;wiki&#x2F;download&#x2F;attachments&#x2F;56664858&#x2F;ecmwf-api-client-python.tgz</span><br></pre></td></tr></table></figure>
<h3 id="数据下载"><a href="#数据下载" class="headerlink" title="数据下载"></a>数据下载</h3><a id="more"></a></li>
<li><p>了解想要下载数据的信息</p>
<p>点击<a href="https://apps.ecmwf.int/datasets/">数据集</a>获取所有公开的数据集，如下图所示：</p>
<p><img src="download_ecmwf_data/datasets.png" alt="datasets"></p>
<p>本人下载的是<strong>ERA Interim</strong>数据集，如下图所示：</p>
<p><img src="download_ecmwf_data/selecteddataset.png" alt="ERA Interim"></p>
<p>选择下载月份、时间等信息，本人选择如下参数：</p>
<p><img src="download_ecmwf_data/params.png" alt="params"></p>
<p>点击<strong>View the MARS requests</strong>,即可查看Python脚本代码</p>
<p><img src="download_ecmwf_data/viewpythoncode.png" alt="viewpythoncode"></p>
<p><img src="download_ecmwf_data/resultcode.png" alt="resultcode"></p>
</li>
<li><p>参数详解</p>
<p>主要注意以下几个参数：</p>
</li>
</ol>
<ul>
<li><p>date：选择下载数据的日期</p>
</li>
<li><p>param：不同的数据类型，有不同的参数，</p>
<p>  下面几个参数是本人下载的时候所查找的查找方式可以看上一节：</p>
<p>  <img src="download_ecmwf_data/paramsvalue.png" alt="paramsvalue"></p>
</li>
<li><p>format： 输出格式，可以指定为<code>netcdf</code></p>
</li>
<li><p>target： 输出路径</p>
</li>
</ul>
<ol start="3">
<li><p>代码展示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ecmwfapi <span class="keyword">import</span> ECMWFDataServer</span><br><span class="line">server = ECMWFDataServer()</span><br><span class="line">a = linecache.getlines(<span class="string">&#x27;./month.txt&#x27;</span>)</span><br><span class="line">cur = datetime.datetime.now()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> params.items():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2010</span>, cur.year):</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">4</span> == <span class="number">0</span>:</span><br><span class="line">            m = <span class="number">29</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            m = <span class="number">28</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">13</span>):</span><br><span class="line">            <span class="keyword">if</span> j == <span class="number">2</span>:</span><br><span class="line">                b = m</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                b = a[j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> j &lt; <span class="number">10</span>:</span><br><span class="line">                y = <span class="string">&#x27;0&#x27;</span>+ <span class="built_in">str</span>(j)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                y = <span class="built_in">str</span>(j)</span><br><span class="line">            date = <span class="built_in">str</span>(i) + <span class="string">&#x27;-&#x27;</span> + y + <span class="string">&#x27;-01/to/&#x27;</span> + <span class="built_in">str</span>(i) + <span class="string">&#x27;-&#x27;</span> + y + <span class="string">&#x27;-&#x27;</span> + <span class="built_in">str</span>(b)</span><br><span class="line">            <span class="comment"># print(date)</span></span><br><span class="line">            <span class="comment"># from ecmwfapi import ECMWFDataServer</span></span><br><span class="line">            <span class="comment"># server = ECMWFDataServer()</span></span><br><span class="line">            filename = <span class="built_in">str</span>(i) + y + <span class="string">&#x27;01&#x27;</span> + k + <span class="string">&#x27;.nc&#x27;</span></span><br><span class="line">            path = os.path.join(outfolder, k)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):</span><br><span class="line">                os.makedirs(path)</span><br><span class="line">            fullpath = os.path.join(path, filename)</span><br><span class="line">            print(<span class="string">&#x27;=====================================&#x27;</span>)</span><br><span class="line">            print(<span class="string">&#x27;start download &#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(filename))</span><br><span class="line">            server.retrieve(&#123;</span><br><span class="line">                <span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;ei&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;dataset&#x27;</span>: <span class="string">&#x27;interim&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;date&#x27;</span>: date,     <span class="comment"># &#x27;2018-02-01/to/2018-02-28&#x27;,</span></span><br><span class="line">                <span class="string">&#x27;expver&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;grid&#x27;</span>: <span class="string">&#x27;0.75/0.75&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;levtype&#x27;</span>: <span class="string">&#x27;sfc&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;param&#x27;</span>: v,  <span class="comment"># &#x27;167.128&#x27;,</span></span><br><span class="line">                <span class="string">&#x27;step&#x27;</span>: <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;stream&#x27;</span>: <span class="string">&#x27;oper&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;time&#x27;</span>: <span class="string">&#x27;00:00:00&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;an&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;format&#x27;</span>: <span class="string">&#x27;netcdf&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;target&#x27;</span>: fullpath</span><br><span class="line">            &#125;)</span><br><span class="line">            print(<span class="string">&#x27;&#123;0&#125; file download success!&#x27;</span>.<span class="built_in">format</span>(filename))</span><br><span class="line">            print(<span class="string">&#x27;======================================&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>更多信息，请查看本人Github(<a href="https://github.com/javyxu/download_ecmwf_datasets">https://github.com/javyxu/download_ecmwf_datasets</a>)</p>
</li>
</ol>
]]></content>
      <categories>
        <category>BigData</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python、BigData</tag>
      </tags>
  </entry>
  <entry>
    <title>OLTP和OLAP的关系</title>
    <url>/bigdata/oltp_olap_doc/</url>
    <content><![CDATA[<h2 id="OLTP和OLAP的关系"><a href="#OLTP和OLAP的关系" class="headerlink" title="OLTP和OLAP的关系"></a>OLTP和OLAP的关系</h2><h3 id="联机事务处理"><a href="#联机事务处理" class="headerlink" title="联机事务处理"></a>联机事务处理</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>OLTP（on-line transaction processing）主要是执行基本日常的事务处理，比如数据库中得增删改。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol>
<li><p>实时性要求高。（分分钟到账）</p>
</li>
<li><p>数据量不是很大，生产库上的数据量一般不会太大，而且会及时做出相应的数据处理与转移。</p>
</li>
<li><p>对确定性的数据进行存取</p>
</li>
<li><p>高并发，并且满足ACID原则。（两人同时操作一张银行卡账户、大型的购物网站秒杀活动）</p>
</li>
</ol>
<h3 id="联机分析处理"><a href="#联机分析处理" class="headerlink" title="联机分析处理"></a>联机分析处理</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>OLAP（On-Line Analytical Processing）是数据仓库系统的主要应用，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。典型的应用就是复杂的动态的报表系统。</p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ol>
<li><p>实时性要求不高，比如最常见的应用就是天级更新数据，然后出对应的数据报表。</p>
</li>
<li><p>数据量大。因为支持动态查询</p>
</li>
<li><p>通过数据提供决策支持。</p>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><a id="more"></a>

<p><strong>OLTP即联机事务处理：</strong> 就是我们经常说的关系数据库，增删查改就是我们经常应用的东西，这是数据库的基础；TPCC(Transaction Processing Performance Council)属于此类。</p>
<p><strong>OLAP即联机分析处理：</strong> 是数据仓库的核心部心，所谓数据仓库是对于大量已经由OLTP形成的数据的一种分析型的数据库，用于处理商业智能、决策支持等重要的决策信息；数据仓库是在数据库应用到一定程序之后而对历史数据的加工与分析，读取较多，更新较少，TPCH属于此类。</p>
<p>随着大数据时代的到来，对于OLAP，列存储模式或者说nosql模式比传统意义的行存储模式可能更具优势。</p>
<h2 id="ACID说明"><a href="#ACID说明" class="headerlink" title="ACID说明"></a>ACID说明</h2><p>数据库事务正确执行的四个基本要素得缩写。原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。</p>
<h3 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h3><p>要么完成要么不完成、执行过程中实现回滚。</p>
<h3 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h3><p>一个事务可以封装状态改变（除非它是一个只读的）。事务必须始终保持系统处于一致的状态，不管在任何给定的时间并发事务有多少。</p>
<h3 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h3><p>隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同一时间仅有一个请求用于同一数据。</p>
<h3 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a>持久性（Durability）</h3><p>在事务完成以后，该事务对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</p>
]]></content>
      <categories>
        <category>BigData</category>
        <category>PostgresSQL</category>
      </categories>
      <tags>
        <tag>BigData、PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask Web 开发</title>
    <url>/python/flask_web_dev/</url>
    <content><![CDATA[<h2 id="Flask-Web-开发"><a href="#Flask-Web-开发" class="headerlink" title="Flask Web 开发"></a>Flask Web 开发</h2><h3 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h3><p>Flask由3个主要依赖：路由、调试和Web服务器网关接口（WSGI， Web Server gateway interface）子系统由Werkzeug提供；模版系统由Jinjia2提供；命令行集成由Click提供。</p>
<h4 id="1-1-虚拟环境"><a href="#1-1-虚拟环境" class="headerlink" title="1.1 虚拟环境"></a>1.1 虚拟环境</h4><p>虚拟环境的安装和使用，请看本人的博客<a href="https://javyxu.cn/Python/python_virtual_env/">Python虚拟环境的安装</a></p>
<h3 id="二、应用的基本机构"><a href="#二、应用的基本机构" class="headerlink" title="二、应用的基本机构"></a>二、应用的基本机构</h3><h4 id="2-1-初始化"><a href="#2-1-初始化" class="headerlink" title="2.1 初始化"></a>2.1 初始化</h4><p>所有的Flask必须创建一个应用实例。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br></pre></td></tr></table></figure>
<h4 id="2-2-路由和视图函数"><a href="#2-2-路由和视图函数" class="headerlink" title="2.2 路由和视图函数"></a>2.2 路由和视图函数</h4><a id="more"></a>
<p>客户端把请求发送给Web服务器，Web服务器再把请求发送给Flask应用实例。</p>
<p>处理URL和函数之间关系的程序成为<strong>路由</strong> 。</p>
<p>比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&lt;h1&gt;Hello World!&lt;/h1&gt;&#x27;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&lt;h1&gt;Hello World!&lt;/h1&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line">app.add_url_rule(<span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;index&#x27;</span>, index)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/user/&lt;name&gt;&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&lt;h1&gt;Hello, &#123;&#125;!&lt;/h1&gt;&#x27;</span>.<span class="built_in">format</span>(name)</span><br></pre></td></tr></table></figure>
<h4 id="2-3-请求-响应循环"><a href="#2-3-请求-响应循环" class="headerlink" title="2.3 请求-响应循环"></a>2.3 请求-响应循环</h4><h5 id="2-3-1-应用和请求上下文"><a href="#2-3-1-应用和请求上下文" class="headerlink" title="2.3.1 应用和请求上下文"></a>2.3.1 应用和请求上下文</h5><p>在Flask中有两种上下文：<strong>应用上下文</strong> 和<strong>请求上下文</strong> 。</p>
<p>Flask上下文全局变量</p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>上下文</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>current_app</td>
<td>应用上下文</td>
<td>当前应用的应用实例</td>
</tr>
<tr>
<td>g</td>
<td>应用上下文</td>
<td>处理请求时用作临时存储的对象， 每次请求都会重设这个变量</td>
</tr>
<tr>
<td>request</td>
<td>请求上下文</td>
<td>请求对象，封装了客户端发出的HTTP请求中的内容</td>
</tr>
<tr>
<td>session</td>
<td>请求上下文</td>
<td>用户会话，值为一个字典，存储请求之间需要“记住”的值</td>
</tr>
</tbody></table>
<h5 id="2-3-2-请求对象"><a href="#2-3-2-请求对象" class="headerlink" title="2.3.2 请求对象"></a>2.3.2 请求对象</h5><p>Flask请求对象中最常用的属性和方法：</p>
<p>| 属性或方法 | 说明 |<br>| form | 一个字段，存储请求提交的所有表单字段 |</p>
<h3 id="二、应用编程接口"><a href="#二、应用编程接口" class="headerlink" title="二、应用编程接口"></a>二、应用编程接口</h3><p>Flask是开发表现层状态转移(REST，representational state transfer)架构Web服务的理想框架，因为Flask天生轻量。</p>
<h4 id="2-1-REST简介"><a href="#2-1-REST简介" class="headerlink" title="2.1 REST简介"></a>2.1 REST简介</h4><p>REST架构方式的六大特征：</p>
<ol>
<li><p>客户端-服务端</p>
<p>客户端和服务端之间必须要有明确的界线。</p>
</li>
<li><p>无状态</p>
<p>客户端发出的请求这必须包含所有必要的信息。服务器不能在两次请求之间保存客户端的任何状态。</p>
</li>
<li><p>缓存</p>
<p>服务器发出的响应可以标记为可缓存或不可缓存，这样处于优化目的，客户端（或客户端和服务器之间的中间服务）可以使用缓存。</p>
</li>
<li><p>接口统一</p>
<p>客户端访问服务器资源时使用的协议必须一致、定义良好，且已经标准化。这是REST架构最复杂的一方面，涉及唯一的资源标识符、资源表述、客户端和服务器中间自描述的消息，以及超媒体（hypermedia）。</p>
</li>
<li><p>系统分层</p>
<p>在客户端和服务器之间可以按需插入代理服务器、缓存或网关，以提高性能、稳定性和伸缩性。</p>
</li>
<li><p>按需编程</p>
<p>客户端可以选择从服务器中下载代码，在客户端的上下文中执行。</p>
</li>
</ol>
<h5 id="2-1-1-资源就是一切"><a href="#2-1-1-资源就是一切" class="headerlink" title="2.1.1 资源就是一切"></a>2.1.1 资源就是一切</h5><p><strong>资源</strong> 是REST架构风格的核心概念。在REST结构中。资源是应用中你要着重关注的事物。</p>
<p>每个资源都要有唯一的URL表示。对HTTP协议来说，资源的标识符就是URL。</p>
<p>某一类资源的集合也要有一个URL。</p>
<p>API还可以为某一类资源的逻辑子集定义集合URL。</p>
<h5 id="2-1-2-请求方法"><a href="#2-1-2-请求方法" class="headerlink" title="2.1.2 请求方法"></a>2.1.2 请求方法</h5><p>客户端应用在建立起的资源URL上发送请求，使用请求方法表示期望的操作。</p>
<table>
<thead>
<tr>
<th>请求方法</th>
<th>目标</th>
<th>说明</th>
<th>HTTP状态码</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>单个资源的URL</td>
<td>获取目标资源</td>
<td>200</td>
</tr>
<tr>
<td>GET</td>
<td>资源集合的URL</td>
<td>获取资源的集合（如果是服务器实现了分页，还可以是一叶中的资源）</td>
<td>200</td>
</tr>
<tr>
<td>POST</td>
<td>资源集合的URL</td>
<td>创建新资源，并将其加入目标集合。服务器为新资源指派URL，并在响应的Location首部中返回</td>
<td>201</td>
</tr>
<tr>
<td>PUT</td>
<td>单个资源的URL</td>
<td>修改一个现有资源。如果客户端能为资源指派URL，还可用来创建新资源</td>
<td>200或204</td>
</tr>
<tr>
<td>DELETE</td>
<td>单个资源的URL</td>
<td>删除一个资源</td>
<td>200或204</td>
</tr>
<tr>
<td>DELETE</td>
<td>资源集合的URL</td>
<td>删除目标集合中的所有资源</td>
<td>200或204</td>
</tr>
</tbody></table>
<h5 id="2-1-3-请求和响应主体"><a href="#2-1-3-请求和响应主体" class="headerlink" title="2.1.3 请求和响应主体"></a>2.1.3 请求和响应主体</h5><p>REST式Web服务常用的两种编码方式是Javascript对象表示方法（JSON，Javascript object notation）和可扩展标记语音（XML， extensible markup language）。</p>
<p>在设计良好的REST式API这，客户端只需要知道几个顶级资源的URL，其他资源的URL则从响应中包含的链接上发掘。</p>
<h5 id="2-1-4-版本"><a href="#2-1-4-版本" class="headerlink" title="2.1.4 版本"></a>2.1.4 版本</h5><p>在URL中加入Web服务的版本号有助于组织化管理新旧功能，让服务器能为新客户端提供新功能，同时继续支持旧版客户端。</p>
<p>提供多版本支持会增加服务器的维护负担，但在某些情况下，这是不破坏现有部署且能让应用不断发展的唯一方式。等到所有客户端都升级到新版之后，可以弃用旧版服务，待时机成熟后再把旧版完全删除。</p>
<h4 id="2-2-使用Flask实现REST式Web服务"><a href="#2-2-使用Flask实现REST式Web服务" class="headerlink" title="2.2 使用Flask实现REST式Web服务"></a>2.2 使用Flask实现REST式Web服务</h4><p>使用Flask创建REST式Web服务十分简单。使用少许细的route()装饰器及其methods可选参数可以声明服务器所提供资源URL的路由。处理JSON数据同样简单，请求中的JSON数据可以通过reques.get_json()转换成字典格式，而且可以使用Flask提供的辅助函数jsonify()，从Python字典中生成需要包含JSON的响应。</p>
<h5 id="2-2-1-创建API蓝本"><a href="#2-2-1-创建API蓝本" class="headerlink" title="2.2.1 创建API蓝本"></a>2.2.1 创建API蓝本</h5><p>REST式API相关的路由式应用中一个自成一体的子集。因此，为了更好的组织代码、最好把这些路由放到一个独立的蓝本中。比如：</p>
<ul>
<li><p>API蓝本结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|- flasky</span><br><span class="line">  |- app&#x2F;</span><br><span class="line">    |- api</span><br><span class="line">      |- __init__flB.py</span><br><span class="line">      |- users.py</span><br><span class="line">      |- posts.py</span><br><span class="line">      |- comments.py</span><br><span class="line">      |- errors.py</span><br><span class="line">      |- decorators.py</span><br></pre></td></tr></table></figure></li>
<li><p>API蓝本的构造文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Blueprint</span><br><span class="line">api = Blueprint(<span class="string">&#x27;api&#x27;</span>, __name__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> posts, users, comments, errors</span><br></pre></td></tr></table></figure></li>
<li><p>注册API蓝本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_app</span>(<span class="params">config_name</span>):</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">from</span> .api <span class="keyword">import</span> api <span class="keyword">as</span> api_blueprint</span><br><span class="line">    app.register_blueprint(api_blueprint, url_prefix=<span class="string">&#x27;/api/v1&#x27;</span>)</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<p>注册API蓝本时指定了一个URL前缀，因此蓝本中所有路由器的URL都以/api/v1开头。注册蓝本时设置前缀是好主意，无需在每个路由中硬编码版本号。</p>
</li>
</ul>
<h5 id="2-2-2-错误处理"><a href="#2-2-2-错误处理" class="headerlink" title="2.2.2 错误处理"></a>2.2.2 错误处理</h5><p>REST式Web服务讲请求的状态告知客户端时，会在响应中发送适当的HTTP状态码，并将额外信息放入响应主体。客户端从Web服务得到的常见状态码如下所示：</p>
<table>
<thead>
<tr>
<th>HTTP状态码</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td>OK</td>
<td>请求成功</td>
</tr>
<tr>
<td>201</td>
<td>Created</td>
<td>请求成功，而且创建一个新资源</td>
</tr>
<tr>
<td>202</td>
<td>Accepted</td>
<td>请求已接收，但仍在处理中，将异步处理</td>
</tr>
<tr>
<td>204</td>
<td>No Content</td>
<td>请求处理成功，但是返回的响应没有数据</td>
</tr>
<tr>
<td>400</td>
<td>Bad Request</td>
<td>请求无效或不一致</td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized</td>
<td>请求未包含身份验证信息，或者提供的凭证无效</td>
</tr>
<tr>
<td>403</td>
<td>Foridden</td>
<td>请求这发送的身份验证凭据无权访问目标</td>
</tr>
<tr>
<td>404</td>
<td>Not Found</td>
<td>URL对应的资源不存在</td>
</tr>
<tr>
<td>405</td>
<td>Method Not Allowed</td>
<td>指定资源不支持请求使用的方法</td>
</tr>
<tr>
<td>500</td>
<td>Internal Server Error</td>
<td>处理请求的过程这发生意外错误</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Python</category>
        <category>Web Programming</category>
      </categories>
      <tags>
        <tag>Web Programming、Python、Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Python下的ORM框架SQLAlchemy</title>
    <url>/python/orm_sqlalchemy/</url>
    <content><![CDATA[<h2 id="Python下的ORM框架SQLAlchemy"><a href="#Python下的ORM框架SQLAlchemy" class="headerlink" title="Python下的ORM框架SQLAlchemy"></a>Python下的ORM框架SQLAlchemy</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>如果写程序用sql和程序交互，那是不是要写原生sql语句。如果进行复杂的查询，那sql语句就要进行一点一点拼接，而且不太有重用性，扩展不方便。而且写的sql语句可能不高效，导致程序运行也变慢。<br>为了避免把sql语句写死在代码里，有没有一种方法直接把原生sql封装好了并且以你熟悉的方式操作，像面向对象那样？<br>　<br>orm（object relational mapping）,就是对象映射关系程序，简单来说我们类似python这种面向对象的程序来说一切皆对象，但是我们使用的数据库却都是关系型的，为了保证一致的使用习惯，通过orm将编程语言的对象模型和数据库的关系模型建立映射关系，这样我们在使用编程语言对数据库进行操作的时候可以直接使用编程语言的对象模型进行操作就可以了，而不用直接使用sql语言。</p>
<p>ORM 相当于把数据库也给你实例化了，在代码操作sql中级又加了orm这一层。</p>
<p><strong>orm的优点：</strong></p>
<a id="more"></a>
<p>隐藏了数据访问细节，“封闭”的通用数据库交互，ORM的核心。他使得我们的通用数据库交互变得简单易行，并且完全不用考虑该死的SQL语句。快速开发，由此而来。<br>ORM使我们构造固化数据结构变得简单易行。</p>
<p><strong>缺点：</strong></p>
<p>无可避免的，自动化意味着映射和关联管理，代价是牺牲性能（早期，这是所有不喜欢ORM人的共同点）。现在的各种ORM框架都在尝试使用各种方法来减轻这块（LazyLoad，Cache），效果还是很显著的。</p>
<h3 id="sqlalchemy安装"><a href="#sqlalchemy安装" class="headerlink" title="sqlalchemy安装"></a>sqlalchemy安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install SQLAlchemy</span><br></pre></td></tr></table></figure>
<h3 id="sqlalchemy的基本操作"><a href="#sqlalchemy的基本操作" class="headerlink" title="sqlalchemy的基本操作"></a>sqlalchemy的基本操作</h3><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line"></span><br><span class="line"><span class="comment"># Connecting</span></span><br><span class="line">engine = create_engine(<span class="string">&#x27;sqlite:///:memory:&#x27;</span>, echo=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h4 id="定义和创建表"><a href="#定义和创建表" class="headerlink" title="定义和创建表"></a>定义和创建表</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Table, Column, Integer, String, MetaData, ForeignKey</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define and Create Tables</span></span><br><span class="line">metadata = MetaData()</span><br><span class="line"></span><br><span class="line">users = Table(<span class="string">&#x27;users&#x27;</span>, metadata,</span><br><span class="line">             Column(<span class="string">&#x27;id&#x27;</span>, Integer, primary_key=<span class="literal">True</span>),</span><br><span class="line">             Column(<span class="string">&#x27;name&#x27;</span>, String),</span><br><span class="line">             Column(<span class="string">&#x27;fullname&#x27;</span>, String),</span><br><span class="line"> )</span><br><span class="line"></span><br><span class="line">addresses = Table(<span class="string">&#x27;addresses&#x27;</span>, metadata,</span><br><span class="line">                 Column(<span class="string">&#x27;id&#x27;</span>, Integer, primary_key=<span class="literal">True</span>),</span><br><span class="line">                 Column(<span class="string">&#x27;user_id&#x27;</span>, <span class="literal">None</span>, ForeignKey(<span class="string">&#x27;users.id&#x27;</span>)),</span><br><span class="line">                 Column(<span class="string">&#x27;email_address&#x27;</span>, String, nullable=<span class="literal">False</span>)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">metadata.create_all(engine)</span><br></pre></td></tr></table></figure>
<h4 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># user</span></span><br><span class="line"><span class="keyword">for</span> kv <span class="keyword">in</span> dict_rep:</span><br><span class="line">     <span class="built_in">setattr</span>(user, kv, dict_rep[kv])</span><br><span class="line">session.add(user)</span><br><span class="line">session.commit()</span><br><span class="line">session.close()</span><br></pre></td></tr></table></figure>
<h5 id="单行新增"><a href="#单行新增" class="headerlink" title="单行新增"></a>单行新增</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Insert Expressions</span></span><br><span class="line">ins = users.insert()</span><br><span class="line"><span class="built_in">str</span>(ins)</span><br><span class="line">ins = users.insert().values(name=<span class="string">&#x27;jack&#x27;</span>, fullname=<span class="string">&#x27;Jack Jones&#x27;</span>)</span><br><span class="line">ins.<span class="built_in">compile</span>().params</span><br></pre></td></tr></table></figure>
<h5 id="多行新增"><a href="#多行新增" class="headerlink" title="多行新增"></a>多行新增</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Executing</span></span><br><span class="line">conn = engine.connect()</span><br><span class="line">result = conn.execute(ins)</span><br><span class="line">ins.bind = engine</span><br><span class="line"><span class="built_in">str</span>(ins)</span><br><span class="line">result.inserted_primary_key</span><br><span class="line"></span><br><span class="line"><span class="comment"># Executing Multiple Statements</span></span><br><span class="line">ins = users.insert()</span><br><span class="line">conn.execute(ins, <span class="built_in">id</span>=<span class="number">2</span>, name=<span class="string">&#x27;wendy&#x27;</span>, fullname=<span class="string">&#x27;Wendy Williams&#x27;</span>)</span><br><span class="line"></span><br><span class="line">conn.execute(addresses.insert(), [</span><br><span class="line">       &#123;<span class="string">&#x27;user_id&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;email_address&#x27;</span> : <span class="string">&#x27;jack@yahoo.com&#x27;</span>&#125;,</span><br><span class="line">       &#123;<span class="string">&#x27;user_id&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;email_address&#x27;</span> : <span class="string">&#x27;jack@msn.com&#x27;</span>&#125;,</span><br><span class="line">       &#123;<span class="string">&#x27;user_id&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;email_address&#x27;</span> : <span class="string">&#x27;www@www.org&#x27;</span>&#125;,</span><br><span class="line">       &#123;<span class="string">&#x27;user_id&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;email_address&#x27;</span> : <span class="string">&#x27;wendy@aol.com&#x27;</span>&#125;,</span><br><span class="line">    ])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dict_rep 待修改参数</span></span><br><span class="line">user = session.query(user).filter_by(<span class="built_in">id</span>=<span class="built_in">int</span>(pk)).first()</span><br><span class="line"><span class="keyword">for</span> kv <span class="keyword">in</span> dict_rep:</span><br><span class="line">     <span class="built_in">setattr</span>(user, kv, dict_rep[kv])</span><br><span class="line">session.add(user)</span><br><span class="line">session.commit()</span><br><span class="line">session.close()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">table = sqlalchemy.Table(<span class="string">&#x27;stuff&#x27;</span>, md, autoload=<span class="literal">True</span>)</span><br><span class="line">upd = table.update(values=&#123;table.c.foo:table.c.foo+<span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">session.execute(update(stuff_table, values=&#123;stuff_table.c.foo: stuff_table.c.foo + <span class="number">1</span>&#125;))</span><br><span class="line">session.commit()</span><br><span class="line"></span><br><span class="line">session.query(Stuff).update(&#123;Stuff.foo: Stuff.foo + <span class="number">1</span>&#125;)</span><br><span class="line">session.commit()</span><br><span class="line">session.close()</span><br></pre></td></tr></table></figure>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">o = session.query(user).filter_by(<span class="built_in">id</span>=<span class="built_in">id</span>).first()</span><br><span class="line">session.delete(o)</span><br><span class="line">session.commit()</span><br><span class="line">session.close()</span><br></pre></td></tr></table></figure>
<h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">curdatabase = session.query(users).filter_by(name=<span class="string">&#x27;test&#x27;</span>).first()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy.sql <span class="keyword">import</span> select</span><br><span class="line">s = select([users])</span><br><span class="line">result = conn.execute(s)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> result:</span><br><span class="line">    print(row)</span><br><span class="line"></span><br><span class="line">result = conn.execute(s)</span><br><span class="line">row = result.fetchone()</span><br><span class="line">print(<span class="string">&quot;name:&quot;</span>, row[<span class="string">&#x27;name&#x27;</span>], <span class="string">&quot;; fullname:&quot;</span>, row[<span class="string">&#x27;fullname&#x27;</span>])</span><br><span class="line"></span><br><span class="line">ow = result.fetchone()</span><br><span class="line">print(<span class="string">&quot;name:&quot;</span>, row[<span class="number">1</span>], <span class="string">&quot;; fullname:&quot;</span>, row[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> conn.execute(s):</span><br><span class="line">        print(<span class="string">&quot;name:&quot;</span>, row[users.c.name], <span class="string">&quot;; fullname:&quot;</span>, row[users.c.fullname])</span><br><span class="line"></span><br><span class="line">result.close()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
        <category>Web Programming</category>
      </categories>
      <tags>
        <tag>Web Programming、Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask-restful在flask下的使用</title>
    <url>/python/flask_restful_use/</url>
    <content><![CDATA[<h2 id="Flask-restful在flask下的使用"><a href="#Flask-restful在flask下的使用" class="headerlink" title="Flask-restful在flask下的使用"></a>Flask-restful在flask下的使用</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol>
<li>通过pip安装</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install flask-restful</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>通过源码安装</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;javyxu&#x2F;flask-restful.git</span><br><span class="line">cd flask-restful</span><br><span class="line">python setup.py develop</span><br></pre></td></tr></table></figure>
<h3 id="简单的使用"><a href="#简单的使用" class="headerlink" title="简单的使用"></a>简单的使用</h3><ol>
<li>一个简单的使用</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask_restful <span class="keyword">import</span> Resource, Api</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">api = Api(app)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span>(<span class="params">Resource</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&#x27;Hello, World!&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">api.add_resource(HelloWorld, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># pylint: disable=C,R,W</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, jsonify, Response, request</span><br><span class="line"><span class="keyword">from</span> flask_restful <span class="keyword">import</span> reqparse, Resource, Api</span><br><span class="line"><span class="keyword">from</span> flask_cors <span class="keyword">import</span> CORS</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> simplejson <span class="keyword">as</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实现跨域操作</span></span><br><span class="line">CORS(app, supports_credentials=<span class="literal">True</span>)</span><br><span class="line">CORS(app, resources=<span class="string">r&#x27;/api&#x27;</span>)</span><br><span class="line">api = Api(app)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取参数</span></span><br><span class="line">parser = reqparse.RequestParser()   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">json_result</span>(<span class="params">code=<span class="number">0</span>, data=<span class="literal">None</span>, msg=<span class="string">&#x27;success&#x27;</span></span>):</span></span><br><span class="line">    <span class="comment"># res = Response(json_msg, status=status, mimetype=&#x27;application/json&#x27;)</span></span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">&quot;code&quot;</span>:code, <span class="string">&quot;data&quot;</span>: data, <span class="string">&quot;msg&quot;</span>:msg&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 实现Get</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestGet</span>(<span class="params">Resource</span>):</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;name&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;age&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            args = parser.parse_args()</span><br><span class="line">            name = args[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">            age = args[<span class="string">&#x27;age&#x27;</span>]</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            logging.exception(e)</span><br><span class="line">            <span class="comment"># return json_error_response(e)</span></span><br><span class="line">            <span class="keyword">return</span> json_result(code=<span class="number">500</span>, msg=<span class="built_in">str</span>(e))</span><br><span class="line">        <span class="keyword">return</span> json_result(data=&#123;<span class="string">&quot;get_reslut&quot;</span>: json.dumps(&#123;<span class="string">&#x27;name&#x27;</span>: name, <span class="string">&#x27;age&#x27;</span> : age&#125;)&#125;)</span><br><span class="line"></span><br><span class="line">api.add_resource(TestGet, <span class="string">&#x27;/api/v1/testget&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 实现Post和options</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestPost</span>(<span class="params">Resource</span>):</span></span><br><span class="line">    <span class="comment">## 实现跨域必须执行options</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">options</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> json_result()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 如果参数较长，或者较多时，从json直接传入</span></span><br><span class="line">            dict_rep = <span class="built_in">dict</span>(request.json)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            logging.exception(e)</span><br><span class="line">            <span class="comment"># json_error_response(e)</span></span><br><span class="line">            <span class="keyword">return</span> json_result(code=<span class="number">500</span>, msg=<span class="built_in">str</span>(e))</span><br><span class="line">        <span class="keyword">return</span> json_result(data=&#123;<span class="string">&quot;post_reslut&quot;</span>: json.dumps(dict_rep)&#125;)</span><br><span class="line"></span><br><span class="line">api.add_resource(TestPost, <span class="string">&#x27;/api/v1/testpost&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 实现delete</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestDelete</span>(<span class="params">Resource</span>):</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            args = parser.parse_args()</span><br><span class="line">            <span class="built_in">id</span> = args[<span class="string">&#x27;id&#x27;</span>]</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            logging.exception(e)</span><br><span class="line">            <span class="comment"># return json_error_response(e)</span></span><br><span class="line">            <span class="keyword">return</span> json_result(code=<span class="number">500</span>, msg=<span class="built_in">str</span>(e))</span><br><span class="line">        <span class="keyword">return</span> json_result(data=&#123;<span class="string">&quot;delete_reslut&quot;</span>: json.dumps(&#123;<span class="string">&#x27;id&#x27;</span> : <span class="built_in">id</span>&#125;)&#125;)</span><br><span class="line"></span><br><span class="line">api.add_resource(TestDelete, <span class="string">&#x27;/api/v1/testsdelete&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
        <category>Web Programming</category>
      </categories>
      <tags>
        <tag>Web Programming、Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>通过Python库elasticsearch_dsl处理elasticsearch</title>
    <url>/python/es4python/</url>
    <content><![CDATA[<h2 id="了解elasticsearch-dsl"><a href="#了解elasticsearch-dsl" class="headerlink" title="了解elasticsearch_dsl"></a>了解elasticsearch_dsl</h2><h3 id="ElasticSearch与数据库的对应关系"><a href="#ElasticSearch与数据库的对应关系" class="headerlink" title="ElasticSearch与数据库的对应关系"></a>ElasticSearch与数据库的对应关系</h3><table>
<thead>
<tr>
<th>ES</th>
<th>RDBS</th>
</tr>
</thead>
<tbody><tr>
<td>index</td>
<td>database</td>
</tr>
<tr>
<td>type</td>
<td>table</td>
</tr>
<tr>
<td>filed</td>
<td>column</td>
</tr>
</tbody></table>
<h3 id="通过Python库elasticsearch-dsl处理ES"><a href="#通过Python库elasticsearch-dsl处理ES" class="headerlink" title="通过Python库elasticsearch_dsl处理ES"></a>通过Python库elasticsearch_dsl处理ES</h3><h4 id="添加连接"><a href="#添加连接" class="headerlink" title="添加连接"></a>添加连接</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> elasticsearch_dsl <span class="keyword">import</span> connections</span><br><span class="line">connections.create_connection(hosts=[<span class="string">&#x27;10.0.4.122:9200&#x27;</span>], timeout=<span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<h4 id="获取index-database"><a href="#获取index-database" class="headerlink" title="获取index(database)"></a>获取index(database)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> elasticsearch <span class="keyword">import</span> Elasticsearch</span><br><span class="line"><span class="keyword">from</span> elasticsearch_dsl <span class="keyword">import</span> Search</span><br><span class="line"></span><br><span class="line">client = Elasticsearch(<span class="string">&#x27;10.0.4.122:9200&#x27;</span>)</span><br><span class="line"></span><br><span class="line">indexs = client.indices.get(<span class="string">&#x27;*&#x27;</span>) <span class="comment"># 获取所有的index</span></span><br><span class="line"></span><br><span class="line">indexnames = indexs.keys()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="获取type-table"><a href="#获取type-table" class="headerlink" title="获取type(table)"></a>获取type(table)</h4><a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">index = indexnames[<span class="number">0</span>]</span><br><span class="line">tables = indexs[index][<span class="string">&#x27;mappings&#x27;</span>].keys</span><br></pre></td></tr></table></figure>
<h4 id="获取所有的字段-columns"><a href="#获取所有的字段-columns" class="headerlink" title="获取所有的字段(columns)"></a>获取所有的字段(columns)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">table = tables[<span class="number">0</span>]</span><br><span class="line">colunms = inidexs[table][<span class="string">&#x27;properties&#x27;</span>].keys()</span><br></pre></td></tr></table></figure>
<h4 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> elasticsearch <span class="keyword">import</span> Elasticsearch</span><br><span class="line"><span class="keyword">from</span> elasticsearch_dsl <span class="keyword">import</span> Search</span><br><span class="line"></span><br><span class="line">client = Elasticsearch(<span class="string">&#x27;10.0.4.122:9200&#x27;</span>)</span><br><span class="line">s = Search().using(client).query(<span class="string">&quot;match&quot;</span>, account_number=<span class="number">5</span>)</span><br><span class="line">response = s.execute()</span><br><span class="line"></span><br><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> response.hits:</span><br><span class="line">    <span class="comment"># print row.to_dict()</span></span><br><span class="line">    result.append(row.to_dict())</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>BigData</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python、elasticsearch_dsl、elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell编程</title>
    <url>/linux/shell_program/</url>
    <content><![CDATA[<h1 id="Shell编程"><a href="#Shell编程" class="headerlink" title="Shell编程"></a>Shell编程</h1><h2 id="shell脚本编程"><a href="#shell脚本编程" class="headerlink" title="shell脚本编程"></a>shell脚本编程</h2><h3 id="构建基本脚本"><a href="#构建基本脚本" class="headerlink" title="构建基本脚本"></a>构建基本脚本</h3><h4 id="注释格式"><a href="#注释格式" class="headerlink" title="注释格式"></a>注释格式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line"></span><br><span class="line"># FILENAME: test_shell</span><br><span class="line"># AUTHOR:   Javy</span><br><span class="line"># Email:    xujavy@gmail.com</span><br><span class="line"># PURPOSE:  Demonstration of comment style</span><br><span class="line"># HISTORY:  1 May, 2018    Created</span><br><span class="line">#           5 May, 2018    Modified to show mods</span><br></pre></td></tr></table></figure>
<h4 id="显示消息"><a href="#显示消息" class="headerlink" title="显示消息"></a>显示消息</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo This is a test</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ul>
<li>-n：输出在同一行</li>
</ul>
<h4 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h4><h5 id="1-环境变量"><a href="#1-环境变量" class="headerlink" title="1. 环境变量"></a>1. 环境变量</h5><ul>
<li>set 显示所有的当前环境变量列表</li>
</ul>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> display user information from the system.</span></span><br><span class="line">echo &quot;User info for userid: $USER&quot;</span><br><span class="line">echo UID: $UID</span><br><span class="line">echo HOME: $HOME</span><br></pre></td></tr></table></figure>
<h5 id="2-用户变量"><a href="#2-用户变量" class="headerlink" title="2. 用户变量"></a>2. 用户变量</h5><a id="more"></a>
<h5 id="3-命令替换"><a href="#3-命令替换" class="headerlink" title="3. 命令替换"></a>3. 命令替换</h5><ul>
<li><p>反引号字符（ `）</p>
</li>
<li><p>$()格式</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!bin/bash</span></span><br><span class="line">testing=$(date)</span><br></pre></td></tr></table></figure>
<h4 id="重定向输入和输出"><a href="#重定向输入和输出" class="headerlink" title="重定向输入和输出"></a>重定向输入和输出</h4><h5 id="1-输出重定向"><a href="#1-输出重定向" class="headerlink" title="1. 输出重定向"></a>1. 输出重定向</h5><p><code>command &gt; outputfile</code></p>
<h5 id="2-输入重定向"><a href="#2-输入重定向" class="headerlink" title="2. 输入重定向"></a>2. 输入重定向</h5><p><code>command &lt; outputfile</code></p>
<h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><h4 id="执行数学运算"><a href="#执行数学运算" class="headerlink" title="执行数学运算"></a>执行数学运算</h4><h5 id="1-expr命令"><a href="#1-expr命令" class="headerlink" title="1. expr命令"></a>1. expr命令</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">expr 1 + 5</span><br></pre></td></tr></table></figure>
<h5 id="2-使用方括号"><a href="#2-使用方括号" class="headerlink" title="2. 使用方括号"></a>2. 使用方括号</h5><p><code>$[ operation ]</code></p>
<h5 id="3-浮点解决方案"><a href="#3-浮点解决方案" class="headerlink" title="3. 浮点解决方案"></a>3. 浮点解决方案</h5><ul>
<li>bc的基本用法</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bc -q</span><br><span class="line"></span><br><span class="line">quit</span><br></pre></td></tr></table></figure>
<h5 id="2-在脚本中使用bc"><a href="#2-在脚本中使用bc" class="headerlink" title="2. 在脚本中使用bc"></a>2. 在脚本中使用bc</h5><p><code>variable=$(echo &quot;options; expression&quot; | bc)</code></p>
<p><strong>说明：</strong></p>
<p>options：设置变量，允许多个变量可以用分号隔开。</p>
<p>expression：定义bc执行的数学表达式。</p>
<p><code>variable=$(bc &lt;&lt; EOF   options   statements   expression   EOF   )</code></p>
<h4 id="退出脚本"><a href="#退出脚本" class="headerlink" title="退出脚本"></a>退出脚本</h4><h5 id="1-查看退出状态码"><a href="#1-查看退出状态码" class="headerlink" title="1. 查看退出状态码"></a>1. 查看退出状态码</h5><p><code>$?</code>可查看退出状态</p>
<p><strong>说明：</strong></p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>命令成功结束</td>
</tr>
<tr>
<td>1</td>
<td>一般性未知错误</td>
</tr>
<tr>
<td>2</td>
<td>不适合的shell执行命令</td>
</tr>
<tr>
<td>126</td>
<td>命令不可执行</td>
</tr>
<tr>
<td>127</td>
<td>没找到命令</td>
</tr>
<tr>
<td>128</td>
<td>无效的退出参数</td>
</tr>
<tr>
<td>128+x</td>
<td>与Linux信息x相关的严重错误</td>
</tr>
<tr>
<td>130</td>
<td>通过Ctrl+C终止的命令</td>
</tr>
<tr>
<td>255</td>
<td>正常范围之外的退出状态码</td>
</tr>
</tbody></table>
<h5 id="2-exit命令"><a href="#2-exit命令" class="headerlink" title="2. exit命令"></a>2. exit命令</h5><p>可以指定退出码<code>exit num</code>,num表示0～255之间的数，如果大于将以取模的形式返回。  </p>
<h3 id="使用结构化命令"><a href="#使用结构化命令" class="headerlink" title="使用结构化命令"></a>使用结构化命令</h3><h4 id="使用if-then语句"><a href="#使用if-then语句" class="headerlink" title="使用if-then语句"></a>使用if-then语句</h4><p><strong>格式：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if command then</span><br><span class="line">    commands</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<p>if后面的command是一个命令，如果命令退出代码是0，then部分就会被允许，如果是其他码then部分不会被执行。</p>
<h4 id="使用if-then-else语句"><a href="#使用if-then-else语句" class="headerlink" title="使用if-then-else语句"></a>使用if-then-else语句</h4><p><strong>格式：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if command then</span><br><span class="line">  commands</span><br><span class="line">else</span><br><span class="line">  commands</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h4 id="嵌套if"><a href="#嵌套if" class="headerlink" title="嵌套if"></a>嵌套if</h4><h4 id="test命令"><a href="#test命令" class="headerlink" title="test命令"></a>test命令</h4><p><code>test condition</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if test condition then</span><br><span class="line">  commands</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>也可以写为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ condition ] then</span><br><span class="line">  commands</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>test命令可以判断的三类条件：</p>
<ul>
<li><p>数值比较</p>
</li>
<li><p>字符串比较</p>
</li>
<li><p>文件比较</p>
</li>
</ul>
<h5 id="1-数值比较"><a href="#1-数值比较" class="headerlink" title="1. 数值比较"></a>1. 数值比较</h5><table>
<thead>
<tr>
<th>比较</th>
<th>描述</th>
<th>比较命令说明</th>
</tr>
</thead>
<tbody><tr>
<td>n1 -eq n2</td>
<td>n1是否与n2相等</td>
<td>-equal</td>
</tr>
<tr>
<td>n1 -ge n2</td>
<td>n1是否大于或等于n2</td>
<td>-(greater and equal)</td>
</tr>
<tr>
<td>n1 -gt n2</td>
<td>n1是否大于n2</td>
<td>-(greater than)</td>
</tr>
<tr>
<td>n1 -le n2</td>
<td>n1是否小于或等于n2</td>
<td>-(less and equal)</td>
</tr>
<tr>
<td>n1 -lt n2</td>
<td>n1是否小于n2</td>
<td>-(less than)</td>
</tr>
<tr>
<td>n1 -ne n2</td>
<td>n1是否不等于n2</td>
<td>-(not equal)</td>
</tr>
</tbody></table>
<h5 id="2-字符串比较"><a href="#2-字符串比较" class="headerlink" title="2. 字符串比较"></a>2. 字符串比较</h5><table>
<thead>
<tr>
<th>比较</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>str1 = str2</td>
<td>str1是否与str2相同</td>
</tr>
<tr>
<td>str1 != str2</td>
<td>str1是否与str2不同</td>
</tr>
<tr>
<td>str1 &lt; str2</td>
<td>str1是否比str2小</td>
</tr>
<tr>
<td>str1 &gt; str2</td>
<td>str1是否比str2大</td>
</tr>
<tr>
<td>-n str1</td>
<td>str1的长度是否非0</td>
</tr>
<tr>
<td>-z str1</td>
<td>str1的长度是否为0</td>
</tr>
</tbody></table>
<p><strong>注：</strong> 在使用<code>&lt;</code>和<code>&gt;</code>是需要进行转义，就想这样<code>\&lt;</code>和<code>\&gt;</code>。</p>
<h5 id="3-文件比较"><a href="#3-文件比较" class="headerlink" title="3. 文件比较"></a>3. 文件比较</h5><table>
<thead>
<tr>
<th>比较</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-d file</td>
<td>file是否存在并是一个目录</td>
</tr>
<tr>
<td>-e file</td>
<td>file是否存在</td>
</tr>
<tr>
<td>-f file</td>
<td>file是否存在并是一个文件</td>
</tr>
<tr>
<td>-r file</td>
<td>file是否存在并可读</td>
</tr>
<tr>
<td>-s file</td>
<td>file是否存在并非空</td>
</tr>
<tr>
<td>-w file</td>
<td>file是否存在并可写</td>
</tr>
<tr>
<td>-x file</td>
<td>file是否存在并可执行</td>
</tr>
<tr>
<td>-o file</td>
<td>file是否存在并属当前用户所有</td>
</tr>
<tr>
<td>-G file</td>
<td>file是否存在并默认与当前用户相同</td>
</tr>
<tr>
<td>file1 -nt file2</td>
<td>file1是否比file2新</td>
</tr>
<tr>
<td>file1 -ot file2</td>
<td>file1是否比file2旧</td>
</tr>
</tbody></table>
<h4 id="复合条件测试"><a href="#复合条件测试" class="headerlink" title="复合条件测试"></a>复合条件测试</h4><ul>
<li><p>[ condition1 ] &amp;&amp; [ condition2 ]</p>
</li>
<li><p>[ condition1 ] || [ condition2 ]</p>
</li>
</ul>
<h4 id="if-then的高级特性"><a href="#if-then的高级特性" class="headerlink" title="if-then的高级特性"></a>if-then的高级特性</h4><ul>
<li><p>用于数学表达式的双括号</p>
</li>
<li><p>用于高级字符串处理功能的双方括号</p>
</li>
</ul>
<h5 id="1-使用双括号"><a href="#1-使用双括号" class="headerlink" title="1. 使用双括号"></a>1. 使用双括号</h5><p><strong>格式：</strong></p>
<p><code>(( expression ))</code></p>
<p>表达式参数符号说明：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>val++</td>
<td>后增</td>
</tr>
<tr>
<td>val–</td>
<td>后减</td>
</tr>
<tr>
<td>++val</td>
<td>先增</td>
</tr>
<tr>
<td>–val</td>
<td>先减</td>
</tr>
<tr>
<td>!</td>
<td>逻辑求反</td>
</tr>
<tr>
<td>~</td>
<td>位求反</td>
</tr>
<tr>
<td>**</td>
<td>幂运算</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左位移</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右位移</td>
</tr>
<tr>
<td>&amp;</td>
<td>位布尔和</td>
</tr>
<tr>
<td>&amp;#124</td>
<td>位布尔或</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>逻辑和</td>
</tr>
<tr>
<td>&amp;#124&amp;#124</td>
<td>逻辑或</td>
</tr>
</tbody></table>
<h5 id="2-使用双方括号"><a href="#2-使用双方括号" class="headerlink" title="2. 使用双方括号"></a>2. 使用双方括号</h5><p><code>[[ expression ]]</code></p>
<h4 id="case命令"><a href="#case命令" class="headerlink" title="case命令"></a>case命令</h4><p><strong>格式：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">case variable in</span><br><span class="line">  pattern1 | pattern2) commands1;;</span><br><span class="line">  pattern3) commands2;;</span><br><span class="line">  *) default commands;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>
<h3 id="更多的结构化命令"><a href="#更多的结构化命令" class="headerlink" title="更多的结构化命令"></a>更多的结构化命令</h3><h4 id="for命令"><a href="#for命令" class="headerlink" title="for命令"></a>for命令</h4><p><strong>格式：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for var in list</span><br><span class="line">do</span><br><span class="line">  commands</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h4 id="C语言风格的for命令"><a href="#C语言风格的for命令" class="headerlink" title="C语言风格的for命令"></a>C语言风格的for命令</h4><p><strong>格式：</strong></p>
<p><code>for (( variable assignment ; condition ; iteration process ))</code></p>
<p><strong>使用多个变量：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for (( a=1， b=10; a &lt;= 10; a++, b-- )); do</span><br><span class="line"><span class="meta">  #</span><span class="bash">statements</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h4 id="while命令"><a href="#while命令" class="headerlink" title="while命令"></a>while命令</h4><p><strong>格式：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while [ command ]</span><br><span class="line">do</span><br><span class="line">  other commands</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h4 id="until命令"><a href="#until命令" class="headerlink" title="until命令"></a>until命令</h4><p><strong>格式：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">until [ command ]</span><br><span class="line">do</span><br><span class="line">  other commands</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h4 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h4><h4 id="循环处理文件数据"><a href="#循环处理文件数据" class="headerlink" title="循环处理文件数据"></a>循环处理文件数据</h4><h4 id="控制循环"><a href="#控制循环" class="headerlink" title="控制循环"></a>控制循环</h4><h5 id="1-break命令"><a href="#1-break命令" class="headerlink" title="1. break命令"></a>1. break命令</h5><p>跳出外部循环：break n （默认n=1）</p>
<h5 id="2-continue命令"><a href="#2-continue命令" class="headerlink" title="2. continue命令"></a>2. continue命令</h5><h4 id="处理循环的输出"><a href="#处理循环的输出" class="headerlink" title="处理循环的输出"></a>处理循环的输出</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for (( i = 0; i &lt; 10; i++ )); do</span><br><span class="line"><span class="meta">  #</span><span class="bash">statements</span></span><br><span class="line">done &gt; outputfile.txt</span><br></pre></td></tr></table></figure>
<p>最后的结果使用定向输出：<code>&gt;</code></p>
<h3 id="处理用户输入"><a href="#处理用户输入" class="headerlink" title="处理用户输入"></a>处理用户输入</h3><h4 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h4><h5 id="1-读取参数"><a href="#1-读取参数" class="headerlink" title="1. 读取参数"></a>1. 读取参数</h5><p>位置参数变量是标准的数字：$0是程序名，$1是第一个参数，$2是第二个参数，依次类推直到第九个参数$9。</p>
<h5 id="2-抓取所有的数据"><a href="#2-抓取所有的数据" class="headerlink" title="2. 抓取所有的数据"></a>2. 抓取所有的数据</h5><p><code>$*</code>和<code>$@</code>可以抓取命令行上的所有参数。但是<code>$*</code>是当作一个参数执行，而<code>$@</code>是对每个参数进行处理</p>
<h5 id="3-移动变量"><a href="#3-移动变量" class="headerlink" title="3. 移动变量"></a>3. 移动变量</h5><p><code>shift 2</code>：移动两个位置</p>
<h5 id="4-处理选项"><a href="#4-处理选项" class="headerlink" title="4. 处理选项"></a>4. 处理选项</h5><p>分离参数和选项（<code>--</code>）</p>
<p>使用<code>getopt</code>命令：getopt optstring parameters，在脚本中使用格式:set – $(getopt -q ab:cd “$@”)</p>
<p>使用更高级的<code>getopts</code>：getopt optstring variable</p>
<h5 id="4-获得用户输入"><a href="#4-获得用户输入" class="headerlink" title="4. 获得用户输入"></a>4. 获得用户输入</h5><p><strong>read</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo -n &quot;Enter your name: &quot;</span><br><span class="line">read name</span><br><span class="line">echo &quot;Hello $name, welcome to my program. &quot;</span><br></pre></td></tr></table></figure>
<p><strong>read -p</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">read -p &quot;Enter your age: &quot; age</span><br><span class="line">days=$[ $age * 365 ]</span><br><span class="line">echo &quot;That makes you over $days days old! &quot;</span><br></pre></td></tr></table></figure>
<h5 id="2-超时"><a href="#2-超时" class="headerlink" title="2. 超时"></a>2. 超时</h5><p><strong>read -t</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if read -t 5 -p &quot;Please Enter your name: &quot; name</span><br><span class="line">then</span><br><span class="line">  echo &quot;Hello $name, welcome to my program. &quot;</span><br><span class="line">else</span><br><span class="line">  echo</span><br><span class="line">  echo &quot;Sorry， too slow！&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p><strong>read -n1</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">read -n1 -p &quot;Do you want to continue [Y/N]?: &quot; answer</span><br><span class="line">case $answer in</span><br><span class="line">Y | y) echo</span><br><span class="line">       echo &quot;fine, continue on...&quot;;;</span><br><span class="line">N | n) echo</span><br><span class="line">       echo &quot;Ok, goodbye&quot;</span><br><span class="line">       exit;;</span><br><span class="line">esac</span><br><span class="line">echo &quot;This is the end of the script&quot;</span><br></pre></td></tr></table></figure>
<h5 id="3-隐藏方式读取"><a href="#3-隐藏方式读取" class="headerlink" title="3. 隐藏方式读取"></a>3. 隐藏方式读取</h5><p><strong>read -s</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">read -s &quot;Enter your password: &quot; pass</span><br><span class="line">echo</span><br><span class="line">echo &quot;Is your password really $pass? &quot;</span><br></pre></td></tr></table></figure>
<h5 id="4-从文件中读取"><a href="#4-从文件中读取" class="headerlink" title="4. 从文件中读取"></a>4. 从文件中读取</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Count=1</span><br><span class="line">cat test | while read line</span><br><span class="line">do</span><br><span class="line">  echo &quot;Line $Count: $Line&quot;</span><br><span class="line">  Count=$[ $Count + 1 ]</span><br><span class="line">done</span><br><span class="line">echo &quot;Finished processing the file&quot;</span><br></pre></td></tr></table></figure>
<h3 id="呈现数据"><a href="#呈现数据" class="headerlink" title="呈现数据"></a>呈现数据</h3><h4 id="理解输入和输出"><a href="#理解输入和输出" class="headerlink" title="理解输入和输出"></a>理解输入和输出</h4><h5 id="1-标准文件描述符"><a href="#1-标准文件描述符" class="headerlink" title="1. 标准文件描述符"></a>1. 标准文件描述符</h5><table>
<thead>
<tr>
<th>文件描述符</th>
<th>缩写</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>STDIN</td>
<td>标准输入</td>
</tr>
<tr>
<td>1</td>
<td>STDOUT</td>
<td>标准输出</td>
</tr>
<tr>
<td>2</td>
<td>STDERR</td>
<td>标准错误</td>
</tr>
</tbody></table>
<h5 id="2-重定向错误"><a href="#2-重定向错误" class="headerlink" title="2. 重定向错误"></a>2. 重定向错误</h5><p>ls -al test 2&gt; test1 1&gt; test2</p>
<p>ls -al test &amp;&gt;test1</p>
<h4 id="在脚本中重定向输出"><a href="#在脚本中重定向输出" class="headerlink" title="在脚本中重定向输出"></a>在脚本中重定向输出</h4><h5 id="1-临时重定向"><a href="#1-临时重定向" class="headerlink" title="1. 临时重定向"></a>1. 临时重定向</h5><h5 id="2-永久重定向"><a href="#2-永久重定向" class="headerlink" title="2. 永久重定向"></a>2. 永久重定向</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exec 1&gt;testout</span><br><span class="line"></span><br><span class="line">echo &quot;....&quot;</span><br><span class="line">echo &quot;.......&quot;</span><br></pre></td></tr></table></figure>
<h4 id="在脚本中重定向输入"><a href="#在脚本中重定向输入" class="headerlink" title="在脚本中重定向输入"></a>在脚本中重定向输入</h4><p>exec 0&lt; testfile</p>
<h4 id="创建自己的重定向"><a href="#创建自己的重定向" class="headerlink" title="创建自己的重定向"></a>创建自己的重定向</h4><h5 id="1-关闭文件描述符"><a href="#1-关闭文件描述符" class="headerlink" title="1. 关闭文件描述符"></a>1. 关闭文件描述符</h5><p>exec 3&gt;&amp;-</p>
<h4 id="列出打的开文件描述符"><a href="#列出打的开文件描述符" class="headerlink" title="列出打的开文件描述符"></a>列出打的开文件描述符</h4><p>lsof</p>
<h4 id="记录消息"><a href="#记录消息" class="headerlink" title="记录消息"></a>记录消息</h4><p>tee filename 默认会覆盖</p>
<p>tee -a filename 实现追加</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">read</span> file and create INSERT statements <span class="keyword">for</span> MySQL</span></span><br><span class="line"></span><br><span class="line">outputfile=&#x27;member.sql&#x27;</span><br><span class="line">IFS=&#x27;,&#x27;</span><br><span class="line">while read lname fname address city state zip  </span><br><span class="line">do</span><br><span class="line">  cat \&gt;&gt; $outputfile \&lt;&lt; EOF</span><br><span class="line">  INSEART INTO members (lname, fname, address, city, state, zip) VALUES (&#x27;$lname&#x27;, &#x27;$fname&#x27;, &#x27;$address&#x27;, &#x27;$city&#x27;, &#x27;$state&#x27;, &#x27;$zip&#x27;);</span><br><span class="line">  EOF</span><br><span class="line">done &lt; S&#123;1&#125;</span><br></pre></td></tr></table></figure>
<h3 id="控制脚本"><a href="#控制脚本" class="headerlink" title="控制脚本"></a>控制脚本</h3><h4 id="处理信号"><a href="#处理信号" class="headerlink" title="处理信号"></a>处理信号</h4><h5 id="1-重温Linux信号"><a href="#1-重温Linux信号" class="headerlink" title="1. 重温Linux信号"></a>1. 重温Linux信号</h5><table>
<thead>
<tr>
<th>信号</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIGHUP</td>
<td>挂起进程</td>
</tr>
<tr>
<td>2</td>
<td>SIGINT</td>
<td>终止进程</td>
</tr>
<tr>
<td>3</td>
<td>SIGQUIT</td>
<td>停止进程</td>
</tr>
<tr>
<td>9</td>
<td>SIGKILL</td>
<td>无条件终止进程</td>
</tr>
<tr>
<td>15</td>
<td>SIGTRERM</td>
<td>尽可能终止进程</td>
</tr>
<tr>
<td>17</td>
<td>SIGSTOP</td>
<td>无条件停止进程但不是终止进程</td>
</tr>
<tr>
<td>18</td>
<td>SIGTSTP</td>
<td>停止或暂停进程，但不终止进程</td>
</tr>
<tr>
<td>19</td>
<td>SIGCONT</td>
<td>继续运行停止的进程</td>
</tr>
</tbody></table>
<h5 id="2-生成信号"><a href="#2-生成信号" class="headerlink" title="2. 生成信号"></a>2. 生成信号</h5><ul>
<li>中断进程</li>
</ul>
<p>Ctrl + C</p>
<ul>
<li>暂停进程</li>
</ul>
<p>Ctrl + Z</p>
<h5 id="3-捕获信号"><a href="#3-捕获信号" class="headerlink" title="3. 捕获信号"></a>3. 捕获信号</h5><p><strong>格式：</strong></p>
<p>tarp commands signals</p>
<h5 id="4-捕获脚本退出"><a href="#4-捕获脚本退出" class="headerlink" title="4. 捕获脚本退出"></a>4. 捕获脚本退出</h5><p>tarp commands signals EXIT</p>
<h5 id="5-修改或移除捕获"><a href="#5-修改或移除捕获" class="headerlink" title="5. 修改或移除捕获"></a>5. 修改或移除捕获</h5><h4 id="以后台模式运行脚本"><a href="#以后台模式运行脚本" class="headerlink" title="以后台模式运行脚本"></a>以后台模式运行脚本</h4><h5 id="1-以后台运行脚本"><a href="#1-以后台运行脚本" class="headerlink" title="1. 以后台运行脚本"></a>1. 以后台运行脚本</h5><p>./test.sh &amp;</p>
<h5 id="2-运行多个后台作业"><a href="#2-运行多个后台作业" class="headerlink" title="2. 运行多个后台作业"></a>2. 运行多个后台作业</h5><h4 id="在非控制台下运行脚本"><a href="#在非控制台下运行脚本" class="headerlink" title="在非控制台下运行脚本"></a>在非控制台下运行脚本</h4><p><strong>格式：</strong></p>
<p>nohup ./test.sh &amp;</p>
<h4 id="作业控制"><a href="#作业控制" class="headerlink" title="作业控制"></a>作业控制</h4><h5 id="1-查看作业"><a href="#1-查看作业" class="headerlink" title="1. 查看作业"></a>1. 查看作业</h5><p>jobs</p>
<p><strong>参数说明：</strong><br>| 参数 | 描述 |<br>| — | —- |<br>| -l | 列出进程的PID以及作业号 |<br>| -n | 只列出上次shell发出的通知后改变了状态的作业 |<br>| -p | 只列出作业的PID |<br>| -r | 只列出运行中的作业 |<br>| -s | 只列出已停止的作业 |</p>
<h5 id="2-重启停止的作业"><a href="#2-重启停止的作业" class="headerlink" title="2. 重启停止的作业"></a>2. 重启停止的作业</h5><p>后台模式运行：bg id</p>
<p>前台模式运行：fg id</p>
<h4 id="调整谦让度"><a href="#调整谦让度" class="headerlink" title="调整谦让度"></a>调整谦让度</h4><h5 id="1-nice命令"><a href="#1-nice命令" class="headerlink" title="1. nice命令"></a>1. nice命令</h5><p>nice -n：指定新的优先级级别</p>
<h5 id="2-renice命令"><a href="#2-renice命令" class="headerlink" title="2. renice命令"></a>2. renice命令</h5><p>renice -n 10 -p 5055</p>
<h4 id="定时运行作业"><a href="#定时运行作业" class="headerlink" title="定时运行作业"></a>定时运行作业</h4><h5 id="1-用at命令来计划执行作业"><a href="#1-用at命令来计划执行作业" class="headerlink" title="1. 用at命令来计划执行作业"></a>1. 用at命令来计划执行作业</h5><ol>
<li>at命令的格式</li>
</ol>
<p><strong>格式：</strong></p>
<p>at [ -f filename ] time</p>
<p>at -f test.sh now</p>
<ol start="2">
<li>列出等待的作业</li>
</ol>
<p>atq可以查看系统中等待的作业</p>
<ol start="3">
<li>删除作业</li>
</ol>
<p>arrm删除等待的作业</p>
<h5 id="2-安排需要定期执行的脚本"><a href="#2-安排需要定期执行的脚本" class="headerlink" title="2. 安排需要定期执行的脚本"></a>2. 安排需要定期执行的脚本</h5><ol>
<li>cron时间表</li>
</ol>
<p><strong>格式：</strong></p>
<p>min hour dayofmonth month dayofweek command</p>
<ol start="2">
<li>构建cron时间表</li>
</ol>
<p>crontb -l：列出时间表</p>
<ol start="3">
<li>浏览cron目录</li>
</ol>
<p>包括：hourly、daily、monthly、weekly</p>
<p>ls /etc/cron.*ly</p>
<ol start="4">
<li>anacron程序</li>
</ol>
<p><strong>格式：</strong></p>
<p>period delay identifier command</p>
<h2 id="高级shell脚本编程"><a href="#高级shell脚本编程" class="headerlink" title="高级shell脚本编程"></a>高级shell脚本编程</h2><h3 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h3><h4 id="基本的脚本函数"><a href="#基本的脚本函数" class="headerlink" title="基本的脚本函数"></a>基本的脚本函数</h4><h5 id="1-创建函数"><a href="#1-创建函数" class="headerlink" title="1. 创建函数"></a>1. 创建函数</h5><p>function name {<br>  commands<br>}</p>
<p>name() {<br>  commands<br>}</p>
<h5 id="2-使用函数"><a href="#2-使用函数" class="headerlink" title="2. 使用函数"></a>2. 使用函数</h5><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><ul>
<li>默认退出状态码</li>
</ul>
<p>$?</p>
<ul>
<li>使用return命令</li>
</ul>
<p><strong>注意：</strong> 函数一结束就取返回值；退出状态码必须是0～255。</p>
<ul>
<li>使用函数输出</li>
</ul>
<h4 id="在函数中使用变量"><a href="#在函数中使用变量" class="headerlink" title="在函数中使用变量"></a>在函数中使用变量</h4><p>局部变量：local temp</p>
<h4 id="数组变量和函数"><a href="#数组变量和函数" class="headerlink" title="数组变量和函数"></a>数组变量和函数</h4><h3 id="图形化桌面环境中的脚本编程"><a href="#图形化桌面环境中的脚本编程" class="headerlink" title="图形化桌面环境中的脚本编程"></a>图形化桌面环境中的脚本编程</h3><h3 id="初识sed和gawk"><a href="#初识sed和gawk" class="headerlink" title="初识sed和gawk"></a>初识sed和gawk</h3><h4 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h4><h5 id="1-sed编辑器"><a href="#1-sed编辑器" class="headerlink" title="1. sed编辑器"></a>1. sed编辑器</h5><p>sed：stream editor</p>
<p><strong>说明：</strong></p>
<ol>
<li><p>一次从输入中读取一行数据</p>
</li>
<li><p>根据所提供的编辑器命令匹配数据</p>
</li>
<li><p>按照命令修改流中的数据</p>
</li>
<li><p>将新的数据输出到STDOUT。</p>
</li>
</ol>
<p><strong>格式：</strong></p>
<p>sed options script file</p>
<p><strong>选项：</strong></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-e script</td>
<td>在处理输入时，将script中指定的命令添加到已有的命令中</td>
</tr>
<tr>
<td>-f file</td>
<td>在处理输入时，将file中指定的命令添加到已有的命令中</td>
</tr>
<tr>
<td>-n</td>
<td>不产生命令输出，使用print命令完成输出</td>
</tr>
</tbody></table>
<ol>
<li><strong>格式：</strong></li>
</ol>
<p>sed ‘s/test/big test/‘</p>
<p>例如：</p>
<p>echo “this is a test” | sed ‘s/test/big test/‘</p>
<p>sed ‘s/dog/cat/‘ data.txt</p>
<ol start="2">
<li><strong>执行多个命令格式：</strong></li>
</ol>
<p>sed -e ‘e/brown/green/;s/dog/cat/‘ data.txt</p>
<ol start="3">
<li><strong>从文件中读取编辑器命令</strong></li>
</ol>
<p>sed -f file.sed data.txt</p>
<h5 id="2-gawk程序"><a href="#2-gawk程序" class="headerlink" title="2. gawk程序"></a>2. gawk程序</h5><ol>
<li>gawk命令格式</li>
</ol>
<p>gawk options program file</p>
<p><strong>可用选项：</strong></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-F fs</td>
<td>指定行中划分数据字段的字段分隔符</td>
</tr>
<tr>
<td>-f file</td>
<td>从指定的文件中读取程序</td>
</tr>
<tr>
<td>-v var=value</td>
<td>定义gawk程序中的一个变量及其默认值</td>
</tr>
<tr>
<td>-mf N</td>
<td>指定要处理的数据文件中的最大字段数</td>
</tr>
<tr>
<td>-mr N</td>
<td>指定数据文件中的最大数据行数</td>
</tr>
<tr>
<td>-W keyword</td>
<td>指定gawk的兼容模式或警告等级</td>
</tr>
</tbody></table>
<ol start="2">
<li>从命令行读取程序脚本</li>
</ol>
<p>grawk ‘{print “Hello World!”}’</p>
<ol start="3">
<li>使用数据字段变量</li>
</ol>
<p>$0:代表整个文本行</p>
<p>$1:代表文本行中的第1个数据字段</p>
<p>$2:代表文本行中的第2个数据字段</p>
<p>$n:代表文本行中的第n个数据字段</p>
<h4 id="sde编辑器基础"><a href="#sde编辑器基础" class="headerlink" title="sde编辑器基础"></a>sde编辑器基础</h4><h5 id="1-更多的替换选项"><a href="#1-更多的替换选项" class="headerlink" title="1. 更多的替换选项"></a>1. 更多的替换选项</h5><ol>
<li>替换标记</li>
</ol>
<p>s/pattern/replacement/flags</p>
<p><strong>flags：</strong></p>
<ul>
<li><p>数字：将新文本替换第几行模式匹配的地方</p>
</li>
<li><p>g：替换所有</p>
</li>
<li><p>p：原先行的内容要打印出来</p>
</li>
<li><p>w：file，将替换的结果写到文件中</p>
</li>
</ul>
<ol start="2">
<li>替换字符</li>
</ol>
<p><code>/</code></p>
<h5 id="2-使用地址"><a href="#2-使用地址" class="headerlink" title="2. 使用地址"></a>2. 使用地址</h5><p>行寻址（line addressing）</p>
<ul>
<li><p>以数字形式表示行区间</p>
</li>
<li><p>用文本模式来过滤出行</p>
</li>
</ul>
<p><strong>格式：</strong></p>
<p>[address] command</p>
<p>address{<br>  command1<br>  command2<br>  command3<br>}</p>
<ol>
<li>数字方式的行寻址</li>
</ol>
<p>sed ‘2s/dog/cat’ data.txt</p>
<p>sed ‘2,3s/dog/cat’ data.txt</p>
<p>sed ‘2,$s/dog/cat’ data.txt</p>
<ol start="2">
<li>使用文本模式过滤器</li>
</ol>
<p><strong>格式：</strong></p>
<p><em>/pattern/command</em></p>
<ol start="3">
<li>命令组合</li>
</ol>
<h5 id="3-删除行"><a href="#3-删除行" class="headerlink" title="3. 删除行"></a>3. 删除行</h5><p>sed ‘d’ data.txt</p>
<h5 id="4-插入和附加文本"><a href="#4-插入和附加文本" class="headerlink" title="4. 插入和附加文本"></a>4. 插入和附加文本</h5><ul>
<li>insert命令i</li>
<li>append命令a</li>
</ul>
<p><strong>格式：</strong></p>
<p>sed ‘[address]command\new line’</p>
<p><strong>举例：</strong></p>
<p>sed ‘i\Test line 1’</p>
<p>sed ‘a\test line 1’</p>
<h5 id="5-修改行"><a href="#5-修改行" class="headerlink" title="5. 修改行"></a>5. 修改行</h5><p>sed ‘3c\t xxxx’ data.txt</p>
<h4 id="转换命令"><a href="#转换命令" class="headerlink" title="转换命令"></a>转换命令</h4><p>[address]y/inchars/outchars</p>
<h4 id="回顾打印"><a href="#回顾打印" class="headerlink" title="回顾打印"></a>回顾打印</h4>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Shell编程</tag>
      </tags>
  </entry>
  <entry>
    <title>编写makefile</title>
    <url>/linux/makefile/</url>
    <content><![CDATA[<h2 id="编写makefile"><a href="#编写makefile" class="headerlink" title="编写makefile"></a>编写makefile</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>或许很多Winodws的程序员都不知道这个东西，是因为那些Windows的IDE都为你做了这个工作，但是要成为一个好的或者professional的程序员，掌握和了解makefile还很有必要的。这就好像现在有这么多的HTML的编辑器，但如果你想成为一个专业人士，你还是要了解HTML的标识的含义。特别是在Unix下的软件编译，你就不得不自己写makefile了，会不会写makefile，从一个侧面说明了一个人是否具备完成大型工程的能力。</p>
<p>因为，makefile关系到了整个工程的编译规则。一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。</p>
<p>makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。可见，makefile都成为了一种在工程方面的编译方法。</p>
<h3 id="关于程序的编译和连接"><a href="#关于程序的编译和连接" class="headerlink" title="关于程序的编译和连接"></a>关于程序的编译和连接</h3><a id="more"></a>
<p>一般来说，无论是C、C++、还是pas，首先要把源文件编译成中间代码文件，在Windows下也就是<code>.obj</code> 文件，UNIX下是<code>.o </code>文件，即Object File，这个动作叫做编译（compile）。然后再把大量的Object File合成执行文件，这个动作叫作链接（link）。</p>
<ol>
<li><p>编译时</p>
<p> 编译器需要的是语法的正确，函数与变量的声明的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（头文件中应该只是声明，而定义应该放在C/C++文件中），只要所有的语法正确，编译器就可以编译出中间目标文件。一般来说，每个源文件都应该对应于一个中间目标文件（O文件或是OBJ文件）。</p>
</li>
<li><p>链接时</p>
<p>   主要是链接函数和全局变量，所以，我们可以使用这些中间目标文件（O文件或是OBJ文件）来链接我们的应用程序。链接器并不管函数所在的源文件，只管函数的中间目标文件（Object File），在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，我们要给中间目标文件打个包，在Windows下这种包叫”库文件”（Library File)，也就是<code>.lib</code>文件，在UNIX下，是Archive File，也就是 ‘.a’文件。</p>
</li>
</ol>
<p>总结一下，源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。在编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码（Linker Error），在VC下，这种错误一般是：Link 2001错误，意思说是说，链接器未能找到函数的实现。你需要指定函数的Object File.</p>
<h3 id="makefile介绍"><a href="#makefile介绍" class="headerlink" title="makefile介绍"></a>makefile介绍</h3><p>make命令执行时，需要一个Makefile文件，以告诉make命令需要怎么样的去编译和链接程序。</p>
<p>首先，我们用一个示例来说明Makefile的书写规则。以便给大家一个感兴认识。这个示例来源于GNU的make使用手册，在这个示例中，我们的工程有8个C文件，和3个头文件，我们要写一个Makefile来告诉make命令如何编译和链接这几个文件。我们的规则是：</p>
<ol>
<li><p>如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。</p>
</li>
<li><p>如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。</p>
</li>
<li><p>如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序。</p>
</li>
</ol>
<p>只要我们的Makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自己编译所需要的文件和链接目标程序。</p>
<h4 id="Makefile的规则"><a href="#Makefile的规则" class="headerlink" title="Makefile的规则"></a>Makefile的规则</h4><p>在讲述这个Makefile之前，还是让我们先来粗略地看一看Makefile的规则。</p>
<p>target … : prerequisites …<br>command<br>…<br>…</p>
<p>target也就是一个目标文件，可以是Object File，也可以是执行文件。还可以是一个标签（Label），对于标签这种特性，在后续的“伪目标”章节中会有叙述。</p>
<p>prerequisites就是，要生成那个target所需要的文件或是目标。</p>
<p>command也就是make需要执行的命令。（任意的Shell命令）</p>
<p>这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。这就是Makefile的规则。也就是Makefile中最核心的内容。</p>
<h4 id="makefile示例"><a href="#makefile示例" class="headerlink" title="makefile示例"></a>makefile示例</h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">edit : main.o kbd.o command.o display.o /</span><br><span class="line">insert.o search.o files.o utils.o</span><br><span class="line">cc -o edit main.o kbd.o command.o display.o /</span><br><span class="line">insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">cc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">cc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">cc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">cc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">cc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">cc -c utils.c</span><br><span class="line">clean :</span><br><span class="line">rm edit main.o kbd.o command.o display.o /</span><br><span class="line">insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure>
<h4 id="make是如何工作的"><a href="#make是如何工作的" class="headerlink" title="make是如何工作的"></a>make是如何工作的</h4><p>在默认的方式下，也就是我们只输入make命令。那么，</p>
<ol>
<li><p>make会在当前目录下找名字叫“Makefile”或“makefile”的文件。</p>
</li>
<li><p>如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到”edit”这个文件，并把这个文件作为最终的目标文件。</p>
</li>
<li><p>如果edit文件不存在，或是edit所依赖的后面的.o文件的文件修改时间要比edit这个文件新，那么，他就会执行后面所定义的命令来生成edit这个文件。</p>
</li>
<li><p>如果edit所依赖的.o文件也不存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。（这有点像一个堆栈的过程）</p>
</li>
<li><p>当然，你的C文件和H文件是存在的啦，于是make会生成.o文件，然后再用.o文件生成make的终极任务，也就是执行文件edit了。</p>
</li>
</ol>
<p>这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make根本不理。make只管文件的依赖性，即，如果在我找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦。</p>
<p>通过上述分析，我们知道，像clean这种，没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将不会被自动执行，不过，我们可以显示要make执行。即命令——“make clean”，以此来清除所有的目标文件，以便重编译。</p>
<p>于是在我们编程中，如果这个工程已被编译过了，当我们修改了其中一个源文件，比如file.c，那么根据我们的依赖性，我们的目标file.o会被重编译（也就是在这个依性关系后面所定义的命令），于是file.o的文件也是最新的啦，于是file.o的文件修改时间要比edit要新，所以edit也会被重新链接了（详见edit目标文件后定义的命令）。</p>
<p>而如果我们改变了”command.h”，那么，kdb.o、command.o和files.o都会被重编译，并且，edit会被重链接。</p>
<h4 id="一个简短的举例"><a href="#一个简短的举例" class="headerlink" title="一个简短的举例"></a>一个简短的举例</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* hellomake.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;hellomake.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* code */</span></span><br><span class="line">  myPrintHelloMake();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* hellomake.h */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * example include file</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrintHelloMake</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* hellofun.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;hellomake.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrintHelloMake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* code */</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello makefiles!\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>正常情况下的gcc编译</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -o hellomake hellomake.c hellofun.c -I.</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>第一种方法使用</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi makefile</span><br><span class="line"></span><br><span class="line">hellomake: hellomake.c hellofun.c</span><br><span class="line">    gcc -o hellomake hellomake.c hellofun.c -I.</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>第二种方法使用</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi makefile</span><br><span class="line"></span><br><span class="line">CC&#x3D;gcc</span><br><span class="line">CFLAGS&#x3D;-I.</span><br><span class="line"></span><br><span class="line">hellomake: hellomake.o hellofun.o</span><br><span class="line">    $(CC) -o hellomake hellomake.o hellofun.o</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>第三种方法使用</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi makefile</span><br><span class="line"></span><br><span class="line">CC&#x3D;gcc</span><br><span class="line">CFLAGS&#x3D;-I.</span><br><span class="line">DEPS&#x3D;hellomake.h</span><br><span class="line"></span><br><span class="line">%.o: %.c $(DEPS)</span><br><span class="line">    $(CC) -c -o $@ $&lt; $(CFLAGS)</span><br><span class="line"></span><br><span class="line">hellomake: hellomake.o hellofun.o</span><br><span class="line">    $(CC) -o hellomake hellomake.o hellofun.o</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>第四种方法使用</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi makefile</span><br><span class="line"></span><br><span class="line">CC&#x3D;gcc</span><br><span class="line">CFLAGS&#x3D;-I.</span><br><span class="line">DEPS&#x3D;hellomake.h</span><br><span class="line">OBJ&#x3D;hellomake.o hellofun.o</span><br><span class="line"></span><br><span class="line">%.o: %.c $(DEPS)</span><br><span class="line">    $(CC) -c -o $@ $&lt; $(CFLAGS)</span><br><span class="line"></span><br><span class="line">hellomake: $(OBJ)</span><br><span class="line">    $(CC) -o $@ $^ $(CFLAGS)</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>第五种方法使用</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi makefile</span><br><span class="line"></span><br><span class="line">CC&#x3D;gcc</span><br><span class="line">CFLAGS&#x3D;-I.</span><br><span class="line">DEPS&#x3D;hellomake.h</span><br><span class="line"></span><br><span class="line">%.o: %.c $(DEPS)</span><br><span class="line">    $(CC) -c -o $@ $&lt; $(CFLAGS)</span><br><span class="line"></span><br><span class="line">hellomake: hellomake.o hellofun.o</span><br><span class="line">    $(CC) -o hellomake hellomake.o hellofun.o</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>第六种方法使用</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi makefile</span><br><span class="line"></span><br><span class="line">IDIR&#x3D;..&#x2F;include</span><br><span class="line">CC&#x3D;gcc</span><br><span class="line">CFLAGS&#x3D;-I$(IDIR)</span><br><span class="line"></span><br><span class="line">ODIR&#x3D;obj</span><br><span class="line">LDIR&#x3D;..&#x2F;lib</span><br><span class="line"></span><br><span class="line">LIBS&#x3D;-lm</span><br><span class="line"></span><br><span class="line">_DEPS&#x3D;hellomake.h</span><br><span class="line">DEPS&#x3D;$(patsubst %, $(IDIR)&#x2F;%,$(_DEPS))</span><br><span class="line"></span><br><span class="line">_OBJ&#x3D;hellomake.o hellofun.o</span><br><span class="line">OBJ&#x3D;$(patsubst %,$(ODIR)&#x2F;%,$(_OBJ))</span><br><span class="line"></span><br><span class="line">$(ODIR)&#x2F;%.o: %.c $(DEPS)</span><br><span class="line">    $(CC) -o $@ $^ $(CFLAGS) $(LIBS)</span><br><span class="line"></span><br><span class="line">.PHONY:clean</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    rm -rf $(ODIR)&#x2F;*.o *~ core $(INCDIR)&#x2F;*~</span><br><span class="line"></span><br><span class="line">DEPS&#x3D;hellomake.h</span><br><span class="line"></span><br><span class="line">%.o: %.c $(DEPS)</span><br><span class="line">    $(CC) -c -o $@ $&lt; $(CFLAGS)</span><br><span class="line"></span><br><span class="line">hellomake: $(OBJ)</span><br><span class="line">    $(CC) -o $@ $^ $(CFLAGS)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux、C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的虚函数和纯虚函数</title>
    <url>/c++/pureVirtual_virtual/</url>
    <content><![CDATA[<h2 id="C-中的虚函数和纯虚函数"><a href="#C-中的虚函数和纯虚函数" class="headerlink" title="C++中的虚函数和纯虚函数"></a>C++中的虚函数和纯虚函数</h2><p>要想了解C++中的虚函数和纯虚函数，首先要给大家介绍一下C++中的多态，要实现多态必须具备一下三个条件：</p>
<ul>
<li><p>必须存在继承关系；</p>
</li>
<li><p>继承关系中必须有同名的虚函数；</p>
</li>
<li><p>存在基类类型的指针或引用，通过该指针或引用调用虚函数。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;I&#x27;m base class!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">puredisplay</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;I&#x27;m base class!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived</span>:</span> <span class="keyword">public</span> base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;I&#x27;m derived class!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">puredisplay</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;I&#x27;m derived class!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    base * p;</span><br><span class="line">    derived test;</span><br><span class="line">    p = &amp;test;</span><br><span class="line">    p-&gt;.display();    <span class="comment">//&quot;I&#x27;m base class!&quot;</span></span><br><span class="line"></span><br><span class="line">    base * purep;</span><br><span class="line">    derived puretest;</span><br><span class="line">    purep = &amp;puretest;</span><br><span class="line">    purep-&gt;display();    <span class="comment">//&quot;I&#x27;m derived class!&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用多态会降低程序运行效率，使用多态的程序会使用更多的存储空间，存储虚函数表等内容，而且在调用函数时需要去虚函数表中查询函数入口地址，这会增加程序运行时间。</p>
<p>在设计程序时，程序设计人员可以选择性的使用多态，对于有需要的函数使用多态，对于其它的函数则不要采用多态。</p>
<p>通常情况下，如果一个类需要作为基类，并且期望在派生类中修改某成员函数的功能，并且在使用类对象的时候会采用指针或引用的形式访问该函数，则将该函数声明为虚函数。</p>
<h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><a id="more"></a>
<p>在函数返回类型前加上virtual关键字。virtual关键字仅用于函数声明，如果函数是在类外定义，则不需要再加上virtual关键字了，在C++中只有类中的成员函数能被声明为虚函数，而对于顶层函数则不能声明为虚函数，原因很简单，声明虚函数是为了构成多态，而构成多态的第一个条件就是需要继承关系，顶层函数很明显是不具有继承关系的，因此也就不能被声明为虚函数了。</p>
<h4 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h4><p>在C++中通过虚成员函数表vtable实现多态，虚函数表中存储的是类中虚函数的入口地址。在普通的类中是没有虚函数表的，只有在具有虚函数的类中（无论是自身添加的虚函数还是继承过来的虚函数）才会具有虚函数表，通常虚成员函数表的首地址将会被存入对象的最前面（在32位的操作系统中，存储地址是用4个字节，因此这个首地址就会占用对象的前四个字节的空间）。</p>
<h4 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h4><p>在类中，构造函数用于初始化对象及相关操作，构造函数是不能声明为虚函数的，因为在执行构造函数前对象尚未完成创建，虚函数表尚不存在，此时就无法去查询虚函数表，因此也就无法得知该调用哪一个构造函数了。</p>
<p>析构函数则用于销毁对象时完成相应的资源释放工作，析构函数可以被声明为虚函数。</p>
<p>将基类的析构函数声明为虚函数之后，派生类的析构函数也自动成为虚析构函数，在主函数中基类指针p指向的是派生类对象，当delete释放p指针所指向的存储空间时，会执行派生类的析构函数，派生类的析构函数执行完之后会紧接着执行基类的析构函数，以释放从基类继承过来的成员变量所消耗的资源。如此一来就不会存在内存泄漏问题了。</p>
<p>将析构函数声明为虚函数的必要性，但是如果不管三七二十一的将所有的基类的析构函数都声明为虚函数，这也是不合适的。通常来说，如果基类中存在一个指向动态分配内存的成员变量，并且基类的析构函数中定义了释放该动态分配内存的代码，则应该将基类的析构函数声明为虚函数。</p>
<h4 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h4><p>只有非静态成员函数才可以成为虚函数，而静态成员函数不能声明为虚函数。</p>
<h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><h4 id="声明-1"><a href="#声明-1" class="headerlink" title="声明"></a>声明</h4><p>纯虚成员函数的声明语法如下：</p>
<pre><code>virtual 函数返回类型 函数名 (函数参数) = 0;
</code></pre>
<p>纯虚成员函数没有函数体，只有函数声明，在纯虚函数声明结尾加上“=0”表明此函数为纯虚成员函数。</p>
<p>包含纯虚成员函数的类即为抽象基类，之所以说它抽象，那是因为它无法实例化，也即无法用于创建对象。</p>
<p>纯虚成员函数可以被派生类继承，如果派生类不重新定义抽象基类中的所有（有多个则要重新定义多个）纯虚成员函数，则派生类同样会成为抽象基类，因而也不能用于创建对象。</p>
<p>只有类中的虚函数才能被声明为纯虚成员函数，普通成员函数和顶层函数均不能声明为纯虚成员函数。</p>
<p>抽象基类可以用于实现公共接口，在抽象基类中声明的纯虚成员函数，派生类如果想要能够创建对象，则必须全部重新定义这些纯虚成员函数。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li><p>虚函数和纯虚函数可以定义在同一个类中，含有纯虚函数的类被称为抽象类，而只含有虚函数的类不能被称为抽象类。</p>
</li>
<li><p>虚函数可以被直接使用，也可以被子类重载以后，以多态的形式调用，而纯虚函数必须在子类中实现该函数才可以使用，因为纯虚函数在基类有声明而没有定义。</p>
</li>
<li><p>虚函数和纯虚函数都可以在子类中被重载，以多态的形式被调用。</p>
</li>
<li><p>虚函数和纯虚函数通常存在于抽象基类之中，被继承的子类重载，目的是提供一个统一的接口。</p>
</li>
<li><p>虚函数的定义形式：virtual {};纯虚函数的定义形式：virtual  { } = 0;</p>
</li>
<li><p>在虚函数和纯虚函数的定义中不能有static标识符，原因很简单，被static修饰的函数在编译时要求前期绑定,然而虚函数却是动态绑定，而且被两者修饰的函数生命周期也不一样。</p>
</li>
<li><p>虚函数充分体现了面向对象思想中的继承和多态性这两大特性，在C++语言里应用极广。比如在微软的MFC类库中，你会发现很多函数都有virtual关键字，也就是说，它们都是虚函数。有人甚至称虚函数是C++语言的精髓。</p>
</li>
<li><p>定义纯虚函数就是为了让基类不可实例化，因为实例化这样的抽象数据结构本身并没有意义或者给出实现也没有意义。</p>
</li>
<li><p>纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。</p>
</li>
<li><p>虚函数在子类里面也可以不重载的，但纯虚必须在子类去实现。通常我们把很多函数加上virtual，是一个好的习惯，虽然牺牲了一些性能，但是增加了面向对象的多态性，因为你很难预料到父类里面的这个函数不在子类里面不去修改它的实现</p>
</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker与虚拟机</title>
    <url>/linux/docker_virtualmachine/</url>
    <content><![CDATA[<h2 id="Docker与虚拟机"><a href="#Docker与虚拟机" class="headerlink" title="Docker与虚拟机"></a>Docker与虚拟机</h2><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><h4 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h4><p>Docker是一个集开发、打包、运行应用于一体的开放式平台。Docker可以用来快速交付应用。使用Docker，你可以将应用程序从你的基础设施中分离出来，并将基础设施当做一个管理平台。Docker可以加快打包时间，加快测试，加快发布，缩短开发及运行代码之间的周期。Docker通过结合内核容器化特点和工作流，并使之工具化来实现这一切，帮助管理和发布你的应用。</p>
<h4 id="Docker的两个重要概念"><a href="#Docker的两个重要概念" class="headerlink" title="Docker的两个重要概念"></a>Docker的两个重要概念</h4><h5 id="镜像（Images）"><a href="#镜像（Images）" class="headerlink" title="镜像（Images）"></a>镜像（Images）</h5><p>Docker镜像是一个只读的模板。包含了容器运行时所需要的文件系统和一些参数。镜像是无状态的，也不会改变。镜像是用来创建容器的。你可以使用docker pull命令获取一个别人已创建好的镜像，或者使用dockerbuild来构建一个自己的镜像。</p>
<h5 id="容器（Containers）"><a href="#容器（Containers）" class="headerlink" title="容器（Containers）"></a>容器（Containers）</h5><a id="more"></a>
<p>Docker容器就像是一个文件夹，容器中包含了应用运行所需的一切。每个容器都是一个隔离的和安全的应用平台。容器是镜像的一个实例，它是有状态的，而且随时会改变，容器一般是短暂的。</p>
<h4 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h4><p><img src="docker_virtualmachine/docker_architecture.png" alt="Docker架构"></p>
<p>  <strong>说明：</strong></p>
<p>  该图显示Docker虚拟化的架构：其中Docker Engine可以简单看成对Linux的NameSpace、Cgroup、镜像管理文件系统操作的封装。Docker并没有和虚拟机一样利用一个完全独立的Guest OS实现环境隔离，它利用的是目前linux内核本身支持的容器方式实现资源和环境隔离。简单的说，Docker是利用namespace实现系统环境的隔离；利用Cgroup实现资源限制；利用镜像实现根目录环境的隔离。</p>
<h4 id="Docker-Engine"><a href="#Docker-Engine" class="headerlink" title="Docker Engine"></a>Docker Engine</h4><p>Docker Engine属于Docker的运行层。这是一套轻量化运行时及工具组合，负责管理容器、镜像、构建 等等。它以原生方式运行在Linux系统之上，并由以下元素构成：</p>
<ul>
<li><p>Docker Daemon，运行在主机计算机之上。</p>
</li>
<li><p>Docker Client，负责与Docker Daemon通信以执行命令。</p>
</li>
<li><p>REST API，用于同Docker Daemon远程交互。</p>
</li>
</ul>
<p>现在详细介绍一下这三者：</p>
<h5 id="Docker-Daemon"><a href="#Docker-Daemon" class="headerlink" title="Docker Daemon"></a>Docker Daemon</h5><p>Docker Daemon直接将执行命令发送至Docker Client——例如构建、运行以及分发等等。Docker Daemon运行在主机设备之上，但作为用户，我们永远不会直接与该Daemon进行通信。Docker Client也可以运行在主机设备上，但并非必需。它亦能够运行在另一台设备上，并与运行在目标主机上的Docker Daemon进行远程通信。</p>
<h5 id="Docker-Client"><a href="#Docker-Client" class="headerlink" title="Docker Client"></a>Docker Client</h5><p>Docker Client是我们作为最终用户的通信对象。我们可以将其视为Docker的UI。</p>
<p>我们进行的一切操作都将直接接入Docker Client，再由其将指令传递至Docker Daemon。</p>
<h5 id="REST-API"><a href="#REST-API" class="headerlink" title="REST API"></a>REST API</h5><p>用于同Docker Daemon远程交互。</p>
<h4 id="Docker可以做什么"><a href="#Docker可以做什么" class="headerlink" title="Docker可以做什么"></a>Docker可以做什么</h4><ul>
<li><p>快速交付应用</p>
</li>
<li><p>便捷的部署和调整</p>
</li>
<li><p>高密集度，高负载</p>
</li>
</ul>
<h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><h4 id="什么是虚拟机"><a href="#什么是虚拟机" class="headerlink" title="什么是虚拟机"></a>什么是虚拟机</h4><p>虚拟机在本质上就是在模拟一台真实的计算机设备，同时遵循同样的程序执行方式。虚拟机能够利用“虚拟机管理程序”运行在物理设备之上。反过来，虚拟机管理程序则可运行在主机设备或者“裸机”之上。</p>
<p>传统的虚拟机需要模拟整台机器包括硬件，每台虚拟机都需要有自己的操作系统，虚拟机一旦被开启，预分配给他的资源将全部被占用。，每一个虚拟机包括应用，必要的二进制和库，以及一个完整的用户操作系统。</p>
<h4 id="虚拟机架构"><a href="#虚拟机架构" class="headerlink" title="虚拟机架构"></a>虚拟机架构</h4><p><img src="docker_virtualmachine/vm_architecture.png" alt="虚拟机架构"></p>
<p>  <strong>说明：</strong></p>
<p>  该图展示虚拟机的架构，其中Guest OS层和Hypervisor层在docker中被Docker Engine层所替代。虚拟机的Guest OS即为虚拟机安装的操作系统，它是一个完整操作系统内核；虚拟机的Hypervisor层可以简单理解为一个硬件虚拟化平台，它在Host OS是以内核态的驱动存在的。</p>
<p>  虚拟机实现资源隔离的方法是利用独立的OS，并利用Hypervisor虚拟化CPU、内存、IO设备等实现的。例如，为了虚拟CPU，Hypervisor会为每个虚拟的CPU创建一个数据结构，模拟CPU的全部寄存器的值，在适当的时候跟踪并修改这些值。需要指出的是在大多数情况下，虚拟机软件代码是直接跑在硬件上的，而不需要Hypervisor介入。只有在一些权限高的请求下，Guest OS需要运行内核态修改CPU的寄存器数据，Hypervisor会介入，修改并维护虚拟的CPU状态。</p>
<p>  Hypervisor虚拟化内存的方法是创建一个shadow page table。正常的情况下，一个page table可以用来实现从虚拟内存到物理内存的翻译。在虚拟化的情况下，由于所谓的物理内存仍然是虚拟的，因此shadow page table就要做到：虚拟内存-&gt;虚拟的物理内存-&gt;真正的物理内存。</p>
<p>  对于IO设备虚拟化，当Hypervisor接到page fault，并发现实际上虚拟的物理内存地址对应的是一个I/O设备，Hypervisor就用软件模拟这个设备的工作情况，并返回。比如当CPU想要写磁盘时，Hypervisor就把相应的数据写到一个host OS的文件上，这个文件实际上就模拟了虚拟的磁盘。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Docker和虚拟机有各自擅长的领域，在软件开发、测试场景和生产运维场景中各有优劣</p>
<ol>
<li><p>Docker启动快速属于秒级别。虚拟机通常需要几分钟去启动。</p>
</li>
<li><p>Docker需要的资源更少，Docker在操作系统级别进行虚拟化，Docker容器和内核交互，几乎没有性能损耗，性能优于通过Hypervisor层与内核层的虚拟化。</p>
</li>
<li><p>Docker更轻量，Docker的架构可以共用一个内核与共享应用程序库，所占内存极小。同样的硬件环境，Docker运行的镜像数远多于虚拟机数量。对系统的利用率非常高。</p>
</li>
<li><p>与虚拟机相比，Docker隔离性更弱，Docker属于进程之间的隔离，虚拟机可实现系统级别隔离。</p>
</li>
<li><p>安全性：Docker的安全性也更弱。Docker的租户root和宿主机root等同，一旦容器内的用户从普通用户权限提升为root权限，它就直接具备了宿主机的root权限，进而可进行无限制的操作。虚拟机租户root权限和宿主机的root虚拟机权限是分离的，并且虚拟机利用如Intel的VT-d和VT-x的ring-1硬件隔离技术，这种隔离技术可以防止虚拟机突破和彼此交互，而容器至今还没有任何形式的硬件隔离，这使得容器容易受到攻击。</p>
</li>
<li><p>可管理性：Docker的集中化管理工具还不算成熟。各种虚拟化技术都有成熟的管理工具，例如VMware vCenter提供完备的虚拟机管理能力。</p>
</li>
<li><p>高可用和可恢复性：Docker对业务的高可用支持是通过快速重新部署实现的。虚拟化具备负载均衡、高可用、容错、迁移和数据保护等经过生产实践检验的成熟保障机制，VMware可承诺虚拟机99.999%高可用，保证业务连续性。</p>
</li>
<li><p>快速创建、删除：虚拟化创建是分钟级别的，Docker容器创建是秒级别的，Docker的快速迭代性，决定了无论是开发、测试、部署都可以节约大量时间。</p>
</li>
<li><p>交付、部署：虚拟机可以通过镜像实现环境交付的一致性，但镜像分发无法体系化；Docker在Dockerfile中记录了容器构建过程，可在集群中实现快速分发和快速部署。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Docker、虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS使用yum update空间不足</title>
    <url>/linux/centos_boot_space/</url>
    <content><![CDATA[<h2 id="CentOS7在使用yum-update时提示boot空间不足问题"><a href="#CentOS7在使用yum-update时提示boot空间不足问题" class="headerlink" title="CentOS7在使用yum update时提示boot空间不足问题"></a>CentOS7在使用yum update时提示boot空间不足问题</h2><p>Q:At least xMB more space needed on the /boot filesystem</p>
<p>A：删除多余的kernel<br>df -h</p>
<p>rpm -qa | grep kernel</p>
<p>rpm -e kernel-2.6.32-220.7.1.el6.x86_64</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的结构体和类</title>
    <url>/c++/struct_class/</url>
    <content><![CDATA[<h2 id="C-中的结构体和类"><a href="#C-中的结构体和类" class="headerlink" title="C++中的结构体和类"></a>C++中的结构体和类</h2><h3 id="结构体-struct"><a href="#结构体-struct" class="headerlink" title="结构体(struct)"></a>结构体(struct)</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><strong>结构体(struct)</strong> 是由一系列具有相同类型或不同类型的数据构成的数据集合，也叫结构。</p>
<p>C语言中struct定义了一组变量的集合，C编译器并不认为这是一种新的类型。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Teacher</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> names[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">int</span> age;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Teacher t1; <span class="comment">//这是错误的</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Teacher</span> <span class="title">t1</span>;</span> <span class="comment">//这是正确的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++语言中struct是一种新类型的定义声明，进行了类型加强</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Teacher</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> names[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">int</span> age;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Teacher t1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="定义和初始化"><a href="#定义和初始化" class="headerlink" title="定义和初始化"></a>定义和初始化</h4><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><ol>
<li>先声明结构体类型再初始化变量</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体的声明</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student stu1, stu2;    <span class="comment">//结构体变量的初始化</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(stu1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(stu2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在声明结构体类型的同时初始化变量</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//结构体的声明</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">        <span class="keyword">char</span> name[<span class="number">32</span>];</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">        <span class="keyword">int</span> score;</span><br><span class="line">    &#125; stu1, stu2;    <span class="comment">//结构体变量的初始化</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(stu1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(stu2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>直接定义结构体变量</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//结构体的声明</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">char</span> name[<span class="number">32</span>];</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">        <span class="keyword">int</span> score;</span><br><span class="line">    &#125; stu1, stu2;    <span class="comment">//结构体变量的初始化</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(stu1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(stu2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>注：</em> 虽然这几种定义方式都可以，但是最常用的是第一种方法</p>
<p><strong>结构体类型需要注意的几点：</strong></p>
<a id="more"></a>
<ol>
<li><p>只能对结构体变量中的成员赋值，而不能对结构体类型赋值。</p>
</li>
<li><p>对结构体变量中的成员（即“域”），可以单独使用，它的作用与地位相当于同类型的普通变量。</p>
</li>
<li><p>结构体的成员也可以是一个结构体变量。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体的声明</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Date</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">    <span class="keyword">int</span> mounth;</span><br><span class="line">    <span class="keyword">int</span> day;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    Date birthday;   <span class="comment">//Date是结构体类型，birthday是Date的类型的变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student stu;    <span class="comment">//结构体变量的初始化</span></span><br><span class="line">    Date date;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(stu) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(date) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>结构体中的成员名可以与程序中的变量名相同，但二者没有关系。</li>
</ol>
<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><ol>
<li>在定义结构体时对结构体变量指定初始值</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">&#125; stu1&#123;</span><br><span class="line">    &#x27;li&#x27;,</span><br><span class="line">    <span class="number">18</span>,</span><br><span class="line">    <span class="number">80</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在定义变量时进行初始化（这种方法更常用）</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    Student stu1&#123;</span><br><span class="line">        &#x27;li&#x27;,</span><br><span class="line">        <span class="number">18</span>,</span><br><span class="line">        <span class="number">80</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="结构体变量的引用"><a href="#结构体变量的引用" class="headerlink" title="结构体变量的引用"></a>结构体变量的引用</h4><p>在定义了结构体变量之后，就可以引用这个变量。</p>
<ol>
<li><p>引用结构体变量中的一个成员的值</p>
<p>引用方式：<strong>结构体变量名.成员名</strong>,其中“.”是成员运算符，它在所有的运算符中优先级最高。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Date</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">    <span class="keyword">int</span> mounth;</span><br><span class="line">    <span class="keyword">int</span> day;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    Date birthday;   <span class="comment">//Date是结构体类型，birthday是Date的类型的变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student stu = &#123;<span class="string">&quot;li&quot;</span>, <span class="number">18</span>, <span class="number">100</span>, <span class="number">1993</span>, <span class="number">10</span>, <span class="number">1</span>&#125;;    <span class="comment">//结构体变量的初始化</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; stu.name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; stu.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; stu.score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;stu.birthday.year&lt;&lt;<span class="string">&quot;/&quot;</span>&lt;&lt;stu.birthday.mounth&lt;&lt;<span class="string">&quot;/&quot;</span>&lt;&lt;stu.birthday.day &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个成员本身也是一个结构体类型，则要用若干个成员运算符，一级一级地找到最低一级的成员。</p>
<p>比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;stu.birthday.year&lt;&lt;<span class="string">&quot;/&quot;</span>&lt;&lt;stu.birthday.mounth&lt;&lt;<span class="string">&quot;/&quot;</span>&lt;&lt;stu.birthday.day &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>可以将一个结构体变量的值付给另外一个具有相同结构的结构体变量。</p>
</li>
<li><p>可以引用结构体变量的地址，也可以引用结构体变量成员的地址。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Date</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">    <span class="keyword">int</span> mounth;</span><br><span class="line">    <span class="keyword">int</span> day;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    Date birthday;   <span class="comment">//Date是结构体类型，birthday是Date的类型的变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student stu1 = &#123;<span class="string">&quot;li&quot;</span>, <span class="number">18</span>, <span class="number">100</span>, <span class="number">1993</span>, <span class="number">10</span>, <span class="number">1</span>&#125;;    <span class="comment">//结构体变量的初始化</span></span><br><span class="line">    Student &amp;stu2=stu1;</span><br><span class="line">    stu2.age++;</span><br><span class="line">    stu2.birthday.day+=<span class="number">10</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; stu2.name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; stu2.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; stu2.score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;stu2.birthday.year&lt;&lt;<span class="string">&quot;/&quot;</span>&lt;&lt;stu2.birthday.mounth&lt;&lt;<span class="string">&quot;/&quot;</span>&lt;&lt;stu2.birthday.day &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类-class"><a href="#类-class" class="headerlink" title="类(class)"></a>类(class)</h3></li>
</ol>
<h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p><strong>类(class)</strong> 是一种数据类型，该类型类似于普通的数据类型，但是又有别于普通的数据类型。类这种数据类型是一个包含成员变量和成员函数的一个集合。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];  <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">int</span> id_num;     <span class="comment">//学号</span></span><br><span class="line">    <span class="keyword">int</span> age;        <span class="comment">//年龄</span></span><br><span class="line">    <span class="keyword">char</span> sex;       <span class="comment">//性别</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_age</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_age</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="定义和初始化-1"><a href="#定义和初始化-1" class="headerlink" title="定义和初始化"></a>定义和初始化</h4><h5 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h5><ol>
<li>定义一个类</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类的声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];  <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">int</span> id_num;     <span class="comment">//学号</span></span><br><span class="line">    <span class="keyword">int</span> age;        <span class="comment">//年龄</span></span><br><span class="line">    <span class="keyword">char</span> sex;       <span class="comment">//性别</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_age</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_age</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中成员变量：name、id_num、age、sex；成员函数：set_age(int a)、get_age();</p>
<p><strong>有两种方法可以给出成员函数的定义：</strong></p>
<ol>
<li>内联定义(inline)</li>
</ol>
<p>在类内部进行函数的声明和定义，此种方式我们成为inline。inline是C++关键字，专门用于表示内联；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];  <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">int</span> id_num;     <span class="comment">//学号</span></span><br><span class="line">    <span class="keyword">int</span> age;        <span class="comment">//年龄</span></span><br><span class="line">    <span class="keyword">char</span> sex;       <span class="comment">//性别</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_age</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;age = a;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_age</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> age;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在类内进行函数声明，在类外部进行函数定义。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];  <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">int</span> id_num;     <span class="comment">//学号</span></span><br><span class="line">    <span class="keyword">int</span> age;        <span class="comment">//年龄</span></span><br><span class="line">    <span class="keyword">char</span> sex;       <span class="comment">//性别</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_age</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_age</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在类外部定义set_age函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">student::set_age</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    age = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在类外部定义get_age函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">student::get_age</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在类内声明函数，如果在函数声明时使用inline关键字，如例4所示，则可以将类内声明类外定义的函数强制转换为内联函数。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];  <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">int</span> id_num;     <span class="comment">//学号</span></span><br><span class="line">    <span class="keyword">int</span> age;        <span class="comment">//年龄</span></span><br><span class="line">    <span class="keyword">char</span> sex;       <span class="comment">//性别</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set_age</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_age</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//在类外部定义set_age函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">student::set_age</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    age = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在类外部定义get_age函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">student::get_age</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>C++语言继承了C语言的struct，并且加以扩充。在C语言中struct是只能定义数据成员，而不能定义成员函数的。而在C++中，struct类似于class，在其中既可以定义数据成员，又可以定义成员函数。</p>
<p>在C++中，struct与class基本是通用的，唯一不同的是如果使用class关键字，类中定义的成员变量或成员函数默认都是private属性的，而采用struct关键字，结构体中定义的成员变量或成员函数默认都是public属性的。</p>
<p>在C++中，没有抛弃C语言中的struct关键字，其意义就在于给C语言程序开发人员有一个归属感，并且能让C++编译器兼容以前用C语言开发出来的项目。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++宏定义</title>
    <url>/c++/macor_of_c++/</url>
    <content><![CDATA[<h2 id="C-C-宏定义"><a href="#C-C-宏定义" class="headerlink" title="C/C++宏定义"></a>C/C++宏定义</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>用<code>#define</code>命令将一个指定的标识符（即宏名）来代表一个字符串。可以分为两种：</p>
<h4 id="简单的宏定义"><a href="#简单的宏定义" class="headerlink" title="简单的宏定义"></a>简单的宏定义</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 表示符 字符串</span></span><br></pre></td></tr></table></figure>
<p><strong>举例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> pi2 = PI * <span class="number">2</span>;   <span class="comment">//pi2 = 6.28</span></span><br></pre></td></tr></table></figure>
<h4 id="带参数的宏定义"><a href="#带参数的宏定义" class="headerlink" title="带参数的宏定义"></a>带参数的宏定义</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> <span class="meta-string">&lt;宏名&gt; (&lt;参数表&gt;) &lt;宏体&gt;</span></span></span><br></pre></td></tr></table></figure>
<p><strong>举例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AddOne(x) (x+1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> pi2 = PI * <span class="number">2</span>;    <span class="comment">//pi2 = 6.28</span></span><br><span class="line">pi2 = AddOne(pi2);     <span class="comment">// pi2 = 7.28</span></span><br></pre></td></tr></table></figure>
<p>不过，由于C++增加了内联函数(inline)，实现起来比带参数的宏更方便，这样的宏在C++中已经很少使用了。</p>
<h3 id="宏发生的时机"><a href="#宏发生的时机" class="headerlink" title="宏发生的时机"></a>宏发生的时机</h3><a id="more"></a>
<ol>
<li><p>文件包含（#include命令）</p>
<p> 可以把源程序中的#include 扩展为文件正文，即把包含的.h文件找到并展开到#include 所在处。</p>
</li>
<li><p>条件编译（#ifdef ….  #def …. #endif命令）</p>
<p> 预处理器根据#if和#ifdef等编译命令及其后的条件，将源程序中的某部分包含进来或排除在外，通常把排除在外的语句转换成空行。</p>
</li>
<li><p>宏展开</p>
<p> 预处理器将源程序文件中出现的对宏的引用展开成相应的宏定义，即本文所说的<code>#define</code>的功能，由预处理器来完成。经过预处理器处理的源程序与之前的源程序有所有不同，在这个阶段所进行的工作只是纯粹的替换与展开，没有任何计算功能，所以在学习#define命令时只要能真正理解这一点，这样才不会对此命令引起误解并误用。</p>
</li>
</ol>
<h3 id="宏的特点"><a href="#宏的特点" class="headerlink" title="宏的特点"></a>宏的特点</h3><p>（1）宏名一般用大写，且末尾不加分号。</p>
<p>（2）宏定义的参数是无类型的，不做语法检查，不做表达式求解，只做替换。</p>
<p>（3）宏定义通常在文件的最开头，可以使用</p>
<pre><code><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> 宏名</span></span><br></pre></td></tr></table></figure>
</code></pre>
<p>命令终止宏定义的作用域。</p>
<p>（4）宏定义可以嵌套，但字符串””中永远不包含宏。</p>
<p>（5）宏展开使源程序变长，函数调用不会；宏展开不占运行时间，只占编译时间，函数调用占运行时间（分配内存、保留现场、值传递、返回值）。</p>
<p>（6）函数调用在编译后程序运行时进行，并且分配内存。宏替换在编译前进行，不分配内存。</p>
<p>（7）使用宏可提高程序的通用性和易读性，减少不一致性，减少输入错误和便于修改。例如：数组大小常用宏定义，常量pi常用宏定义。</p>
<h3 id="宏的优点："><a href="#宏的优点：" class="headerlink" title="宏的优点："></a>宏的优点：</h3><ol>
<li><p>提高了程序的可读性，同时也方便进行修改；</p>
</li>
<li><p>提高程序的运行效率：使用带参的宏定义既可完成函数调用的功能，又能避免函数的出栈与入栈操作，减少系统开销，提高运行效率；</p>
</li>
<li><p>宏是由预处理器处理的，通过字符串操作可以完成很多编译器无法实现的功能。比如##连接符。</p>
</li>
</ol>
<h3 id="宏的缺点"><a href="#宏的缺点" class="headerlink" title="宏的缺点"></a>宏的缺点</h3><ol>
<li><p>由于是直接嵌入的，所以代码可能相对多一点；</p>
</li>
<li><p>嵌套定义过多可能会影响程序的可读性，而且很容易出错；</p>
</li>
<li><p>对带参的宏而言，由于是直接替换，并不会检查参数是否合法，存在安全隐患。</p>
</li>
</ol>
<h3 id="常有宏定义"><a href="#常有宏定义" class="headerlink" title="常有宏定义"></a>常有宏定义</h3><ol>
<li><p>防止一个头文件被重复包含</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BODYDEF_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BODYDEF_H</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//头文件内容</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>得到指定地址上的一个字节或字</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM_B( x ) ( *( (byte *) (x) ) )</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM_W( x ) ( *( (word *) (x) ) )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例如：</span></span><br><span class="line"><span class="keyword">int</span> bTest = <span class="number">0x123456</span>;</span><br><span class="line"></span><br><span class="line">byte m = MEM_B((&amp;bTest));<span class="comment">/*m=0x56*/</span></span><br><span class="line"><span class="keyword">int</span> n = MEM_W((&amp;bTest));<span class="comment">/*n=0x3456*/</span></span><br></pre></td></tr></table></figure></li>
<li><p>得到一个field在结构体(struct)中的偏移量</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OFFSETOF( type, field ) ( (size_t) &amp;(( type * ) 0)-&gt; field )</span></span><br></pre></td></tr></table></figure></li>
<li><p>得到一个结构体中field所占用的字节数</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FSIZ( type, field ) sizeof( ((type * ) 0)-&gt;field )</span></span><br></pre></td></tr></table></figure></li>
<li><p>得到一个变量的地址（word宽度）</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> B_PTR( var ) ( (byte * ) (void * ) &amp;(var) )</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W_PTR( var ) ( (word * ) (void * ) &amp;(var) )</span></span><br></pre></td></tr></table></figure></li>
<li><p>将一个字母转换为大写</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#define UPCASE( c ) ( ((c) &gt;= &#x27;&#x27;a&#x27;&#x27; &amp;&amp; (c) &lt;= &#x27;&#x27;z&#x27;&#x27;) ? ((c) - 0x20) : (c) )</span><br></pre></td></tr></table></figure></li>
<li><p>防止溢出的一个方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INC_SAT( val ) (val = ((val)+1 &gt; (val)) ? (val)+1 : (val))</span></span><br></pre></td></tr></table></figure></li>
<li><p>返回数组元素的个数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARR_SIZE( a ) ( sizeof( (a) ) / sizeof( (a[0]) ) )</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用一些宏跟踪调试</p>
</li>
</ol>
<p>ANSI标准说明了五个预定义的宏名。它们是：</p>
<p><code>__LINE__</code>：在源代码中插入当前源代码行号；</p>
<p><code>__FILE__</code>：在源文件中插入当前源文件名；</p>
<p><code>__DATE__</code>：在源文件中插入当前的编译日期</p>
<p><code>__TIME__</code>：在源文件中插入当前编译时间；</p>
<p><code>__STDC__</code>：当要求程序严格遵循ANSI C标准时该标识被赋值为1；</p>
<p><code>__cplusplus</code>：当编写C++程序时该标识符被定义</p>
<h3 id="define中的三个特殊符号：-、-、"><a href="#define中的三个特殊符号：-、-、" class="headerlink" title="define中的三个特殊符号：##、#、#@"></a>define中的三个特殊符号：##、#、#@</h3><p><code>##</code>: x连接y</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Conn(x,y) x##y</span></span><br></pre></td></tr></table></figure>
<p><code>#</code>: 给x加上单引号，结果返回是一个const char</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ToChar(x) #@x</span></span><br></pre></td></tr></table></figure>
<p><code>#@</code>:给x加上一个双引号</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ToString(x) #x</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7下安装boost</title>
    <url>/linux/install_boost/</url>
    <content><![CDATA[<h2 id="CentOS下安装boost"><a href="#CentOS下安装boost" class="headerlink" title="CentOS下安装boost"></a>CentOS下安装boost</h2><h3 id="获取boost"><a href="#获取boost" class="headerlink" title="获取boost"></a>获取boost</h3><p>在<a href="https://www.boost.org/">boost</a>官网可以了解和下载你要安装的boost版本。</p>
<h3 id="安装boost"><a href="#安装boost" class="headerlink" title="安装boost"></a>安装boost</h3><a id="more"></a>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://dl.bintray.com/boostorg/release/1.67.0/source/boost_1_67_0.tar.gz</span><br><span class="line">tar -zxvf boost_1_67_0.tar.gz</span><br><span class="line">cd boost_1_67_0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行.sh文件，使用--<span class="built_in">help</span>查看更多帮助</span></span><br><span class="line">./bootstrap.sh --help</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 也可以指定安装目录，例如</span></span><br><span class="line">./bootstrap.sh --prefix=/usr/local/include/boost</span><br><span class="line"><span class="meta">#</span><span class="bash"> 本人是安装在默认路径下，默认路径是/usr/<span class="built_in">local</span>/lib</span></span><br><span class="line">./bootstrap.sh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装boost</span></span><br><span class="line">sudo ./b2 install</span><br></pre></td></tr></table></figure>
<h3 id="安装boost-build"><a href="#安装boost-build" class="headerlink" title="安装boost.build"></a>安装boost.build</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /boost/tools/build</span><br><span class="line">sudo ./bootstrap.sh</span><br><span class="line">sudo ./b2 install --prefix=/usr/local/include/boost</span><br></pre></td></tr></table></figure>
<h3 id="立即生效"><a href="#立即生效" class="headerlink" title="立即生效"></a>立即生效</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ldconfig</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>BigData</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++、Boost</tag>
      </tags>
  </entry>
  <entry>
    <title>简述URL</title>
    <url>/web_programming/url_intro/</url>
    <content><![CDATA[<h2 id="简述URL"><a href="#简述URL" class="headerlink" title="简述URL"></a>简述URL</h2><h3 id="URL说明"><a href="#URL说明" class="headerlink" title="URL说明"></a>URL说明</h3><p><strong>统一资源定位符（URL）</strong> 是用于完整地描述Internet上网页和其他资源的地址的一种标识方法。</p>
<p>Internet上的每一个网页都具有一个唯一的名称标识，通常称之为URL地址，这种地址可以是本地磁盘，也可以是局域网上的某一台计算机，更多的是Internet上的站点。简单地说，URL就是Web地址，俗称“网址”。</p>
<p>URI方案集，包含如何访问Internet上的资源的明确指令。</p>
<p>URL是统一的，因为它们采用相同的基本语法，无论寻址哪种特定类型的资源（网页、新闻组）或描述通过哪种机制获取该资源。</p>
<p>对于Internet服务器或万维网服务器上的目标文件，可以使用“统一资源定位符 (URL)”地址（该地址以“http://”开始）。Web服务器使用“超文本传输协议(HTTP)”，一种“幕后的”Internet 信息传输协议。例如，<a href="http://www.microsoft.com/">http://www.microsoft.com/</a> 为Microsoft网站的万维网URL地址。</p>
<h3 id="URL格式"><a href="#URL格式" class="headerlink" title="URL格式"></a>URL格式</h3><a id="more"></a>
<ol>
<li><p>URL的组成</p>
<p>protocol://hostname[:port]/path/[;parameters][?query]#fragment</p>
</li>
<li><p>格式说明</p>
</li>
</ol>
<p>  <strong>protocol:</strong>　指定使用的传输协议。protocol属性的有效方案名称：</p>
<pre><code>  * http通过HTTP访问该资源协议,是最常用的，也是目前WWW中应用最广的协议。格式：`http://`

  * file资源是本地计算机上的文件。格式：`file://`

  * ftp通过FTP访问资源。格式：`ftp://`

  * gopher通过Gopher协议访问该资源。

  * https通过安全的HTTPS访问该资源。 格式:`https://`

  * mailto资源为电子邮件地址，通过SMTP访问。 格式:`mailto:`

  * MMS通过支持MMS（流媒体）协议的播放该资源。（代表软件：Windows Media Player）格式:`MMS://`

  * ed2k通过支持ed2k（专用下载链接）协议的P2P软件访问该资源。（代表软件：电驴）格式:`ed2k://`

  * Flashget通过支持Flashget:（专用下载链接）协议的P2P软件访问该资源。（代表软件：快车） 格式:`Flashget://`

  * thunder通过支持thunder（专用下载链接）协议的P2P软件访问该资源。（代表软件：迅雷） 格式:`thunder://`

  * news通过NNTP访问该资源。

  * tencent通过支持tencent(专用聊天连接) 协议和用户对话。(代表软件：QQ、TM) 格式:`tencent://message/?uin=号码&amp;Site=&amp;Menu=yes`

  * msnim通过支持msnim(专用聊天连接) 协议和用户对话。(代表软件：MSN、WLM) 格式:`msnim:chat?contact=邮箱地址`
</code></pre>
<p>  <strong>hostname(主机名)</strong> ：是指存放资源的服务器的域名系统(DNS)主机名或IP地址。有时，在主机名前也可以包含连接到服务器所需的用户名和密码（格：username:password）。</p>
<p>  <strong>port(端口号)</strong> ：整数，可选，省略时使用方案的默认端口，各种传输协议都有默认的端口号，如http的默认端口为80。如果输入时省略，则使用默认端口号。有时候出于安全或其他考虑，可以在服务器上对端口进行重定义，即采用非标准端口号，此时，URL中就不能省略端口号这一项。</p>
<p>  <strong>path(路径)</strong> ：由零或多个“/”符号隔开的字符串，一般用来表示主机上的一个目录或文件地址。</p>
<p>  <strong>;parameters(参数)</strong> : 这是用于指定特殊参数的可选项。</p>
<p>  **?query(查询)**： 可选，用于给动态网页（如使用CGI、ISAPI、PHP/JSP/ASP/ASP.NET等技术制作的网页）传递参数，可有多个参数，用“&amp;”符号隔开，每个参数的名和值用“=”符号隔开。</p>
<p>  <strong>fragment</strong> ： 信息片断，字符串，用于指定网络资源中的片断。例如一个网页中有多个名词解释，可使用fragment直接定位到某一名词解释。</p>
<p>  注意，Windows 主机不区分URL大小写，但是，Unix/Linux 主机区分大小写。下面列表是常见的URL中定位和标识的服务或文件：</p>
<pre><code>* http：文件在WEB服务器。

* file：文件在您自己的局部系统或匿名服务器上

* ftp：文件在FTP服务器上

* gopher：文件在gopher服务器上

* wais：文件在wais服务器上

* news：文件在Usenet服务器上

* telnet：连接到一个支持Telnet远程登录的服务器上
</code></pre>
<h3 id="URL转发"><a href="#URL转发" class="headerlink" title="URL转发"></a>URL转发</h3><p>所谓URL转发，是通过服务器的特殊设置，将访问您当前域名的用户引导到您指定的另一个网络地址。例如，URL转发可以让用户在访问<a href="http://www.abc.com/">http://www.abc.com</a> 时，自动转向访问到一个您自己指定的网址“<a href="http://www.123.com/">http://www.123.com</a> ”，URL转发功能是万网提供的域名注册后的增值服务。</p>
]]></content>
      <categories>
        <category>Web Programming</category>
      </categories>
      <tags>
        <tag>URL、Web Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>简述HTTP协议</title>
    <url>/web_programming/http_protocol/</url>
    <content><![CDATA[<h2 id="简述HTTP协议"><a href="#简述HTTP协议" class="headerlink" title="简述HTTP协议"></a>简述HTTP协议</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>HTTP（超文本传输协议）是一个基于请求与响应模式、无状态、应用层的协议，常基于TCP的链接方式，1.1版本中给出的一种持续连接的机制，绝大多数的Web开发，都是构建在HTTP之上的Web应用。</p>
<p>超文本传输​​协议（HTTP）的目的是使客户端和服务器之间的通信。</p>
<p>HTTP作品作为客户端和服务器之间的请求 - 响应协议。</p>
<p>Web浏览器可能是客户端，托管网站可能是服务器的计算机上的应用程序。</p>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>分别由：请求头、消息头、请求正文</p>
<h3 id="常用的HTTP方法"><a href="#常用的HTTP方法" class="headerlink" title="常用的HTTP方法"></a>常用的HTTP方法</h3><a id="more"></a>
<p><strong>GET：</strong> 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器。</p>
<p><strong>POST：</strong> 用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。</p>
<p><strong>PUT：</strong> 传输文件，报文主体中包含文件内容，保存到对应URI位置。</p>
<p><strong>HEAD：</strong> 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。</p>
<p><strong>DELETE：</strong> 删除文件，与PUT方法相反，删除对应URI位置的文件。</p>
<p><strong>OPTIONS：</strong> 查询相应URI支持的HTTP方法。</p>
<h3 id="GET方法"><a href="#GET方法" class="headerlink" title="GET方法"></a>GET方法</h3><p>得到的是用于从指定的资源请求数据。</p>
<p><strong>GET</strong> 是最常见的HTTP方法之一。</p>
<p>注意查询字符串（名称/值对）的GET请求的URL发送：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;api&#x2F;index.html?name1&#x3D;value1&amp;name2&#x3D;value2</span><br></pre></td></tr></table></figure>
<p>** 在GET请求其他一些注意事项：**</p>
<ul>
<li>GET请求可以被缓存</li>
<li>GET请求留在浏览器历史记录</li>
<li>GET请求可以添加书签</li>
<li>获取有关敏感数据处理请求时，绝对不能用</li>
<li>GET请求有长度限制</li>
<li>GET请求仅用于请求数据（不能修改）</li>
</ul>
<h3 id="POST方法"><a href="#POST方法" class="headerlink" title="POST方法"></a>POST方法</h3><p>POST用于将数据发送到服务器，创建/更新资源。</p>
<p>发送到与POST服务器的数据被存储在HTTP请求的请求体：</p>
<p>POST /test/demo_form.php HTTP/1.1<br>Host: w3schools.com<br>name1=value1&amp;name2=value2<br>POST是最常见的HTTP方法之一。</p>
<p>** 在POST请求的一些其他注意事项：**</p>
<ul>
<li>POST请求不会被缓存</li>
<li>POST请求不留在浏览器历史记录</li>
<li>POST请求不能被收藏</li>
<li>POST请求对数据长度没有限制</li>
</ul>
<h3 id="PUT方法"><a href="#PUT方法" class="headerlink" title="PUT方法"></a>PUT方法</h3><p>PUT用于将数据发送到服务器，创建/更新资源。</p>
<p>POST和PUT之间的区别是，PUT请求是幂等。也就是说，调用相同PUT请求多次，总是会产生相同的结果。相比之下，重复调用一个POST请求有多次创建相同的资源的副作用。</p>
<h3 id="HEAD方法"><a href="#HEAD方法" class="headerlink" title="HEAD方法"></a>HEAD方法</h3><p>HEAD几乎是相同的GET，但是没有响应体。</p>
<p>换句话说，如果GET /用户返回用户的列表，然后头/用户会提出同样的要求，但不会返回用户列表。</p>
<p>HEAD请求是检查什么的GET请求实际上将一个GET请求之前返回有用 - 下载大型文件或响应体之前等。</p>
<h3 id="Delete方法"><a href="#Delete方法" class="headerlink" title="Delete方法"></a>Delete方法</h3><p>Delete方法删除指定的资源。</p>
<h3 id="OPTIONS方法"><a href="#OPTIONS方法" class="headerlink" title="OPTIONS方法"></a>OPTIONS方法</h3><p>选项方法描述了目标资源的通讯选择。</p>
<h3 id="GET和POST方法的区别"><a href="#GET和POST方法的区别" class="headerlink" title="GET和POST方法的区别"></a>GET和POST方法的区别</h3><ol>
<li><p><code>GET</code>重点在从服务器上获取资源，<code>POST</code>重点在向服务器发送数据；</p>
</li>
<li><p><code>GET</code>传输数据是通过URL请求，以field（字段）= value的形式，置于URL后，并用”?”连接，多个请求数据间用”&amp;”连接如<a href="http://127.0.0.1/Test/login.action?name=admin&amp;password=admin">http://127.0.0.1/Test/login.action?name=admin&amp;password=admin</a> ，这个过程用户是可见的；<code>POST</code>传输数据通过HTTP的post机制，将字段与对应值封存在请求实体中发送给服务器，这个过程对用户是不可见的；</p>
</li>
<li><p><code>GET</code>传输的数据量小，因为受URL长度限制，但效率较高；<code>POST</code>可以传输大量数据，所以上传文件时只能用post方式；</p>
</li>
<li><p><code>GET</code>是不安全的，因为URL是可见的，可能会泄露私密信息，如密码等；<code>POST</code>较get安全性较高；</p>
</li>
<li><p><code>GET</code>方式只能支持ASCII字符，向服务器传的中文字符可能会乱码;<code>POST</code>支持标准字符集，可以正确传递中文字符。</p>
</li>
</ol>
<h3 id="HTTP请求报文的与响应报文格式"><a href="#HTTP请求报文的与响应报文格式" class="headerlink" title="HTTP请求报文的与响应报文格式"></a>HTTP请求报文的与响应报文格式</h3><h4 id="请求报文三部分："><a href="#请求报文三部分：" class="headerlink" title="请求报文三部分："></a>请求报文三部分：</h4><ol>
<li><p>请求行：包含HTTP版本、状态码、状态码的原因短语</p>
</li>
<li><p>请求首部字段</p>
</li>
<li><p>请求内容实体</p>
</li>
</ol>
<h4 id="响应报文三部分："><a href="#响应报文三部分：" class="headerlink" title="响应报文三部分："></a>响应报文三部分：</h4><ol>
<li><p>状态行：包含HTTP版本、状态码、状态码的原因短语</p>
</li>
<li><p>响应首部字段</p>
</li>
<li><p>响应内容实体</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Web Programming</category>
      </categories>
      <tags>
        <tag>Web Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/python/regular_expression/</url>
    <content><![CDATA[<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="什么是正则表达式"><a href="#什么是正则表达式" class="headerlink" title="什么是正则表达式"></a>什么是正则表达式</h3><p>正则表达式是用字符序列来描述复杂查询条件的方式。</p>
<h3 id="匹配所有的数字"><a href="#匹配所有的数字" class="headerlink" title="匹配所有的数字"></a>匹配所有的数字</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^[0-9]+$</span><br></pre></td></tr></table></figure>
<p>表达式说明：</p>
<ul>
<li><code>^</code> - 表示一行的开始</li>
<li><code>[0-9]</code> - 匹配介于0-9中间的任何数字；也可以用<code>\d</code>来代替</li>
<li><code>+</code> - 匹配前面表达式的一个或者多个实例</li>
<li><code>$</code> - 表示一行的结束</li>
</ul>
<h3 id="不同语言实现正则表达式"><a href="#不同语言实现正则表达式" class="headerlink" title="不同语言实现正则表达式"></a>不同语言实现正则表达式</h3><h4 id="C-语言下实现"><a href="#C-语言下实现" class="headerlink" title="C#语言下实现"></a>C#语言下实现</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Text.RegularExpressions;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">RegexExample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">FileRegexExample</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="built_in">string</span> text = File.ReadAllText(<span class="string">@&quot;./test.txt&quot;</span>, Encoding.UTF8);</span><br><span class="line">            Regex regex = <span class="keyword">new</span> Regex(<span class="string">&quot;^[0-9]+$&quot;</span>, RegexOptions.Multiline);</span><br><span class="line">            MatchCollection mc = regex.Matches(text);</span><br><span class="line">            <span class="keyword">var</span> matches = mc.OfType&lt;Match&gt;().Select(m =&gt; m.Value).ToArray();</span><br><span class="line">            Console.WriteLine(<span class="built_in">string</span>.Join(<span class="string">&quot; &quot;</span>, matches));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Python语言下实现"><a href="#Python语言下实现" class="headerlink" title="Python语言下实现"></a>Python语言下实现</h4><a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> line:</span><br><span class="line">  testString = line.read()</span><br><span class="line">  regex = re.<span class="built_in">compile</span>(<span class="string">r&#x27;^([0-9]+)$&#x27;</span>, re.MULTILINE)</span><br><span class="line">  result = regex.findall(testString)</span><br><span class="line">  print(result)</span><br></pre></td></tr></table></figure>
<h4 id="C-语言下实现-1"><a href="#C-语言下实现-1" class="headerlink" title="C++语言下实现"></a>C++语言下实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">ifstream <span class="title">t</span><span class="params">(<span class="string">&quot;test.txt&quot;</span>)</span></span>;</span><br><span class="line">  <span class="built_in">stringstream</span> buffer;</span><br><span class="line">  buffer &lt;&lt; t.rdbuf();</span><br><span class="line">  <span class="built_in">string</span> testString = buffer.str();</span><br><span class="line"></span><br><span class="line">  <span class="function">regex <span class="title">numberLineRegex</span><span class="params">(<span class="string">&quot;(^|\n)([0-9]+)($|\n)&quot;</span>)</span></span>;</span><br><span class="line">  <span class="function">sregex_iterator <span class="title">it</span><span class="params">(testString.begin(), testString.end(), numberLineRegex)</span></span>;</span><br><span class="line">  sregex_iterator it_end;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(it != it_end) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; it -&gt; str();</span><br><span class="line">    ++it;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="匹配年份"><a href="#匹配年份" class="headerlink" title="匹配年份"></a>匹配年份</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\b(19|20)\d&#123;2&#125;\b</span><br></pre></td></tr></table></figure>
<p>表达式说明：</p>
<ul>
<li><code>\b</code> - 单词边界</li>
<li><code>(19|20)</code> - 匹配19或者20数字</li>
<li><code>\d&#123;2&#125;</code> - 两位数字，与<code>[0-9]&#123;2&#125;</code>相似</li>
<li><code>\b</code> - 单词边界</li>
</ul>
<h3 id="匹配时间"><a href="#匹配时间" class="headerlink" title="匹配时间"></a>匹配时间</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\b([01]?[0-9]|2[0-3]):([0-5]\d)\b</span><br></pre></td></tr></table></figure>
<ul>
<li><code>\b</code> - 单词边界</li>
<li><code>[01]</code> - 0 或者 1</li>
<li><code>?</code> - 表示前面的条件或者模式是可选的</li>
<li><code>[0-9]</code> - 匹配0-9的所有数字</li>
<li><code>|</code> - 或者</li>
<li><code>2[0-3]</code> - 20、21、22、23</li>
<li><code>:</code> - 匹配<code>:</code>字符</li>
<li><code>[0-5]</code> - 匹配0-5之间的数字</li>
<li><code>\d</code> - 匹配0-9之间的所有数字</li>
<li><code>\b</code> - 单词边界</li>
</ul>
<h3 id="匹配日期"><a href="#匹配日期" class="headerlink" title="匹配日期"></a>匹配日期</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\b(0?[1-9]|[12]\d|3[01])([\&#x2F;\-])(0?[1-9]|1[012])\2(\d&#123;4&#125;)</span><br></pre></td></tr></table></figure>
<p><code>DAY/MONTH/YEAR </code>表达式说明：</p>
<ul>
<li><code>(0?[1-9]|[12]\d|3[01])</code> - 匹配1-31之间的任何数字，首字符可以是0</li>
<li><code>([\/\-])</code> - 匹配所有的分隔符<code>/</code>或者<code>-</code></li>
<li><code>(0?[1-9]|1[012])</code> - 匹配所有的1-12之间的字符</li>
<li><code>\2</code> - 匹配分组</li>
<li><code>\d&#123;4&#125;</code> - 匹配任何四位数字</li>
</ul>
<h3 id="验证邮箱"><a href="#验证邮箱" class="headerlink" title="验证邮箱"></a>验证邮箱</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^[^@\s]+@[^@\s]+\.\w&#123;2,6&#125;$</span><br></pre></td></tr></table></figure>
<p>表达式说明：</p>
<ul>
<li><code>^</code> - 输入开始</li>
<li><code>[^@\s]</code> - 匹配除了所有的字符除了<code>@</code>和空格<code>\s</code></li>
<li><code>+</code> - 1+次</li>
<li><code>@</code> - 匹配<code>@</code>标志</li>
<li><code>[^@\s]+</code> - 匹配除了所有的字符除了<code>@</code>和空格<code>\s</code>； 1+次</li>
<li><code>\.</code> - 匹配’.’字符</li>
<li><code>\w&#123;2,6&#125;</code> - 匹配任何字符，2-6次</li>
<li><code>$</code> - 输入结束</li>
</ul>
<h3 id="匹配URL"><a href="#匹配URL" class="headerlink" title="匹配URL"></a>匹配URL</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(https?:\&#x2F;\&#x2F;)(www\.)?(?&lt;domain&gt;[-a-zA-Z0-9@:%._\+~#&#x3D;]&#123;2,256&#125;\.[a-z]&#123;2,6&#125;)(?&lt;path&gt;\&#x2F;[-a-zA-Z0-9@:%_\&#x2F;+.~#?&amp;&#x3D;]*)?</span><br></pre></td></tr></table></figure>
<p>表达式说明：</p>
<ul>
<li><code>(https?:\/\/)</code> - 匹配http或者https</li>
<li><code>(www\.)?</code> - 匹配’www’前缀（可选）</li>
<li><code>(?&lt;domain&gt;[-a-zA-Z0-9@:%._\+~#=]&#123;2,256&#125;</code> - 匹配有效的域名</li>
<li><code>\.[a-z]&#123;2,6&#125;)</code> - 匹配域名后缀</li>
<li><code>(?&lt;path&gt;\/[-a-zA-Z0-9@:%_\/+.~#?&amp;=]*)?</code> - 匹配URL路径(/posts), 查询字符条件(?limit=1), and/or 文件后缀(.html), 全可选.</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL语言</title>
    <url>/postgresql/sql_laguage/</url>
    <content><![CDATA[<h2 id="SQL语言"><a href="#SQL语言" class="headerlink" title="SQL语言"></a>SQL语言</h2><p>这部分描述了SQL语言在PostgreSQL中的使用。我们从描述SQL的基础语法开始，然后解释如何创建结构来保存数据，如何填充数据库以及如何查询它。中间部分列出了用于SQL命令的可用数据类型和函数。剩余部分对于优化数据库以获得最佳性能非常重要。</p>
<p>这个部分的信息是被安排的，这样一个新手用户可以跟随它开始结束以获得对主题的充分理解，而不必过多的引用。这些章节的内容是独立的，所以高级用户可以在选择的时候单独阅读章节。这部分的信息以一种叙事的方式呈现在主题单元中。读者在寻找特定命令的完整描述时，应该看到第VI部分。</p>
<p>读者在这一部分应该知道如何连接到PostgreSQL数据库并发出SQL命令。不熟悉这些问题的读者会被鼓励阅读第一部分。SQL命令通常使用PostgreSQL交互式终端<code>psql</code>来输入，但是其他具有类似功能的程序也可以使用。</p>
<h3 id="SQL语法"><a href="#SQL语法" class="headerlink" title="SQL语法"></a>SQL语法</h3><p>本章描述SQL语法。它为理解以下章节奠定了基础，接下来的章节将详细介绍如何应用SQL命令来定义和修改数据。</p>
<p>我们还建议已经熟悉SQL的用户仔细阅读本章，因为它包含了一些在SQL数据库中不一致地实现的规则和概念，或者是特定于PostgreSQL的。</p>
<h4 id="词汇结构"><a href="#词汇结构" class="headerlink" title="词汇结构"></a>词汇结构</h4><a id="more"></a>
<p>SQL输入由一系列命令组成。命令由一系列<em>标记</em>组成，以分号(“;”)终止。输入流的末尾也终止一个命令。哪些标记是有效的，取决于特定命令的语法。</p>
<p><strong>标记</strong> 可以是<em>关键字</em>、<em>标识符</em>、<em>引用标识符</em>、<em>文字(或常量)<em>或</em>特殊字符符号</em>。标记通常由空格(空格、制表符、换行符)分隔，但如果没有歧义(通常只有在特殊字符与其他token类型相邻的情况下)，则不需要。</p>
<p>例如，以下是(语法上)有效的SQL输入:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> MY_TABLE;</span><br><span class="line">UPDATE MY_TABLE <span class="keyword">SET</span> A <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> MY_TABLE <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="string">&#x27;hi there&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>这是三个命令的序列，每一行代表一个命令(尽管这不是必需的；可以在一行上执行多个命令，并且可以有效地跨行分隔命令）。</p>
<p>此外，可以在SQL输入中进行<em>注释</em> 。它们不是tokens，实际上相当于空格。</p>
<p>对于标识命令、操作数或参数SQL语法并不十分一致。最初的几个标记通常是命令名，因此在上面的示例中，我们通常会提到<code>SELECT</code>、<code>UPDATE</code>和<code>INSERT</code>命令。但是，<code>UPDATE</code>命令总是需要一个<code>SET</code>标记出现在某个位置，而<code>INSERT</code>的特殊变量也需要<code>VALUES</code>才能完成。<a href="">详细语法规则</a> 分描述了每个命令的精确语法规则。</p>
<ol>
<li><p>标识符和关键字</p>
<p> 在上面的示例中，诸如<code>SELECT</code>、<code>UPDATE</code>或<code>VALUES</code>之类的标记是<em>关键字</em> 的示例，也就是说，在SQL语言中具有固定含义的单词。MY_TABLE和A是<em>标识符</em> 的示例。它们根据所使用的命令来标识表、列或其他数据库对象的名称。因此，它们有时被简单地称为“名字”。关键字和标识符具有相同的语法结构，这意味着人们不知道标记是标识符还是不懂语言的关键字。关键字的完整列表可以在<a href="https://www.postgresql.org/docs/10/static/sql-keywords-appendix.html">附录C</a> 中找到。</p>
<p> SQL标识符和关键字必须以字母开头(字母a-z，但同时还要有字母和非拉丁字母)或下划线(_)。标识符或关键字中的后续字符可以是字母、下划线、数字(0-9)或美元符号($)。注意，根据SQL标准的字母，标识符不允许使用美元符号，因此它们的使用可能会使应用程序变得更不轻便。SQL标准不会定义一个包含数字或开始或以下划线开头的关键词，因此，这种表单的标识符可以避免与将来的标准扩展冲突。</p>
<p> 该系统仅使用标识符的<code>NAMEDATALEN-1</code>字节；可以在命令中编写较长的名称，但它们将被截断，默认情况下，<em>NAMEDATALEN</em> 是64，因此最大标识符长度为63字节。如果这个限制是有问题的，可以通过更改<code>src/include/pg_config_manul.h</code>中的<strong>NAMEDATALEN</strong> 常量来提高。</p>
<p> 关键字和未引用的标识符是大小写不敏感的。因此:</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">UPDATE MY_TABLE <span class="keyword">SET</span> A <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p> 可以等价地写成:</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">uPDaTE my_TabLE <span class="keyword">SeT</span> a <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p> 一种常用的惯例是在大写字母和小写字母中写上关键词，例如:</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">UPDATE my_table <span class="keyword">SET</span> a <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p> 还有第二种标识符:<em>分隔标识符或引用标识符</em>。它是通过在双引号(“)中包含任意字符序列来形成的。分隔符始终是标识符，而不是关键字。因此，“select”可以用来引用一个名为“select”的列或表，而未引用的select将被当作一个关键字，因此当使用表或列名时，会引发解析错误。这个例子可以用引号来表示:</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">UPDATE &quot;my_table&quot; <span class="keyword">SET</span> &quot;a&quot; <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p> 引用的标识符可以包含任何字符，除了代码为零的字符。(包括双引号，两个双引号)这允许构造表或列名，否则将不可能，例如包含空格或符号的字段。长度限制仍然适用。</p>
<p> 引用的标识符的一个变量允许包括由其代码点标识的转义Unicode字符。此变量从<code>u&amp;</code>(大小写U后面跟着ampersand)开始，然后在打开双引号之前，在中间没有任何空格，例如u&amp;“foo”。(注意，这会给操作人员带来歧义。使用周围的空间来避免这个问题。在引号内，可以通过写反斜杠来指定Unicode字符，后跟4个十六进制代码点数或反斜杠，后跟一个加号，后跟一个6位数的十六进制代码点。例如，标识符“数据”可以写成。</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">U<span class="operator">&amp;</span>&quot;d\0061t\+000061&quot;</span><br></pre></td></tr></table></figure>
<p> 下面这个不那么简单的例子是用古希腊字母写的俄文“slon”(大象):</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">U<span class="operator">&amp;</span>&quot;\0441\043B\043E\043D&quot;</span><br></pre></td></tr></table></figure>
<p> 如果需要一个不同的转义字符，那么可以在字符串后面使用<code>UESCAPE</code>子语句指定它，例如:</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">U<span class="operator">&amp;</span>&quot;d!0061t!+000061&quot; <span class="keyword">UESCAPE</span> <span class="string">&#x27;!&#x27;</span></span><br></pre></td></tr></table></figure>
<p> 转义字符可以是任何单个字符，而不仅仅是十六进制数字、加号、单引号、双引号或空格字符。注意，转义字符是用单引号写的，而不是双引号。</p>
<p> 要在标识符中包含转义字符，请写两次。</p>
<p> 只有当服务器编码为UTF8时，Unicode转义语法才起作用。当使用其他服务器编码时，可以指定ASCII范围内的代码点(最高为\007F)。4位和6位的形式都可以用来指定UTF-16的代理对，用比U+FFFF更大的代码点组成字符，尽管6位数字形式的可用性使得这没有必要。(代理对并不是直接存储的，而是将其组合成一个代码点，然后用UTF-8编码。)</p>
<p> 引用一个标识符也会使它区分大小写，而未引用的名称总是被折叠到小写。例如，标识符FOO、Foo和“Foo”在PostgreSQL中被认为是相同的，但是“Foo”和“FOO”不同于这三者和彼此。(在PostgreSQL中，未引用的名称的折叠是与SQL标准不兼容的，这意味着未引用的名称应该折叠到大写。因此，foo应该等同于“FOO”而不是“foo”。如果您想编写可移植的应用程序，建议您总是引用一个特定的名称，或者永远不要引用它。</p>
</li>
<li><p>常量</p>
<p> PostgreSQL中有三种隐含类型常量:字符串、位串和数字。常量还可以使用显式类型指定，这可以使系统更准确地表示和更有效地处理。下面的小节将讨论这些替代方案。</p>
<ul>
<li><p><strong>字符串常量</strong></p>
<p>  SQL中的字符串常量是由单引号(‘)绑定的任意字符序列，例如<code>&#39;This is A string&#39;</code>。要在一个字符串常量中包含一个单引号字符，可以写两个相邻的单引号，例如，’Dianne’’ s horse’。请注意，这与双引号字符(“)不一样。</p>
<p>  两个仅由空格分隔的字符串常量，其中至少有一条新行被连接并有效地处理，就像字符串被写成一个常量一样。例如:</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;foo&#x27;</span></span><br><span class="line"><span class="string">&#x27;bar&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>  等价于:</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;foobar&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>  但是：</p>
  <figure class="highlight"><table><tr><td class="code"><pre><span class="line">SELECT &#x27;foo&#x27;      &#x27;bar&#x27;;</span><br></pre></td></tr></table></figure>
<p>  这是无效的语法。(这有点奇怪的行为是由SQL指定的；PostgreSQL遵循标准。）</p>
</li>
<li><p><strong>带有C风格的字符串常量</strong></p>
<p>  PostgreSQL还接受“escape”字符串常量，这是对SQL标准的扩展。一个转义字符串常数是通过写字母<code>E</code>(大写或小写)来指定的，就在开头的单引号之前，例如，<code>E&#39;foo</code>。(当在一行中继续执行一个转义字符串时，在第一个开头引用之前写E)。在一个转义字符串中，一个反斜杠字符()开始一个类似于c的反斜杠转义序列，其中反斜杠和跟随字符的组合表示一个特殊的字节值，<strong>如表2.1所示</strong>。</p>
<p>  <strong>表2.1反斜杠转义序列</strong></p>
  <table>
  <td>**反斜杠转义序列**</td> <td>**说明**</td>
  <tr>
  <td>\b</td><td>backspace</td>
  </tr>
  <tr>
  <td>\f</td><td>form feed</td>
  </tr>
  <tr>
  <td>\n</td><td>newline</td>
  </tr>
  <tr>
  <td>\r</td><td>carriage return</td>
  </tr>
  <tr>
  <td>\t</td><td>tab</td>
  </tr>
  <tr>
  <td>\o,\oo,\ooo(o = 0 - 7)</td><td>octal byte value</td>
  </tr>
  <tr>
  <td>\xh,\xhh(h = 0 - 9, A - F)</td><td>hexadecimal byte value</td>
  </tr>
  <tr>
  <td>\uxxxx,\Uxxxxxxxx(x = 0 - 9, A - F)</td><td>16 or 32bit hexadecimal Unicode character value</td>
  </tr>
  </table>
  在反斜杠后面的任何其他字符都是按字面意思执行的。因此，要包含反斜杠字符，可以写两个反斜杠(`\\`)。另外，一个单引号可以包含在一个转义字符串中，除了正常的方式外，还可以写`\\`。

<p>  你的职责是创建的字节序列，特别是在使用八进制或十六进制转义时，在服务器字符集编码中组成有效的字符。当服务器编码为UTF-8时，则应该使用上节中解释的Unicode转义或替代的Unicode转义语法。(另一种方法是手工编写UTF-8编码，并将字节写出来，这将非常麻烦。)</p>
<p>  只有当服务器编码为UTF8时，Unicode转义语法才有效。当使用其他服务器编码时，只能指定ASCII范围内的代码点(最高为\u007F)。4位和8位的形式都可以用来指定UTF-16代理对，以比U+FFFF更大的代码点组成字符，尽管8位数字形式的可用性使得这没有必要。(当服务器编码为UTF8时使用代理对时，首先将它们组合成一个单独的代码点，然后用UTF-8编码。)</p>
<p>  代码为0的字符不能在字符串常量中。</p>
</li>
<li><p><strong>使用Unicode转义的字符串常量</strong></p>
<p>  PostgreSQL还支持另一种用于字符串的转义语法，它允许通过代码指定任意的Unicode字符。一个Unicode的转义字符串常量从u&amp;(上或小写字母U后面跟着ampersand)开始，在引号前面没有空格，例如u&amp;’ foo。(注意，这会给操作人员带来歧义。使用周围的空间来避免这个问题。在引号内，可以通过写反斜杠来指定Unicode字符，后跟4个十六进制代码点数或反斜杠，后跟一个加号，后跟一个6位数的十六进制代码点。例如，字符串’data’可以写成。</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">U<span class="operator">&amp;</span><span class="string">&#x27;d\0061t\+000061&#x27;</span></span><br></pre></td></tr></table></figure>
<p>  下面这个不那么简单的例子是用古希腊写的俄文“slon”(大象):</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">U<span class="operator">&amp;</span><span class="string">&#x27;\0441\043B\043E\043D&#x27;</span></span><br></pre></td></tr></table></figure>
<p>  如果需要一个不同的转义字符，那么可以在字符串后面使用<code>UESCAPE</code>子语句指定它，例如:</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">U<span class="operator">&amp;</span><span class="string">&#x27;d!0061t!+000061&#x27;</span> <span class="keyword">UESCAPE</span> <span class="string">&#x27;!&#x27;</span></span><br></pre></td></tr></table></figure>
<p>  转义字符可以是任何单个字符，而不是十六进制数字、加号、单引号、双引号或空格字符。</p>
<p>  只有当服务器编码为UTF8时，Unicode转义语法才起作用。当使用其他服务器编码时，可以指定ASCII范围内的代码点(最高为\007F)。4位和6位的形式都可以用来指定UTF-16的代理对，用比U+FFFF更大的代码点组成字符，尽管6位数字形式的可用性使得这没有必要。(当服务器编码为UTF8时使用代理对时，首先将它们组合成一个单独的代码点，然后用UTF-8编码。)</p>
<p>  此外，只有当配置参数<a href="https://www.postgresql.org/docs/10/static/runtime-config-compatible.html#GUC-STANDARD-CONFORMING-STRINGS">standard_conforming_strings</a>打开时，字符串常量的Unicode转义语法才会起作用。这是因为否则这种语法会使解析SQL语句的客户机感到迷惑，从而导致SQL注入和类似的安全问题。如果将参数设置为off，则将使用错误消息拒绝此语法。</p>
<p>  要在字串中包含转义字符，请写两次。</p>
</li>
<li><p><strong>Dollar-quoted字符串常量</strong></p>
<p>  虽然指定字符串常量的标准语法通常很方便，但是当所需的字符串包含许多单引号或反斜杠时，就很难理解了，因为每个字符串都必须加倍。为了在这种情况下允许更可读的查询，PostgreSQL提供了另一种方法，称为“引用美元”，以编写字符串常量。一个美元引用的字符串常量由一个美元符号($)组成，一个可选的零或多个字符的“标记”，另一个美元符号，组成字符串内容的任意字符序列，一个美元符号，开始这一美元报价的相同标签，和一个美元符号。例如，这里有两种不同的方法来指定字符串“Dianne的马”，使用<code>$</code>引用:</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$$Dianne<span class="string">&#x27;s horse$$</span></span><br><span class="line"><span class="string">$SomeTag$Dianne&#x27;</span>s horse$SomeTag$</span><br></pre></td></tr></table></figure>
<p>  注意，在美元引用的字符串中，可以使用单引号而不需要转义。事实上，一个美元引用的字符串中没有任何字符被转义:字符串内容总是按字面意思写的。反斜杠并不是特别的，美元符号也不是特别的，除非它们是与开始标签匹配的序列的一部分。</p>
<p>  通过在每个嵌套级别上选择不同的标记，可以使用美元引用的字符串常量。这在编写函数定义时最常用。例如:</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$<span class="keyword">function</span>$</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">RETURN</span> ($<span class="number">1</span> <span class="operator">~</span> $q$[\t\r\n\v\\]$q$);</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$<span class="keyword">function</span>$</span><br></pre></td></tr></table></figure>
<p>  在这里，序列<code>$q$[\t\r\n\v\\]$q$</code>表示一个美元引用的字符串<code>[\t\r\n\v\\]</code>。但是由于这个序列与外部美元的函数值不匹配，所以它只是在外部字符串的范围内的一些字符。</p>
<p>  标签，如果有的话，一个美元引用的字符串遵循与未引用的标识符相同的规则，只是它不能包含一个美元符号。标签是区分大小写的，所以<code>$tag$String content$tag$</code>是正确的，但是<code>$tag$String content$tag$</code>不是。</p>
<p>  引用一个关键字或标识符的美元引用的字符串必须与空格分开;否则，引用分隔符的美元将作为前面标识符的一部分。</p>
<p>  引用美元不是SQL标准的一部分，但它通常比标准兼容的单引号语法更方便地编写复杂的字符串。当在其他常量中表示字符串常量时，它特别有用，因为在过程函数定义中经常需要这样做。使用单引号语法，上面的示例中的每个反斜杠都必须写成4个反斜杠，在解析原始字符串常量时，将减少为两个反斜杠，然后在函数执行期间重新解析内字符串常量时，将其改为1。</p>
</li>
<li><p><strong>位串常量</strong></p>
<p>  在打开引号之前(不插入空格)，例如<code>B&#39;1001&#39;</code>，位串常量看起来就像普通的字符串常量(大写或小写)。在位串常量中允许的唯一字符是0和1。</p>
<p>  或者，可以用十六进制表示法来指定位串常量，前面使用的X(大写或小写)，例如<code>X&#39;1FF&#39;</code>。这个符号相当于一个位串常数，每个十六进制数字的四位二进制数字。</p>
<p>  这两种类型的位串常数都可以像普通的字符串常量一样以相同的方式继续。美元引用不能用在位串常数中。</p>
</li>
<li><p><strong>数字常量</strong></p>
<p>  数值常量在这些一般形式中被接受:</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">digits</span><br><span class="line">digits.[digits][e[+-]digits]</span><br><span class="line">[digits].digits[e[+-]digits]</span><br><span class="line">digitse[+-]digits</span><br></pre></td></tr></table></figure>
<p>  如果数字是一个或多个十进制数字(0到9)，至少一个数字必须在小数点之前或之后，如果使用了一个数字。如果出现一个数字，至少有一个数字必须跟随指数标记(e)。不能有任何空格或其他字符嵌入在常量中。注意，任何正负号都不被认为是常数的一部分;它是一个应用于常数的算子。</p>
<p>  这些是一些有效的数值常量的例子:<br>  42<br>  3.5<br>  4.<br>  .001<br>  5e2<br>  1.925e-3</p>
<p>  一个既不包含小数点也不包含指数的数值常量，如果它的值符合<code>integer</code>(32位)，则最初假定为整数类型；否则，如果其值符合<code>bigint</code>类型(64位)，则假定为类型<code>bigint</code>；否则，它被认为是<code>numeric</code>的。包含小数点和/或指数的常量最初被假定为类型数值。</p>
<p>  数字常量的初始指定数据类型只是类型解析算法的起点。在大多数情况下，根据上下文，常量会自动被强制到最合适的类型。当需要时，您可以强制将一个数字值转换为特定的数据类型。例如，您可以通过写入来强制将数值处理为类型real (float4):</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="type">REAL</span> <span class="string">&#x27;1.23&#x27;</span>  <span class="comment">-- string style</span></span><br><span class="line"><span class="number">1.23</span>::<span class="type">REAL</span>   <span class="comment">-- PostgreSQL (historical) style</span></span><br></pre></td></tr></table></figure>
<p>  这些实际上只是接下来讨论的一般铸造符号的特殊情况。</p>
</li>
<li><p><strong>其他类型的常量</strong></p>
<p>  任意类型的**<em>arbitrary**</em> 可以使用下列任何一种符号来输入:</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">type <span class="string">&#x27;string&#x27;</span></span><br><span class="line"><span class="string">&#x27;string&#x27;</span>::type</span><br><span class="line"><span class="built_in">CAST</span> ( <span class="string">&#x27;string&#x27;</span> <span class="keyword">AS</span> type )</span><br></pre></td></tr></table></figure>
<p>  字符串常量的文本被传递给类型为类型的输入转换例程。结果是指定类型的常数。如果对常量的类型没有歧义(例如，当它被直接分配到表列时)，则可以省略显式类型转换(例如，当它被直接分配到表列时)，在这种情况下它是自动强制的。</p>
<p>  字符串常量可以使用常规SQL符号或美元引用来编写。</p>
<p>  还可以使用类似函数的语法指定类型强制:</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">typename ( <span class="string">&#x27;string&#x27;</span> )</span><br></pre></td></tr></table></figure>
<p>  但并不是所有类型的名称都可以这样使用；</p>
<p>  <code>::,CAST()</code>和函数调用语法也可以用来指定任意表达式的运行时类型转换,为了避免语法歧义，只能使用<code>&#39;string&#39;</code>类型语法来指定简单的文字常量的类型。语法的另一个限制是，它不能用于数组类型；使用<code>::</code>或<code>CAST()</code>来指定数组常量的类型。</p>
<p>  <code>CAST()</code>语法符合SQL。<code>&#39;string&#39;</code>类型语法是标准的一般化:SQL仅为少数数据类型指定此语法，但PostgreSQL允许对所有类型进行此语法。语法与<code>::</code>是历史的PostgreSQL用法，与函数调用语法一样。</p>
</li>
</ul>
</li>
<li><p>操作符</p>
<p> 操作符名称是由以下列表中的<strong>NAMEDATALEN-1(默认63)</strong> 字符组成的序列:<br> <code>+ - * / &lt; &gt; = ~ !@ # % ^ &amp; | ?</code><br> 不过，对操作员的名字有一些限制:</p>
<ul>
<li><p>–并且/*不能以操作符的名字出现在任何地方，因为它们将作为注释的开始。</p>
</li>
<li><p>一个多字符的操作符名称不能以+或-的形式结束，除非这个名称至少包含其中一个字符:<code>~ !@ # % &amp; | &#39; ?</code><br>例如，@是一个允许的操作符名称，但是*-不是。此限制允许PostgreSQL解析符合sql的查询，而不需要在令牌之间进行空格。</p>
<p>在使用非sql标准的操作符名称时，通常需要将相邻的操作符与空格分开以避免歧义。例如，如果定义了一个名为@的左操作符，您就不能写入X*@y;必须编写X*@Y以确保PostgreSQL将其视为两个操作符而不是一个。</p>
</li>
</ul>
</li>
<li><p>特殊字符</p>
<p> 一些不是字母数字的字符有一个特殊的含义，它与作为一个操作符不同。有关用法的详细信息可以在描述相应语法元素的位置找到。这一节只存在于建议存在和总结这些人物的目的。</p>
<ul>
<li><p>一个美元符号($)后面跟着数字，用来表示函数定义或准备语句中的位置参数。在其他情况下，美元符号可以是标识符或美元引用的字符串常量的一部分。</p>
</li>
<li><p>括号(())具有对组表达式和强制优先级的通常意义。在某些情况下，括号是特定SQL命令的固定语法的一部分。</p>
</li>
<li><p>方括号([])用于选择数组的元素。</p>
</li>
<li><p>逗号(，)用于一些语法结构，以分隔列表的元素。</p>
</li>
<li><p>分号(;)终止一个SQL命令。它不能出现在命令内的任何地方，除非在字符串常量或引用的标识符中。</p>
</li>
<li><p>冒号(:)用于从数组中选择“切片”。(参见8.15节)。在某些SQL方言(如嵌入式SQL)中，冒号用于前缀变量名。</p>
</li>
<li><p>在某些上下文中使用星号(*)表示表行或复合值的所有字段。当用作聚合函数的参数时，它也有特殊意义，即聚合不需要任何显式参数。</p>
</li>
<li><p>期间(.)用于数值常量，并将模式、表和列名分开。</p>
</li>
</ul>
</li>
<li><p>注释</p>
<p> 注释是一个字符序列，从双破折号开始，延伸到行尾，例如:</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- This is a standard SQL comment</span></span><br></pre></td></tr></table></figure>
<p> 或者，可以使用c风格的块注释:</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* multiline comment</span></span><br><span class="line"><span class="comment"> * with nesting: /* nested block comment */</span></span><br><span class="line"> <span class="operator">*</span><span class="operator">/</span></span><br></pre></td></tr></table></figure>
<p> 注释以/<em>开头，并扩展到</em>/的匹配发生。这些块注释嵌套在SQL标准中指定，但与C不同，因此可以注释掉可能包含现有块注释的更大的代码块。</p>
<p> 在进一步的语法分析之前，注释将从输入流中删除，并有效地替换为空白。</p>
</li>
<li><p>运算符优先级</p>
<p> <strong>表4.2</strong> 显示了PostgreSQL中操作符的优先级和关联性。大多数操作符具有相同的优先级，并且是左关联的。操作符的优先级和结合性是硬连接到解析器的。</p>
<p> 在使用二进制和一元运算符的组合时，有时需要添加圆括号。例如:</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="number">5</span> <span class="operator">!</span> <span class="operator">-</span> <span class="number">6</span>;</span><br></pre></td></tr></table></figure>
<p> 将解析:</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="number">5</span> <span class="operator">!</span> (<span class="operator">-</span> <span class="number">6</span>);</span><br></pre></td></tr></table></figure>
<p> 因为解析器不知道——直到它太迟了!定义为后缀操作符，而不是插入操作符。要想在这种情况下获得所需的行为，您必须编写:</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> (<span class="number">5</span> <span class="operator">!</span>) <span class="operator">-</span> <span class="number">6</span>;</span><br></pre></td></tr></table></figure>
<p> 这是为可扩展性付出的代价。</p>
<p> <strong>表4.2。操作员优先级(最高到最低)</strong></p>
 <table>
 <tr>
 <td>操作员/元素</td><td>结合性</td><td>描述</td>
 </tr>
 <tr>
 <td>.</td><td>left</td><td>表、列名称分隔器</td>
 </tr>
 <tr>
 <td>::</td><td>left</td><td>PostgreSQL-style定型</td>
 </tr>
 <tr>
 <td>[ ]</td><td>left</td><td>数组元素的选择</td>
 </tr>
 <tr>
 <td>+ -</td><td>right</td><td>一元加一元减</td>
 </tr>
 <tr>
 <td>^</td><td>left</td><td>乘方</td>
 </tr>
 <tr>
 <td>* / %</td><td>left</td><td>乘、除、模</td>
 </tr>
 <tr>
 <td>+ -</td><td>left</td><td>加、减</td>
 </tr>
 <tr>
 <td>(any other operator)</td><td>left</td><td>所有其他本地和用户定义的操作符</td>
 </tr>
 <tr>
 <td>BETWEEN IN LIKE ILIKE SIMILAR</td><td> </td><td>范围控制，设置成员，字符串匹配</td>
 </tr>
 <tr>
 <td>< > = <= >= <> </td><td> </td><td>比较运算符</td>
 </tr>
 <tr>
 <td>IS ISNULL NOTNULL</td><td> </td><td>IS TRUE, IS FALSE, IS NULL, IS DISTINCT FROM, 等</td>
 </tr>
 <tr>
 <td>NOT</td><td>right</td><td>逻辑非</td>
 </tr>
 <tr>
 <td>AND</td><td>left</td><td>逻辑与</td>
 </tr>
 <tr>
 <td>OR</td><td>left</td><td>逻辑或</td>
 </tr>
 </table>

<p> 注意，操作符优先规则也适用于与上面提到的内置操作符同名的用户定义的操作符。例如，如果您为某些自定义数据类型定义了一个“+”操作符，那么它将具有与内置“+”操作符相同的优先级，无论您的操作是什么。</p>
<p> 在操作符语法中使用模式限定的操作符名称时，例如:</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="number">3</span> OPERATOR(pg_catalog.<span class="operator">+</span>) <span class="number">4</span>;</span><br></pre></td></tr></table></figure>
<p> 对于“任何其他操作符”，操作符构造被认为具有表4.2所示的默认优先级。无论哪个特定的操作符出现在运算符()中，这都是真的。    </p>
</li>
</ol>
<h4 id="值表达式"><a href="#值表达式" class="headerlink" title="值表达式"></a>值表达式</h4><p>值表达式在各种上下文中使用，例如在SELECT命令的目标列表中，在新的列值中使用INSERT或UPDATE，或者在一些命令中使用搜索条件。值表达式的结果有时被称为标量，以区别于表表达式的结果(这是一个表)。因此，值表达式也被称为标量表达式(或者甚至是简单的表达式)。表达式语法允许使用算术、逻辑、集合和其他操作计算原始部件的值。</p>
<p>一个值表达式是以下内容之一:</p>
<ul>
<li><p>常量或文字值</p>
</li>
<li><p>列引用</p>
</li>
<li><p>位置参数引用，在函数定义或准备语句的正文中</p>
</li>
<li><p>一个下标表达式</p>
</li>
<li><p>一个字段选择表达式</p>
</li>
<li><p>操作符调用</p>
</li>
<li><p>一个函数调用</p>
</li>
<li><p>一个聚合表达式</p>
</li>
<li><p>一个窗口函数调用</p>
</li>
<li><p>一种投</p>
</li>
<li><p>排序规则表达式</p>
</li>
<li><p>标量子查询</p>
</li>
<li><p>一个数组构造函数</p>
</li>
<li><p>一行的构造函数</p>
</li>
<li><p>括号中的另一个值表达式(用于组子表达式和重写优先级)</p>
</li>
</ul>
<p>除了这个列表之外，还有一些结构可以被分类为一个表达式，但是不遵循任何一般的语法规则。</p>
<p>我们在上节中讨论了的常数。下面几节讨论剩下的选项。</p>
<ol>
<li><p>列引用</p>
<p>一列可以在表格中引用:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">correlation.columnname</span><br></pre></td></tr></table></figure></li>
</ol>
<p>  <em>相关性</em> 是表的名称(可能符合模式名)，或由<code>FROM</code>子句定义的表的别名。如果在当前查询中使用的所有表的列名是惟一的，则可以省略相关名称和分离点。</p>
<ol start="2">
<li><p>位置参数</p>
<p>位置参数引用用于指示从外部向SQL语句提供的值。参数用于SQL函数定义和准备查询中。一些客户端库还支持从SQL命令字符串中单独指定数据值，在这种情况下，用例参数来引用脱机数据值。参数引用的形式为:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$number</span><br></pre></td></tr></table></figure>
<p>例如，考虑函数的定义，dept, as:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> dept(text) <span class="keyword">RETURNS</span> dept</span><br><span class="line">    <span class="keyword">AS</span> $$ <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> dept <span class="keyword">WHERE</span> name <span class="operator">=</span> $<span class="number">1</span> $$</span><br><span class="line">    <span class="keyword">LANGUAGE</span> <span class="keyword">SQL</span>;</span><br></pre></td></tr></table></figure>
<p>当调用函数时，$1引用第一个函数参数的值。</p>
</li>
<li><p>下标</p>
<p>如果表达式产生一个数组类型的值，那么可以通过写入来提取数组值的特定元素。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">expression[subscript]</span><br></pre></td></tr></table></figure>
<p>或多个相邻元素(一个“数组片”)可以通过写入来提取</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">expression[lower_subscript:upper_subscript]</span><br></pre></td></tr></table></figure>
<p>(这里，括号[]是按字面意思显示的。)每个子脚本本身就是一个表达式，它必须产生一个整数值。</p>
<p>一般来说，数组表达式必须是圆括号的，但是当表达式为下标的表达式只是一个列引用或位置参数时，括号可以省略。此外，当原始数组是多维的时，可以连接多个下标。例如:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mytable.arraycolumn[<span class="number">4</span>]</span><br><span class="line">mytable.two_d_column[<span class="number">17</span>][<span class="number">34</span>]</span><br><span class="line">$<span class="number">1</span>[<span class="number">10</span>:<span class="number">42</span>]</span><br><span class="line">(arrayfunction(a,b))[<span class="number">42</span>]</span><br></pre></td></tr></table></figure>
<p>最后一个示例中的括号是必需的。</p>
</li>
<li><p>选择字段</p>
<p>如果表达式产生一个复合类型的值(row类型)，那么可以通过写入来提取该行的特定字段。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">expression.fieldname</span><br></pre></td></tr></table></figure>
<p>一般来说，行表达式必须是圆括号，但是当从表引用或位置参数中选择表达式时，括号可以省略。例如:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mytable.mycolumn</span><br><span class="line">$<span class="number">1.</span>somecolumn</span><br><span class="line">(rowfunction(a,b)).col3</span><br></pre></td></tr></table></figure>
<p>(因此，一个合格的列引用实际上只是字段选择语法的一个特例)。一个重要的特殊情况是从一个组合类型的表列中提取字段:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">(compositecol).somefield</span><br><span class="line">(mytable.compositecol).somefield</span><br></pre></td></tr></table></figure>
<p>这里需要圆括号来显示compositecol是一个列名，而不是一个表名，或者mytable是一个表名，而不是第二个例子中的模式名。</p>
<p>你可以通过写作<code>.*</code>来要求一个复合值的所有字段:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">(compositecol).<span class="operator">*</span></span><br></pre></td></tr></table></figure>
<p>这种表示法根据上下文不同而不同。</p>
</li>
<li><p>操作符调用</p>
<p>对于操作员调用，有三种可能的语法:</p>
</li>
</ol>
<p>  <em>表达式运算符表达式(二进制infix运算符)</em><br>  <em>运算符表达式(一元前缀运算符)</em><br>  <em>表达式运算符(unary postfix运算符)</em></p>
<p>  操作符令牌的语法规则，或为关键字 AND，OR，and NOT，或为表单中的合格操作符名称:</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">OPERATOR(schema.operatorname)</span><br></pre></td></tr></table></figure>
<p>  存在特定的操作符，它们是一元的还是二进制的，取决于操作符由系统或用户定义。</p>
<ol start="6">
<li><p>函数调用</p>
<p>函数调用的语法是一个函数的名称(可能符合模式名)，然后是它的参数列表，括在括号中:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">function_name ([expression [, expression ... ]] )</span><br></pre></td></tr></table></figure>
<p>例如，下面计算2的平方根:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sqrt</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>聚合表达式</p>
</li>
</ol>
<p>  <em>聚合表达式</em> 表示在查询选择的行之间应用聚合函数。聚合函数将多个输入降低为单个输出值，例如输入的总和或平均值。聚合表达式的语法如下:</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">aggregate_name (expression [ , ... ] [ order_by_clause ] ) [ <span class="keyword">FILTER</span> ( <span class="keyword">WHERE</span> filter_clause ) ]</span><br><span class="line">aggregate_name (<span class="keyword">ALL</span> expression [ , ... ] [ order_by_clause ] ) [ <span class="keyword">FILTER</span> ( <span class="keyword">WHERE</span> filter_clause ) ]</span><br><span class="line">aggregate_name (<span class="keyword">DISTINCT</span> expression [ , ... ] [ order_by_clause ] ) [ <span class="keyword">FILTER</span> ( <span class="keyword">WHERE</span> filter_clause ) ]</span><br><span class="line">aggregate_name ( <span class="operator">*</span> ) [ <span class="keyword">FILTER</span> ( <span class="keyword">WHERE</span> filter_clause ) ]</span><br><span class="line">aggregate_name ( [ expression [ , ... ] ] ) <span class="keyword">WITHIN</span> <span class="keyword">GROUP</span> ( order_by_clause ) [ <span class="keyword">FILTER</span> ( <span class="keyword">WHERE</span> filter_clause ) ]</span><br></pre></td></tr></table></figure>
<p>  <em>aggregate_name</em> 是以前定义的聚合(可能符合模式名称)，表达式是任何不包含聚合表达式或窗口函数调用的值表达式。可选的<em>order_by_clause</em> 和<em>filter_clause</em> 描述如下。</p>
<p>  聚合表达式的第一种形式为每个输入行调用一次聚合。第二个表单与第一个表单相同，因为所有的都是默认的。第三个表单将对输入行中发现的表达式的每个不同值(或不同的值集合)调用一次聚合。第四种形式为每个输入行调用一次聚合;由于没有指定特定的输入值，因此通常只对<code>count(*)</code>聚合函数有用。最后一种形式使用有序集聚合函数，如下所示。</p>
<p>  大多数聚合函数都忽略null输入，因此，在其中一个或多个表达式产生null的行被丢弃。这可以假定为真，除非另有规定，对于所有内置的集合。</p>
<p>  例如，count(*)会产生输入行的总数；count(f1)产生的输入行数，f1是 non-null，因为count忽略了null；并且count(distinct f1)产生了f1的不同非空值的数目。</p>
<p>  通常，输入行以未指定的顺序输入聚合函数。在许多情况下，这并不重要；例如，不管输入什么顺序，min都会产生相同的结果。但是，一些聚合函数(例如array_agg和string_agg)产生的结果依赖于输入行的顺序。在使用这样的聚合时，可以使用可选<code>order_by_clause</code>指定所需的排序。<code>order_by_clause</code>语法与查询级顺序相同，只是它的表达式总是表达式，不能是输出列名称或数字。例如:</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">array_agg</span>(a <span class="keyword">ORDER</span> <span class="keyword">BY</span> b <span class="keyword">DESC</span>) <span class="keyword">FROM</span> <span class="keyword">table</span>;</span><br></pre></td></tr></table></figure>
<p>  在处理多参数聚合函数时，请注意，ORDER BY子句要处理所有的聚合参数。例如,写这个:</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> string_agg(a, <span class="string">&#x27;,&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> a) <span class="keyword">FROM</span> <span class="keyword">table</span>;</span><br></pre></td></tr></table></figure>
<p>  而不是：</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> string_agg(a <span class="keyword">ORDER</span> <span class="keyword">BY</span> a, <span class="string">&#x27;,&#x27;</span>) <span class="keyword">FROM</span> <span class="keyword">table</span>;  <span class="comment">-- incorrect</span></span><br></pre></td></tr></table></figure>
<p>  后者在语法上是有效的，但是它代表了一个单参数聚合函数的调用，它有两个键的顺序(第二个是无用的，因为它是一个常量)。</p>
<p>  如果除了<em>order_by_caluse</em>之外，还指定了<code>DISTINCT</code>，那么所有<strong>ORDER BY</strong>表达式的所有顺序都必须匹配聚合的正则参数；也就是说，不能对不包含在不同列表中的表达式<strong>DISTINCT</strong>排序。</p>
<ol start="8">
<li>调用窗口函数</li>
<li>圆柱型</li>
<li>排序规则表达式</li>
<li>标量子查询</li>
<li>数组构造函数</li>
<li>行构造函数</li>
<li>表达式求值规则</li>
</ol>
<h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><ol>
<li>使用按位记数法</li>
<li>使用命名符号</li>
<li>使用复合符号</li>
</ol>
<h3 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h3><h4 id="表基础知识"><a href="#表基础知识" class="headerlink" title="表基础知识"></a>表基础知识</h4><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><h4 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h4><ol>
<li>约束检查</li>
<li>非空（Not-Null）约束</li>
<li>唯一值约束</li>
<li>主键</li>
<li>外键</li>
<li>排除约束</li>
</ol>
<h4 id="系统列"><a href="#系统列" class="headerlink" title="系统列"></a>系统列</h4><h4 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h4><ol>
<li>添加列</li>
<li>删除列</li>
<li>添加约束</li>
<li>删除约束</li>
<li>更改列的默认值</li>
<li>更改列的数据类型</li>
<li>重命名列</li>
<li>重命名表</li>
</ol>
<h4 id="特权"><a href="#特权" class="headerlink" title="特权"></a>特权</h4><h4 id="行安全策略"><a href="#行安全策略" class="headerlink" title="行安全策略"></a>行安全策略</h4><h4 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h4><ol>
<li>创建模式</li>
<li>公共模式</li>
<li>模式搜索路径</li>
<li>模式和特权</li>
<li>系统目录模式</li>
<li>使用模式</li>
<li>可移植性</li>
</ol>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ol>
<li>警告</li>
</ol>
<h4 id="表分区"><a href="#表分区" class="headerlink" title="表分区"></a>表分区</h4><ol>
<li>概述</li>
<li>声明式分区</li>
<li>使用继承实现</li>
<li>分区和约束排斥</li>
</ol>
<h4 id="外部值"><a href="#外部值" class="headerlink" title="外部值"></a>外部值</h4><h4 id="其他数据库对象"><a href="#其他数据库对象" class="headerlink" title="其他数据库对象"></a>其他数据库对象</h4><h4 id="依赖跟踪"><a href="#依赖跟踪" class="headerlink" title="依赖跟踪"></a>依赖跟踪</h4><h3 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h3><h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><h4 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h4><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><h4 id="返回修改行数据"><a href="#返回修改行数据" class="headerlink" title="返回修改行数据"></a>返回修改行数据</h4><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><h4 id="表表达式"><a href="#表表达式" class="headerlink" title="表表达式"></a>表表达式</h4><ol>
<li>FROM子语句</li>
<li>WHERE子语句</li>
<li>GROUP BY和HAVING子语句</li>
<li>GROUPING SETS，CUBE和ROLLUP</li>
<li>窗口处理函数</li>
</ol>
<h4 id="选择列表"><a href="#选择列表" class="headerlink" title="选择列表"></a>选择列表</h4><ol>
<li>选择列表项</li>
<li>列标签</li>
<li>DISTINCT</li>
</ol>
<h4 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h4><h4 id="行排序"><a href="#行排序" class="headerlink" title="行排序"></a>行排序</h4><h4 id="限制和偏移量"><a href="#限制和偏移量" class="headerlink" title="限制和偏移量"></a>限制和偏移量</h4><h4 id="值列表"><a href="#值列表" class="headerlink" title="值列表"></a>值列表</h4><h4 id="WITH查询（常有表表达式）"><a href="#WITH查询（常有表表达式）" class="headerlink" title="WITH查询（常有表表达式）"></a>WITH查询（常有表表达式）</h4><ol>
<li>用WITH选择</li>
<li>用WITH修改数据状态</li>
</ol>
<h3 id="函数和运算符"><a href="#函数和运算符" class="headerlink" title="函数和运算符"></a>函数和运算符</h3><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><h4 id="比较函数和运算符"><a href="#比较函数和运算符" class="headerlink" title="比较函数和运算符"></a>比较函数和运算符</h4><h4 id="数学函数和运算符"><a href="#数学函数和运算符" class="headerlink" title="数学函数和运算符"></a>数学函数和运算符</h4><h4 id="字符串函数和运算符"><a href="#字符串函数和运算符" class="headerlink" title="字符串函数和运算符"></a>字符串函数和运算符</h4><h4 id="二进制字符串函数和运算符"><a href="#二进制字符串函数和运算符" class="headerlink" title="二进制字符串函数和运算符"></a>二进制字符串函数和运算符</h4><h4 id="字节函数和运算符"><a href="#字节函数和运算符" class="headerlink" title="字节函数和运算符"></a>字节函数和运算符</h4><h4 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h4><h4 id="数据类型格式函数"><a href="#数据类型格式函数" class="headerlink" title="数据类型格式函数"></a>数据类型格式函数</h4><h4 id="日期-时间函数和运算符"><a href="#日期-时间函数和运算符" class="headerlink" title="日期/时间函数和运算符"></a>日期/时间函数和运算符</h4><h4 id="枚举支持函数"><a href="#枚举支持函数" class="headerlink" title="枚举支持函数"></a>枚举支持函数</h4><h4 id="几何函数和运算符"><a href="#几何函数和运算符" class="headerlink" title="几何函数和运算符"></a>几何函数和运算符</h4><h4 id="网络地址函数和运算符"><a href="#网络地址函数和运算符" class="headerlink" title="网络地址函数和运算符"></a>网络地址函数和运算符</h4><h4 id="文本搜索函数和操作符"><a href="#文本搜索函数和操作符" class="headerlink" title="文本搜索函数和操作符"></a>文本搜索函数和操作符</h4><h4 id="XML函数"><a href="#XML函数" class="headerlink" title="XML函数"></a>XML函数</h4><h4 id="JSON函数和运算符"><a href="#JSON函数和运算符" class="headerlink" title="JSON函数和运算符"></a>JSON函数和运算符</h4><h4 id="序列操作函数"><a href="#序列操作函数" class="headerlink" title="序列操作函数"></a>序列操作函数</h4><h4 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h4><h4 id="数组函数和运算符"><a href="#数组函数和运算符" class="headerlink" title="数组函数和运算符"></a>数组函数和运算符</h4><h4 id="范围函数和运算符"><a href="#范围函数和运算符" class="headerlink" title="范围函数和运算符"></a>范围函数和运算符</h4><h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><h4 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h4><h4 id="子查询表达式"><a href="#子查询表达式" class="headerlink" title="子查询表达式"></a>子查询表达式</h4><h4 id="行和数组比较"><a href="#行和数组比较" class="headerlink" title="行和数组比较"></a>行和数组比较</h4><h4 id="设置返回函数"><a href="#设置返回函数" class="headerlink" title="设置返回函数"></a>设置返回函数</h4><h4 id="系统信息函数"><a href="#系统信息函数" class="headerlink" title="系统信息函数"></a>系统信息函数</h4><h4 id="系统管理函数"><a href="#系统管理函数" class="headerlink" title="系统管理函数"></a>系统管理函数</h4><h4 id="触发函数"><a href="#触发函数" class="headerlink" title="触发函数"></a>触发函数</h4><h4 id="事件触发函数"><a href="#事件触发函数" class="headerlink" title="事件触发函数"></a>事件触发函数</h4><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><h4 id="运算操作"><a href="#运算操作" class="headerlink" title="运算操作"></a>运算操作</h4><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><h4 id="值存储"><a href="#值存储" class="headerlink" title="值存储"></a>值存储</h4><h4 id="UNION、CASE和相关构造"><a href="#UNION、CASE和相关构造" class="headerlink" title="UNION、CASE和相关构造"></a>UNION、CASE和相关构造</h4><h4 id="选择输出列"><a href="#选择输出列" class="headerlink" title="选择输出列"></a>选择输出列</h4><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><h4 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h4><h4 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h4><h4 id="索引和ORDER-BY"><a href="#索引和ORDER-BY" class="headerlink" title="索引和ORDER BY"></a>索引和ORDER BY</h4><h4 id="结合多个索引"><a href="#结合多个索引" class="headerlink" title="结合多个索引"></a>结合多个索引</h4><h4 id="唯一值索引"><a href="#唯一值索引" class="headerlink" title="唯一值索引"></a>唯一值索引</h4><h4 id="索引表达式"><a href="#索引表达式" class="headerlink" title="索引表达式"></a>索引表达式</h4><h4 id="部分索引"><a href="#部分索引" class="headerlink" title="部分索引"></a>部分索引</h4><h4 id="操作类和操作家族"><a href="#操作类和操作家族" class="headerlink" title="操作类和操作家族"></a>操作类和操作家族</h4><h4 id="索引和排序"><a href="#索引和排序" class="headerlink" title="索引和排序"></a>索引和排序</h4><h4 id="唯一索引查看"><a href="#唯一索引查看" class="headerlink" title="唯一索引查看"></a>唯一索引查看</h4><h4 id="检查索引使用"><a href="#检查索引使用" class="headerlink" title="检查索引使用"></a>检查索引使用</h4><h3 id="全文检索"><a href="#全文检索" class="headerlink" title="全文检索"></a>全文检索</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><ol>
<li>文档是什么？</li>
<li>基本的文档匹配</li>
<li>配置</li>
</ol>
<h4 id="表和索引"><a href="#表和索引" class="headerlink" title="表和索引"></a>表和索引</h4><ol>
<li>查询表</li>
<li>创建索引</li>
</ol>
<h4 id="控制全文检索"><a href="#控制全文检索" class="headerlink" title="控制全文检索"></a>控制全文检索</h4><ol>
<li>解析文档</li>
<li>解析查询</li>
<li>查询结果排名</li>
<li>强调结果</li>
</ol>
<h4 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h4><ol>
<li>文档操作</li>
<li>查询操作</li>
<li>触发自动更新</li>
<li>收集文档统计信息</li>
</ol>
<h4 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h4><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><ol>
<li>停止词</li>
<li>Simple字典</li>
<li>Synonym字典</li>
<li>Thesaurus字段</li>
<li>Ispell字典</li>
<li>Snowball字典</li>
</ol>
<h4 id="配置示例"><a href="#配置示例" class="headerlink" title="配置示例"></a>配置示例</h4><h4 id="测试和调试文本搜索"><a href="#测试和调试文本搜索" class="headerlink" title="测试和调试文本搜索"></a>测试和调试文本搜索</h4><ol>
<li>配置测试</li>
<li>解析测试</li>
<li>字典测试</li>
</ol>
<h4 id="GIN和GiST索引类型"><a href="#GIN和GiST索引类型" class="headerlink" title="GIN和GiST索引类型"></a>GIN和GiST索引类型</h4><h4 id="psql支持"><a href="#psql支持" class="headerlink" title="psql支持"></a>psql支持</h4><h4 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h4><h3 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><h4 id="事物隔离"><a href="#事物隔离" class="headerlink" title="事物隔离"></a>事物隔离</h4><ol>
<li>读取提交隔离级别</li>
<li>可重复度隔离级别</li>
<li>可序列化隔离级别</li>
</ol>
<h4 id="显示锁"><a href="#显示锁" class="headerlink" title="显示锁"></a>显示锁</h4><ol>
<li>表级别锁</li>
<li>行级别锁</li>
<li>页面级别锁</li>
<li>死锁</li>
<li>咨询锁</li>
</ol>
<h4 id="在应用级别下的数据一致性检查"><a href="#在应用级别下的数据一致性检查" class="headerlink" title="在应用级别下的数据一致性检查"></a>在应用级别下的数据一致性检查</h4><ol>
<li>执行与可序列化事务的一致性</li>
<li>强制执行与显式阻塞锁的一致性</li>
</ol>
<h4 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h4><h4 id="锁定和索引"><a href="#锁定和索引" class="headerlink" title="锁定和索引"></a>锁定和索引</h4><h3 id="性能技巧"><a href="#性能技巧" class="headerlink" title="性能技巧"></a>性能技巧</h3><h4 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h4><ol>
<li>使用基础</li>
<li>使用分析</li>
<li>警告</li>
</ol>
<h4 id="Planner使用的统计"><a href="#Planner使用的统计" class="headerlink" title="Planner使用的统计"></a>Planner使用的统计</h4><ol>
<li>单列数据统计</li>
<li>可扩展的信息统计</li>
</ol>
<h4 id="使用显式连接子句控制计划程序"><a href="#使用显式连接子句控制计划程序" class="headerlink" title="使用显式连接子句控制计划程序"></a>使用显式连接子句控制计划程序</h4><h4 id="填充一个数据库"><a href="#填充一个数据库" class="headerlink" title="填充一个数据库"></a>填充一个数据库</h4><ol>
<li>禁止自动提交</li>
<li>使用COPY</li>
<li>删除索引</li>
<li>删除外键约束</li>
<li>增加maintenance_work_mem</li>
<li>增加max_wal_size</li>
<li>禁用WAL_Archival和流复制</li>
<li>运行ABALYZE</li>
<li>关于pg_dump笔记</li>
</ol>
<h4 id="非持久设置"><a href="#非持久设置" class="headerlink" title="非持久设置"></a>非持久设置</h4><h3 id="并行查询"><a href="#并行查询" class="headerlink" title="并行查询"></a>并行查询</h3><h4 id="并行查询是如何工作的"><a href="#并行查询是如何工作的" class="headerlink" title="并行查询是如何工作的"></a>并行查询是如何工作的</h4><h4 id="何时可以使用并行查询？"><a href="#何时可以使用并行查询？" class="headerlink" title="何时可以使用并行查询？"></a>何时可以使用并行查询？</h4><h4 id="并行计划"><a href="#并行计划" class="headerlink" title="并行计划"></a>并行计划</h4><ol>
<li>并行扫描</li>
<li>并行连接</li>
<li>并行聚合</li>
<li>并行计划建议</li>
</ol>
<h4 id="并行安全"><a href="#并行安全" class="headerlink" title="并行安全"></a>并行安全</h4>]]></content>
      <categories>
        <category>PostgresSQL</category>
      </categories>
      <tags>
        <tag>PostgresSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL下的Python</title>
    <url>/postgresql/python_in_postgresql/</url>
    <content><![CDATA[<h2 id="PostgreSQL下的Python"><a href="#PostgreSQL下的Python" class="headerlink" title="PostgreSQL下的Python"></a>PostgreSQL下的Python</h2><p>PL/Python过程语言允许PostgreSQL函数用Python语言编写。</p>
<p>要在特定数据库中安装PL/Python，请使用<code>CREATE EXTENSION plpythonu</code>。</p>
<p><font color=red><strong>提示：</strong></font>如果语言安装到template1中，则随后创建的所有数据库都将自动安装该语言。</p>
<p>PL/Python仅作为”不可信”语言提供，这意味着它不提供限制用户可以在其中执行的任何方式，因此命名为plpythonu。如果在Python中开发安全执行机制，将来可能会有可信变量plpython。在不可信的PL / Python中函数的作者必须注意，该函数不能用于做任何不想要的事情，因为它可以完成登录为数据库管理员的用户所能做的任何事情。 只有超级用户可以使用不受信任的语言（如plpythonu）创建函数。</p>
<h3 id="Python-2-和-Python-3"><a href="#Python-2-和-Python-3" class="headerlink" title="Python 2 和 Python 3"></a>Python 2 和 Python 3</h3><p>PL/Python支持Python 2和Python 3语言变量。由于Python 2和Python 3语言变量在某些重要方面不兼容，因此PL / Python使用以下命名和转换方案来避免混淆它们：</p>
<ul>
<li>命名为plpython2u的PostgreSQL语言实现了基于Python 2语言版本的PL/Python。</li>
<li>命名为plpython3u的PostgreSQL语言实现了基于Python 3语言版本的PL/Python。</li>
<li>命名为plpythonu的语言基于默认的Python语言变体（目前是Python 2）实现了PL/Python。（这个默认值与任何本地Python安装可能认为是它们的”默认”无关，例如，可能是<code>usr/bin/python</code>。）根据在Python社区中迁移到Python 3的进度，在PostgreSQL的一个遥远的未来版本中，默认情况下可能会更改为Python 3。</li>
</ul>
<p>这个方案类似于<a href="https://www.python.org/dev/peps/pep-0394/">PEP 394</a>关于python命令的命名和转换的建议。</p>
<p>它取决于构建配置或安装的包是否可用于Python 2或Python 3的PL/Python。</p>
<p>这会导致以下使用和迁移策略：</p>
<a id="more"></a>
<ul>
<li><p>目前还存在很多对Python 3不感兴趣的用使用语言名称plpythonu，并且在可预见的将来不必改变任何内容。建议通过迁移到Python 2.6/2.7逐步”面向未来”的代码，以简化最终迁移到Python 3。</p>
<p>在实践中，许多PL/Python函数将迁移到Python 3而几乎不做任何更改。</p>
</li>
<li><p>知道他们拥有严重Python 2相关代码并且不打算改变它的用户可以使用plpython2u语言名称。这将继续运行到很遥远的将来，直到Python 2的支持可能会被PostgreSQL完全抛弃。</p>
</li>
<li><p>想要深入Python 3的用户可以使用plpython3u语言名称，该名称将按照今天的标准继续工作。在遥远的将来，当Python 3可能成为默认版本时，他们可能会因美学原因而想要删除”3”。</p>
</li>
<li><p>Daredevils希望构建一个仅限于Python 3的操作系统环境，它可以更改<a href="">pg_pltemplate</a>的内容，使plpythonu等同于plpython3u，同时要记住，这会使得它们的安装与世界上大多数其他地方不兼容。</p>
</li>
</ul>
<p>有关移植到Python 3的更多信息，另请参阅<a href="https://docs.python.org/3/whatsnew/3.0.html">Python 3.0中的新增功能</a>。</p>
<p>在同一个会话中，不允许使用基于Python 2的PL/Python和基于Python 3的PL/Python，因为动态模块中的符号会发生冲突，这可能会导致PostgreSQL服务器进程崩溃。有一个检查可以防止在会话中混合Python主要版本，如果检测到不匹配，这将会中止会话。但是，可以在单独的会话中使用同一数据库中的PL/Python变量。</p>
<h3 id="PL-Python函数"><a href="#PL-Python函数" class="headerlink" title="PL/Python函数"></a>PL/Python函数</h3><p>PL/Python中的函数通过标准的<a href="https://www.postgresql.org/docs/10/static/sql-createfunction.html">CREATE FUNCTION</a>语法声明：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> funcname (argument<span class="operator">-</span>list)</span><br><span class="line">  <span class="keyword">RETURNS</span> <span class="keyword">return</span><span class="operator">-</span>type</span><br><span class="line"><span class="keyword">AS</span> $$</span><br><span class="line">  # PL<span class="operator">/</span>Python <span class="keyword">function</span> body</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpythonu;</span><br></pre></td></tr></table></figure>
<p>函数的主体只是一个Python脚本。当函数被调用时，它的参数作为列表参数的元素传递; 命名参数也作为普通变量传递给Python脚本。命名参数的使用通常更具可读性。结果以通常的方式从Python代码返回，返回或yield（在结果集语句的情况下）。如果你没有提供返回值，Python将返回默认的None。PL/Python将Python的None转换为SQL空值。</p>
<p>例如，返回两个整数中较大者的函数可以定义为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> pymax (a <span class="type">integer</span>, b <span class="type">integer</span>)</span><br><span class="line">  <span class="keyword">RETURNS</span> <span class="type">integer</span></span><br><span class="line"><span class="keyword">AS</span> $$</span><br><span class="line">  if a <span class="operator">&gt;</span> b:</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">  <span class="keyword">return</span> b</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpythonu;</span><br></pre></td></tr></table></figure>
<p>作为函数定义主体给出的Python代码被转换为Python函数。例如，上面的结果是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__plpython_procedure_pymax_23456</span>():</span></span><br><span class="line">  <span class="keyword">if</span> a &gt; b:</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">  <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure>
<p>假设23456是由PostgreSQL分配给函数的OID。</p>
<p>参数被设置为全局变量。由于Python的范围规则，这具有微妙的后果，即变量不能在函数内重新分配给涉及变量名本身的表达式的值，除非该变量在块中被重新声明为全局变量。例如，以下内容不起作用：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> pystrip(x text)</span><br><span class="line">  <span class="keyword">RETURNS</span> text</span><br><span class="line"><span class="keyword">AS</span> $$</span><br><span class="line">  x <span class="operator">=</span> x.strip()  # error</span><br><span class="line">  <span class="keyword">return</span> x</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpythonu;</span><br></pre></td></tr></table></figure>
<p>因为赋值给x使x成为整个块的局部变量，所以赋值右侧的x引用尚未赋值的局部变量x，而不是PL/Python函数参数。使用全局声明，可以使其工作：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> pystrip(x text)</span><br><span class="line">  <span class="keyword">RETURNS</span> text</span><br><span class="line"><span class="keyword">AS</span> $$</span><br><span class="line">  <span class="keyword">global</span> x</span><br><span class="line">  x <span class="operator">=</span> x.strip()  # ok now</span><br><span class="line">  <span class="keyword">return</span> x</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpythonu;</span><br></pre></td></tr></table></figure>
<p>但最好不要依赖PL/Python的这个实现细节。最好将函数参数视为只读。</p>
<h3 id="数据值"><a href="#数据值" class="headerlink" title="数据值"></a>数据值</h3><p>一般来说，PL/Python的目标是提供PostgreSQL和Python世界之间的”自然”映射。 这通知了下面描述的数据映射规则。</p>
<h4 id="数据类型映射"><a href="#数据类型映射" class="headerlink" title="数据类型映射"></a>数据类型映射</h4><p>当调用PL/Python函数时，其参数将从其PostgreSQL数据类型转换为相应的Python类型：</p>
<ul>
<li>PostgreSQL boolean 转换为Python bool。</li>
<li>PostgreSQL smallint 和 int 转换为Python int. PostgreSQL bigint 和 oid 转换为 Python 2的long 和Python 3的int。</li>
<li>PostgreSQL numeric转换为Python Decimal。如果可用，则从cdecimal包中导入此类型。否则，将使用标准库中的decimal.Decimal。cdecimal显着快于decimal。然而，在Python 3.3及更高版本中，cdecimal已经被集成到decimal标准库中，所以不再有任何区别。</li>
<li>PostgreSQL bytea被转换为Python 2中的Python str和Python 3中的bytes。在Python 2中，该字符串应该被视为没有任何字符编码的字节序列。</li>
<li>所有其他数据类型（包括PostgreSQL字符串类型）都被转换为Python str。在Python 2中，这个字符串将在PostgreSQL服务器编码中；在Python 3中，它将是一个像所有字符串一样的Unicode字符串。</li>
<li>对于非标量数据类型，请参见下文。</li>
</ul>
<p>当PL/Python函数返回时，它的返回值被转换为函数声明的PostgreSQL返回数据类型，如下所示：</p>
<ul>
<li><p>当PostgreSQL返回类型是boolean时，根据Python规则将返回值的真值。也就是说，0和空字符串都是假的，但值得注意的是’f’是真的。</p>
</li>
<li><p>当PostgreSQL返回类型是bytea时，返回值将被转换为一个字符串（Python 2）或bytes（Python 3），使用各自的Python内置函数，并将结果转换为bytea。</p>
</li>
<li><p>对于所有其他PostgreSQL返回类型，使用Python内置str将返回值转换为字符串，并将结果传递给PostgreSQL数据类型的输入函数。（如果Python值是float，则使用内置的repr而不是str来转换，以避免精度损失。）</p>
<p>Python 2中的字符串在传递给PostgreSQL时需要使用PostgreSQL服务器编码。在当前服务器编码中无效的字符串会引发错误，但并不是所有的编码不匹配都可以被检测到，所以如果没有正确完成，垃圾数据仍然会产生。 Unicode字符串会自动转换为正确的编码，因此可以更安全，更方便地使用这些字符串。在Python 3中，所有字符串都是Unicode字符串。</p>
</li>
<li><p>对于非标量数据类型，请参见下文。</p>
</li>
</ul>
<h4 id="NULL，None"><a href="#NULL，None" class="headerlink" title="NULL，None"></a>NULL，None</h4><p>如果将一个SQL空值传递给一个函数，那么参数值将在Python中显示为<code>None</code>。例如，第45.2节所示的pymax函数定义将返回null输入的错误答案。我们可以对函数定义添加<code>STRUCT</code>，以使PostgreSQL做一些更合理的事情:如果null值被传递，函数将不会被调用，而是会自动返回一个null结果。或者，我们可以检查函数体中的空输入:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> pymax (a <span class="type">integer</span>, b <span class="type">integer</span>)</span><br><span class="line">  <span class="keyword">RETURNS</span> <span class="type">integer</span></span><br><span class="line"><span class="keyword">AS</span> $$</span><br><span class="line">  if (a <span class="keyword">is</span> <span class="keyword">None</span>) <span class="keyword">or</span> (b <span class="keyword">is</span> <span class="keyword">None</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">  if a <span class="operator">&gt;</span> b:</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">  <span class="keyword">return</span> b</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpythonu;</span><br></pre></td></tr></table></figure>
<p>如上所示，要从PL/Python函数返回一个SQL空值，返回None值。无论函数是否严格，都可以这样做。</p>
<h4 id="数组和列表"><a href="#数组和列表" class="headerlink" title="数组和列表"></a>数组和列表</h4><p>SQL数组值作为Python列表传递到PL/Python中。要从PL/Python函数返回SQL数组值，返回Python列表:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> return_arr()</span><br><span class="line">  <span class="keyword">RETURNS</span> <span class="type">int</span>[]</span><br><span class="line"><span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpythonu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> return_arr();</span><br><span class="line"> return_arr  </span><br><span class="line"><span class="comment">-------------</span></span><br><span class="line"> &#123;1,2,3,4,5&#125;</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>
<p>多维数组作为嵌套的Python列表传递到PL/Python中。例如，二维数组是列表的列表。当从PL/Python函数返回多维SQL数组时，每个级别的内部列表必须都是相同的大小。例如:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> test_type_conversion_array_int4(x int4[]) <span class="keyword">RETURNS</span> int4[] <span class="keyword">AS</span> $$</span><br><span class="line">plpy.info(x, type(x))</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpythonu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test_type_conversion_array_int4(<span class="keyword">ARRAY</span>[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]);</span><br><span class="line">INFO:  ([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]], <span class="operator">&lt;</span>type <span class="string">&#x27;list&#x27;</span><span class="operator">&gt;</span>)</span><br><span class="line"> test_type_conversion_array_int4</span><br><span class="line"><span class="comment">---------------------------------</span></span><br><span class="line"> &#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>
<p>其他Python序列，如元组，也被接受为向后兼容PostgreSQL版本9.6和以下，当多维数组不受支持时。但是，它们总是被当作一维数组来处理，因为它们与复合类型是不明确的。出于同样的原因，当一个复合类型在多维数组中使用时，它必须由一个元组来表示，而不是一个列表。</p>
<p>请注意，在Python中，字符串是序列，它可能对Python程序员很熟悉:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> return_str_arr()</span><br><span class="line">  <span class="keyword">RETURNS</span> <span class="type">varchar</span>[]</span><br><span class="line"><span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">return</span> &quot;hello&quot;</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpythonu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> return_str_arr();</span><br><span class="line"> return_str_arr</span><br><span class="line"><span class="comment">----------------</span></span><br><span class="line"> &#123;h,e,l,l,o&#125;</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>
<h4 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h4><p>复合类型的参数被传递给函数作为Python映射。映射的元素名称是复合类型的属性名称。如果传递行的属性具有空值，那么它在映射中没有任何值。这是一个例子:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employee (</span><br><span class="line">  name text,</span><br><span class="line">  salary <span class="type">integer</span>,</span><br><span class="line">  age <span class="type">integer</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> overpaid (e employee)</span><br><span class="line">  <span class="keyword">RETURNS</span> <span class="type">boolean</span></span><br><span class="line"><span class="keyword">AS</span> $$</span><br><span class="line">  if e[&quot;salary&quot;] <span class="operator">&gt;</span> <span class="number">200000</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">  if (e[&quot;age&quot;] <span class="operator">&lt;</span> <span class="number">30</span>) <span class="keyword">and</span> (e[&quot;salary&quot;] <span class="operator">&gt;</span> <span class="number">100000</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpythonu;</span><br></pre></td></tr></table></figure>
<p>从Python函数中返回行或复合类型有多种方法。下面的例子假设我们有:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> TYPE named_value <span class="keyword">AS</span> (</span><br><span class="line">  name   text,</span><br><span class="line">  <span class="keyword">value</span>  <span class="type">integer</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>复合结果可以返回为:</p>
<p><strong>序列类型</strong>(一个元组或列表，但不是一个集合，因为它不是可索引的)</p>
<p>返回的序列对象必须具有相同数量的项，因为复合结果类型具有字段。索引0的项被分配给复合类型的第一个字段，1的第二个字段，等等。例如:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> make_pair (name text, <span class="keyword">value</span> <span class="type">integer</span>)</span><br><span class="line">  <span class="keyword">RETURNS</span> named_value</span><br><span class="line"><span class="keyword">AS</span> $$</span><br><span class="line">  <span class="keyword">return</span> ( name, <span class="keyword">value</span> )</span><br><span class="line">  # <span class="keyword">or</span> alternatively, <span class="keyword">as</span> tuple: <span class="keyword">return</span> [ name, <span class="keyword">value</span> ]</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpythonu;</span><br></pre></td></tr></table></figure>
<p>若要返回任何列的SQL null，请在相应位置插入<code>None</code>。</p>
<p>当返回一个复合类型数组时，它不能作为一个列表返回，因为它是不明确的，是否Python列表表示一个复合类型，或者另一个数组维度。</p>
<p><strong>映射</strong>(字典)<br>从映射中检索每个结果类型列的值，并使用列名称作为键。例子:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> make_pair (name text, <span class="keyword">value</span> <span class="type">integer</span>)</span><br><span class="line">  <span class="keyword">RETURNS</span> named_value</span><br><span class="line"><span class="keyword">AS</span> $$</span><br><span class="line">  return &#123; &quot;name&quot;: name, &quot;value&quot;: value &#125;</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpythonu;</span><br></pre></td></tr></table></figure>
<p>任何额外的字典键/值对都被忽略。丢失的键被视为错误。若要返回任何列的SQL空值，请插入<code>None</code>用相应的列名作为键。</p>
<p><strong>对象</strong>(任何提供方法__getattr__的对象)<br>这和映射是一样的。例子:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> make_pair (name text, <span class="keyword">value</span> <span class="type">integer</span>)</span><br><span class="line">  <span class="keyword">RETURNS</span> named_value</span><br><span class="line"><span class="keyword">AS</span> $$</span><br><span class="line">  class named_value:</span><br><span class="line">    def __init__ (self, n, v):</span><br><span class="line">      self.name <span class="operator">=</span> n</span><br><span class="line">      self.value <span class="operator">=</span> v</span><br><span class="line">  <span class="keyword">return</span> named_value(name, <span class="keyword">value</span>)</span><br><span class="line"></span><br><span class="line">  # <span class="keyword">or</span> simply</span><br><span class="line">  class nv: pass</span><br><span class="line">  nv.name <span class="operator">=</span> name</span><br><span class="line">  nv.value <span class="operator">=</span> <span class="keyword">value</span></span><br><span class="line">  <span class="keyword">return</span> nv</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpythonu;</span><br></pre></td></tr></table></figure>
<p>还支持带有OUT参数的函数。例如:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> multiout_simple(<span class="keyword">OUT</span> i <span class="type">integer</span>, <span class="keyword">OUT</span> j <span class="type">integer</span>) <span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">return</span> (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpythonu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> multiout_simple();</span><br></pre></td></tr></table></figure>
<h4 id="设置返回函数"><a href="#设置返回函数" class="headerlink" title="设置返回函数"></a>设置返回函数</h4><p>PL/Python函数还可以返回标量或复合类型的集合。有几种方法可以实现这一点，因为返回的对象内部变成了迭代器。下面的例子假设我们有复合类型:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> TYPE greeting <span class="keyword">AS</span> (</span><br><span class="line">  how text,</span><br><span class="line">  who text</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>可以从A返回一个集合结果:</p>
<p><strong>序列类型</strong>(元组、列表、集合)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> greet (how text)</span><br><span class="line">  <span class="keyword">RETURNS</span> SETOF greeting</span><br><span class="line"><span class="keyword">AS</span> $$</span><br><span class="line">  # <span class="keyword">return</span> tuple containing lists <span class="keyword">as</span> composite types</span><br><span class="line">  # <span class="keyword">all</span> other combinations work also</span><br><span class="line">  <span class="keyword">return</span> ( [ how, &quot;World&quot; ], [ how, &quot;PostgreSQL&quot; ], [ how, &quot;PL/Python&quot; ] )</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpythonu;</span><br></pre></td></tr></table></figure>
<p><strong>迭代器</strong>(任何提供__iter__和next方法的对象)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> greet (how text)</span><br><span class="line">  <span class="keyword">RETURNS</span> SETOF greeting</span><br><span class="line"><span class="keyword">AS</span> $$</span><br><span class="line">  class producer:</span><br><span class="line">    def __init__ (self, how, who):</span><br><span class="line">      self.how <span class="operator">=</span> how</span><br><span class="line">      self.who <span class="operator">=</span> who</span><br><span class="line">      self.ndx <span class="operator">=</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    def __iter__ (self):</span><br><span class="line">      <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    def next (self):</span><br><span class="line">      self.ndx <span class="operator">+</span><span class="operator">=</span> <span class="number">1</span></span><br><span class="line">      if self.ndx <span class="operator">=</span><span class="operator">=</span> len(self.who):</span><br><span class="line">        raise StopIteration</span><br><span class="line">      <span class="keyword">return</span> ( self.how, self.who[self.ndx] )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> producer(how, [ &quot;World&quot;, &quot;PostgreSQL&quot;, &quot;PL/Python&quot; ])</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpythonu;</span><br></pre></td></tr></table></figure>
<p><strong>Generator</strong> (yield)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> greet (how text)</span><br><span class="line">  <span class="keyword">RETURNS</span> SETOF greeting</span><br><span class="line"><span class="keyword">AS</span> $$</span><br><span class="line">  <span class="keyword">for</span> who <span class="keyword">in</span> [ &quot;World&quot;, &quot;PostgreSQL&quot;, &quot;PL/Python&quot; ]:</span><br><span class="line">    yield ( how, who )</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpythonu;</span><br></pre></td></tr></table></figure>
<p>还支持带OUT参数的集返回函数(使用返回的记录集)。例如:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> multiout_simple_setof(n <span class="type">integer</span>, <span class="keyword">OUT</span> <span class="type">integer</span>, <span class="keyword">OUT</span> <span class="type">integer</span>) <span class="keyword">RETURNS</span> SETOF record <span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">return</span> [(<span class="number">1</span>, <span class="number">2</span>)] <span class="operator">*</span> n</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpythonu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> multiout_simple_setof(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<h3 id="分享数据"><a href="#分享数据" class="headerlink" title="分享数据"></a>分享数据</h3><p>全局字典<code>SD</code>可以在函数调用之间存储数据。该变量是私有静态数据。全局字典<code>GD</code>是公共数据，可以在会话中的所有Python函数中使用。小心使用。</p>
<p>每个函数在Python解释器中都有自己的执行环境，因此<code>myfunc</code>中的全局数据和函数参数不能用于<code>myfunc2</code>。例外是GD字典中的数据，如上所述。</p>
<h3 id="匿名代码块"><a href="#匿名代码块" class="headerlink" title="匿名代码块"></a>匿名代码块</h3><p>PL/Python还支持使用<a href="https://www.postgresql.org/docs/10/static/sql-do.html">DO</a>语句调用的匿名代码块:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DO $$</span><br><span class="line">    # PL<span class="operator">/</span>Python code</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpythonu;</span><br></pre></td></tr></table></figure>
<p>一个匿名代码块不会接收任何参数，它返回的任何值都会被丢弃。否则它就像一个函数。</p>
<h3 id="触发函数"><a href="#触发函数" class="headerlink" title="触发函数"></a>触发函数</h3><p>当一个函数被用作触发器时，字典<code>TD</code>包含了触发相关的值:</p>
<p><strong>TD(“event”)</strong></p>
<p>将事件作为字符串包含:插入、更新、删除或截断。</p>
<p><strong>TD(“when”)</strong></p>
<p>包含一个之前，之后，或者不是。</p>
<p><strong>TD(“level”)</strong></p>
<p>包含行或声明。</p>
<p><strong>TD(“new”)</strong></p>
<p><strong>TD(“old”)</strong></p>
<p>对于行级触发器，根据触发器事件，其中一个或两个字段包含相应的触发器行。</p>
<p><strong>TD(“name”)</strong></p>
<p>包含触发器的名称。</p>
<p><strong>TD(“table_name”)</strong></p>
<p>包含触发器所发生的表的名称。</p>
<p><strong>TD(“table_schema”)</strong></p>
<p>包含触发器所发生的表的模式。</p>
<p><strong>TD(“relid”)</strong><br>包含触发器所发生的表的OID。</p>
<p><strong>TD(“args”)</strong><br>如果CREATE TRIGGER命令包含了参数，那么它们可以在TD[“args”][0]到TD[“args”][n-1]中得到。</p>
<p>如果TD[“when”]是在之前或者不是，而TD[“level”]是行，那么您可以从Python函数中返回None或”OK”，表示行未修改，”跳过”取消事件，或者如果TD[“event”]是插入或更新，您可以返回”MODIFY”来表示您已经修改了新行。否则将忽略返回值。</p>
<h3 id="数据库访问"><a href="#数据库访问" class="headerlink" title="数据库访问"></a>数据库访问</h3><p>PL/Python语言模块自动导入名为plpy的Python模块。这个模块中的函数和常量在Python代码中可用作<code>plpy.foo</code>。</p>
<h4 id="数据库访问函数"><a href="#数据库访问函数" class="headerlink" title="数据库访问函数"></a>数据库访问函数</h4><p><code>plpy</code>模块提供了几个执行数据库命令的函数:</p>
<ol>
<li>plpy.execute(query [, max-rows])<br>调用`plpy.execute使用一个查询字符串和一个可选的行限制参数执行查询，结果将返回到结果对象中。</li>
</ol>
<p>结果对象模拟一个列表或dictionary对象。结果对象可以通过行号和列名访问。例如:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">rv <span class="operator">=</span> plpy.execute(&quot;SELECT * FROM my_table&quot;, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>从my_table返回最多5行。如果my_table有一个列my_column，它将被访问如下:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">foo <span class="operator">=</span> rv[i][&quot;my_column&quot;]</span><br></pre></td></tr></table></figure>
<p>可以使用内置的<code>len</code>函数获得返回的行数。</p>
<p>结果对象还有这些额外的方法:<br><strong>nrows()</strong><br>返回由命令处理的行数。请注意，这并不一定与返回的行数相同。例如，UPDATE命令将设置此值，但不会返回任何行(除非使用返回)。</p>
<p><strong>status()</strong><br><code>SPI_execute()</code>返回值。</p>
<p><strong>colnames()</strong><br><strong>coltypes()</strong><br><strong>coltypmods()</strong><br>返回列表的列名称，列出列类型oid，以及列出类型特定和修饰符的列表。</p>
<p>这些方法在从没有生成结果集的命令中调用result对象时引发异常，例如，不返回或删除表的更新。但是在包含0行的结果集上使用这些方法是可以的。</p>
<p><strong><strong>str</strong>()</strong><br>定义了标准<code>__str__</code>方法，以便可以使用<code>plpy.debug(rv)</code>来调试查询执行结果。</p>
<p>结果对象可以被修改。</p>
<p>注意,调用<code>plpy.execute</code>将导致将整个结果集读入内存。只有在确定结果集相对较小的情况下才使用该函数。如果您不想在获取大的结果时冒过多的内存使用风险，请使用<code>plpy.cursor</code>而不是<code>plpy.execute</code>。</p>
<ol start="2">
<li>plpy.prepare(query [, argtypes])<br>plpy.execute(plan [, arguments [, max-rows]])</li>
</ol>
<p><code>plpy.prepare</code>准备一个查询的执行计划。如果查询中有参数引用，则使用查询字符串和参数类型列表进行调用。例如:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">plan <span class="operator">=</span> plpy.prepare(&quot;SELECT last_name FROM my_users WHERE first_name = $1&quot;, [&quot;text&quot;])</span><br></pre></td></tr></table></figure>
<p><code>text</code>是变量的类型，您将传递$1。如果您不想将任何参数传递给查询，则第二个参数是可选的。</p>
<p>在准备语句之后，您将使用函数<code>plpy.execute</code>来运行:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">rv <span class="operator">=</span> plpy.execute(plan, [&quot;name&quot;], <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>将该计划作为第一个参数(而不是查询字符串)传递，并将一个值列表作为第二个参数替换为查询。如果查询不期望任何参数，则第二个参数是可选的。第三个参数是和以前一样的可选行限制。</p>
<p>或者，您可以调用plan对象上的execute方法:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">rv <span class="operator">=</span> plan.execute([&quot;name&quot;], <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>查询参数和结果行字段在PostgreSQL和Python数据类型之间转换。</p>
<p>当您使用PL/Python模块准备一个计划时，它会自动保存。请阅读SPI文档(第46章)来描述这意味着什么。为了在函数调用中有效地使用这个功能，需要使用一个持久存储字典SD或GD(参见第45.4节)。例如:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> usesavedplan() <span class="keyword">RETURNS</span> <span class="keyword">trigger</span> <span class="keyword">AS</span> $$</span><br><span class="line">    if &quot;plan&quot; <span class="keyword">in</span> SD:</span><br><span class="line">        plan <span class="operator">=</span> SD[&quot;plan&quot;]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        plan <span class="operator">=</span> plpy.prepare(&quot;SELECT 1&quot;)</span><br><span class="line">        SD[&quot;plan&quot;] <span class="operator">=</span> plan</span><br><span class="line">    # rest <span class="keyword">of</span> <span class="keyword">function</span></span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpythonu;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>plpy.cursor(query)<br>plpy.cursor(plan [, arguments])</li>
</ol>
<p><code>plpy.cursor</code>函数接受与<code>plpy.execute</code>相同的参数(除了行限制)并返回一个游标对象，它允许以较小的块处理大的结果集。与<code>plpy.execute</code>，可以使用查询字符串或计划对象，也可以使用参数列表，或者可以将游标函数称为计划对象的方法。</p>
<p>游标对象提供一个获取方法，该方法接受整数参数并返回结果对象。每次调用fetch时，返回的对象将包含下一行，它们不会大于参数值。一旦所有行耗尽，fetch开始返回一个空结果对象。游标对象还提供一个迭代器接口，每次产生一行，直到所有行都耗尽为止。获取的数据不是作为结果对象返回的，而是作为字典，每个字典对应一个结果行。</p>
<p>从大型表中处理数据的两种方法的示例是:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> count_odd_iterator() <span class="keyword">RETURNS</span> <span class="type">integer</span> <span class="keyword">AS</span> $$</span><br><span class="line">odd <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> <span class="type">row</span> <span class="keyword">in</span> plpy.cursor(&quot;select num from largetable&quot;):</span><br><span class="line">    if <span class="type">row</span>[<span class="string">&#x27;num&#x27;</span>] <span class="operator">%</span> <span class="number">2</span>:</span><br><span class="line">         odd <span class="operator">+</span><span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> odd</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpythonu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> count_odd_fetch(batch_size <span class="type">integer</span>) <span class="keyword">RETURNS</span> <span class="type">integer</span> <span class="keyword">AS</span> $$</span><br><span class="line">odd <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">cursor</span> <span class="operator">=</span> plpy.cursor(&quot;select num from largetable&quot;)</span><br><span class="line">while <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">rows</span> <span class="operator">=</span> cursor.fetch(batch_size)</span><br><span class="line">    if <span class="keyword">not</span> <span class="keyword">rows</span>:</span><br><span class="line">        break</span><br><span class="line">    <span class="keyword">for</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">rows</span>:</span><br><span class="line">        if <span class="type">row</span>[<span class="string">&#x27;num&#x27;</span>] <span class="operator">%</span> <span class="number">2</span>:</span><br><span class="line">            odd <span class="operator">+</span><span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> odd</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpythonu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> count_odd_prepared() <span class="keyword">RETURNS</span> <span class="type">integer</span> <span class="keyword">AS</span> $$</span><br><span class="line">odd <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">plan <span class="operator">=</span> plpy.prepare(&quot;select num from largetable where num % $1 &lt;&gt; 0&quot;, [&quot;integer&quot;])</span><br><span class="line"><span class="keyword">rows</span> <span class="operator">=</span> list(plpy.cursor(plan, [<span class="number">2</span>]))  # <span class="keyword">or</span>: <span class="operator">=</span> list(plan.cursor([<span class="number">2</span>]))</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> len(<span class="keyword">rows</span>)</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpythonu;</span><br></pre></td></tr></table></figure>
<p>游表被自动处理。但是，如果想要显式地释放游标所持有的所有资源，请使用close方法。一旦关闭，一个游标就不能再被提取了。</p>
<p><strong>提示：</strong><br>不要混淆由plpy创建的对象。使用<a href="https://www.python.org/dev/peps/pep-0249/">Python数据库API规范定义</a>的DB-API游标游标。除了名字以外，他们没有任何共同之处。</p>
<h4 id="捕获错误"><a href="#捕获错误" class="headerlink" title="捕获错误"></a>捕获错误</h4><p>访问数据库的函数可能会遇到错误，这将导致它们中止并引发异常。<code>plpy.execute</code>和<code>plpy.prepare</code>都可以引发<code>plpy.SPIError</code>子类的实例,<code>plpy.SPIError</code>默认情况下将终止该函数。这个错误可以像任何其他Python异常一样，通过使用try/except构造来处理。例如:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> try_adding_joe() <span class="keyword">RETURNS</span> text <span class="keyword">AS</span> $$</span><br><span class="line">    try:</span><br><span class="line">        plpy.execute(&quot;INSERT INTO users(username) VALUES (&#x27;joe&#x27;)&quot;)</span><br><span class="line">    <span class="keyword">except</span> plpy.SPIError:</span><br><span class="line">        <span class="keyword">return</span> &quot;something went wrong&quot;</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> &quot;Joe added&quot;</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpythonu;</span><br></pre></td></tr></table></figure>
<p>所提出的异常的实际类对应于导致错误的特定条件。参考表<a href="https://www.postgresql.org/docs/10/static/errcodes-appendix.html#ERRCODES-TABLE">PostgreSQL Error Codes</a>列出可能的条件。模块<code>plpy.spiexception</code>为每个PostgreSQL条件定义了一个异常类，从条件名称派生它们的名称。例如，division_by_zero变成了DivisionByZero, unique_违背变成了独特的效果，fdw_error变成了FdwError，等等。这些异常类都继承自SPIError。这种分离使得处理特定错误变得更容易，例如:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> insert_fraction(numerator <span class="type">int</span>, denominator <span class="type">int</span>) <span class="keyword">RETURNS</span> text <span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">from</span> plpy import spiexceptions</span><br><span class="line">try:</span><br><span class="line">    plan <span class="operator">=</span> plpy.prepare(&quot;INSERT INTO fractions (frac) VALUES ($1 / $2)&quot;, [&quot;int&quot;, &quot;int&quot;])</span><br><span class="line">    plpy.execute(plan, [numerator, denominator])</span><br><span class="line"><span class="keyword">except</span> spiexceptions.DivisionByZero:</span><br><span class="line">    <span class="keyword">return</span> &quot;denominator cannot equal zero&quot;</span><br><span class="line"><span class="keyword">except</span> spiexceptions.UniqueViolation:</span><br><span class="line">    <span class="keyword">return</span> &quot;already have that fraction&quot;</span><br><span class="line"><span class="keyword">except</span> plpy.SPIError, e:</span><br><span class="line">    <span class="keyword">return</span> &quot;other error, SQLSTATE %s&quot; <span class="operator">%</span> e.sqlstate</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> &quot;fraction inserted&quot;</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpythonu;</span><br></pre></td></tr></table></figure>
<p>请注意，因为所有的异常都来自于<code>plpy.spiexception</code>模块继承自<code>SPIError</code>，除子句处理外，它将捕获任何数据库访问错误。</p>
<p>作为处理不同错误条件的另一种方法，可以通过查看异常对象的<code>sqlstate</code>属性来捕获SPIError异常并确定除块内的特定错误条件。该属性是包含“SQLSTATE”错误代码的字符串值。这种方法提供了大致相同的功能。</p>
<h3 id="显式子事务"><a href="#显式子事务" class="headerlink" title="显式子事务"></a>显式子事务</h3><p>从上节所述的数据库访问引起的错误中恢复，可能导致一些操作在其中一个操作失败之前成功，然后从错误中恢复后，数据将处于不一致的状态。PL/Python以显式子事务的形式提供了这个问题的解决方案。</p>
<h4 id="子事务上下文管理器"><a href="#子事务上下文管理器" class="headerlink" title="子事务上下文管理器"></a>子事务上下文管理器</h4><p>考虑一个实现两个帐户之间转移的函数:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> transfer_funds() <span class="keyword">RETURNS</span> void <span class="keyword">AS</span> $$</span><br><span class="line">try:</span><br><span class="line">    plpy.execute(&quot;UPDATE accounts SET balance = balance - 100 WHERE account_name = &#x27;joe&#x27;&quot;)</span><br><span class="line">    plpy.execute(&quot;UPDATE accounts SET balance = balance + 100 WHERE account_name = &#x27;mary&#x27;&quot;)</span><br><span class="line"><span class="keyword">except</span> plpy.SPIError, e:</span><br><span class="line">    <span class="keyword">result</span> <span class="operator">=</span> &quot;error transferring funds: %s&quot; <span class="operator">%</span> e.args</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">result</span> <span class="operator">=</span> &quot;funds transferred correctly&quot;</span><br><span class="line">plan <span class="operator">=</span> plpy.prepare(&quot;INSERT INTO operations (result) VALUES ($1)&quot;, [&quot;text&quot;])</span><br><span class="line">plpy.execute(plan, [<span class="keyword">result</span>])</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpythonu;</span><br></pre></td></tr></table></figure>
<p>如果第二个<code>UPDATE</code>语句导致一个异常被抛出，这个函数将报告错误，但是第一次更新的结果将会被提交。换句话说，这些资金将从乔的账户中撤出，但不会转移到玛丽的账户上。</p>
<p>为了避免这样的问题，你可以包装你的<code>plpy.execute</code>在显式子事务中的调用。<code>plpy</code>模块提供了一个helper对象，用于管理通过<code>plpy.subtransaction()</code>函数创建的显式子事务。由这个函数创建的对象实现了<a href="https://docs.python.org/3/library/stdtypes.html#context-manager-types">上下文管理器接口</a>。使用显式子事务，我们可以将函数重写为:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> transfer_funds2() <span class="keyword">RETURNS</span> void <span class="keyword">AS</span> $$</span><br><span class="line">try:</span><br><span class="line">    <span class="keyword">with</span> plpy.subtransaction():</span><br><span class="line">        plpy.execute(&quot;UPDATE accounts SET balance = balance - 100 WHERE account_name = &#x27;joe&#x27;&quot;)</span><br><span class="line">        plpy.execute(&quot;UPDATE accounts SET balance = balance + 100 WHERE account_name = &#x27;mary&#x27;&quot;)</span><br><span class="line"><span class="keyword">except</span> plpy.SPIError, e:</span><br><span class="line">    <span class="keyword">result</span> <span class="operator">=</span> &quot;error transferring funds: %s&quot; <span class="operator">%</span> e.args</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">result</span> <span class="operator">=</span> &quot;funds transferred correctly&quot;</span><br><span class="line">plan <span class="operator">=</span> plpy.prepare(&quot;INSERT INTO operations (result) VALUES ($1)&quot;, [&quot;text&quot;])</span><br><span class="line">plpy.execute(plan, [<span class="keyword">result</span>])</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpythonu;</span><br></pre></td></tr></table></figure>
<p>注意，仍然需要使用<code>try/catch</code>，否则，异常将传到Python堆栈的顶部，并导致整个函数以PostgreSQL错误中止，这样操作表就不会插入任何行。子事务上下文管理器不会捕获错误，它只确保在其范围内执行的所有数据库操作将被自动地提交或回滚。子事务块的回滚发生在任何类型的异常退出上，而不仅仅是由数据库访问引起的错误引起的。在显式子事务块中引发的常规Python异常也会导致将子事务回滚。</p>
<h4 id="旧的Python版本"><a href="#旧的Python版本" class="headerlink" title="旧的Python版本"></a>旧的Python版本</h4><p>在Python 2.6中默认情况下，使用<code>with</code>关键字的上下文管理器语法是可用的。如果使用较老的Python版本的PL/Python，仍然可以使用显式子事务，尽管不透明。可以使用<code>enter</code>和<code>exit</code>方便别名调用subtransaction manager的<code>__enter__</code>和<code>__exit__</code>函数。转移资金的示例函数可以写成:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> transfer_funds_old() <span class="keyword">RETURNS</span> void <span class="keyword">AS</span> $$</span><br><span class="line">try:</span><br><span class="line">    subxact <span class="operator">=</span> plpy.subtransaction()</span><br><span class="line">    subxact.enter()</span><br><span class="line">    try:</span><br><span class="line">        plpy.execute(&quot;UPDATE accounts SET balance = balance - 100 WHERE account_name = &#x27;joe&#x27;&quot;)</span><br><span class="line">        plpy.execute(&quot;UPDATE accounts SET balance = balance + 100 WHERE account_name = &#x27;mary&#x27;&quot;)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        import sys</span><br><span class="line">        subxact.exit(<span class="operator">*</span>sys.exc_info())</span><br><span class="line">        raise</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        subxact.exit(<span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>)</span><br><span class="line"><span class="keyword">except</span> plpy.SPIError, e:</span><br><span class="line">    <span class="keyword">result</span> <span class="operator">=</span> &quot;error transferring funds: %s&quot; <span class="operator">%</span> e.args</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">result</span> <span class="operator">=</span> &quot;funds transferred correctly&quot;</span><br><span class="line"></span><br><span class="line">plan <span class="operator">=</span> plpy.prepare(&quot;INSERT INTO operations (result) VALUES ($1)&quot;, [&quot;text&quot;])</span><br><span class="line">plpy.execute(plan, [<span class="keyword">result</span>])</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpythonu;</span><br></pre></td></tr></table></figure>
<h3 id="实用功能"><a href="#实用功能" class="headerlink" title="实用功能"></a>实用功能</h3><p><code>plpy</code> 模块也提供了如下功能：</p>
<ul>
<li>plpy.debug(msg, **kwargs)</li>
<li>plpy.log(msg, **kwargs)</li>
<li>plpy.info(msg, **kwargs)</li>
<li>plpy.notice(msg, **kwargs)</li>
<li>plpy.warning(msg, **kwargs)</li>
<li>plpy.error(msg, **kwargs)</li>
<li>plpy.fatal(msg, **kwargs)</li>
</ul>
<p><code>plpy.error</code>和<code>plpy.fatal</code><br>实际上会引发Python异常，如果未捕获，则传到调用查询，导致当前事务或子事务被终止。提高<code>plpy.Error(msg)</code>和提高<code>plpy.Fatal(msg)</code>等同于调用<code>plpy.Error(msg)</code>和<code>plpy.fatal(msg)</code>，但是<code>raise</code>不允许传递关键字参数。其他函数只生成不同优先级的消息。是否将特定优先级的消息报告给客户机，写入服务器日志，或两者都由<a href="https://www.postgresql.org/docs/10/static/runtime-config-logging.html#GUC-LOG-MIN-MESSAGES">log_min_messages</a>和<a href="https://www.postgresql.org/docs/10/static/runtime-config-logging.html#GUC-CLIENT-MIN-MESSAGES">client_min_messages</a>配置变量控制。</p>
<p><code>msg</code>参数作为一个位置参数给出。对于向后兼容性，可以给出多个位置参数。在这种情况下，位置参数元组的字符串表示形式成为向客户机报告的消息。</p>
<p>以下关键字参数被接受:</p>
<ul>
<li>detail</li>
<li>hint</li>
<li>sqlstate</li>
<li>schema_name</li>
<li>table_name</li>
<li>column_name</li>
<li>datatype_name</li>
<li>constraint_name</li>
</ul>
<p>作为关键字参数传递的对象的字符串表示形式用于丰富向客户机报告的消息。例如:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> raise_custom_exception() <span class="keyword">RETURNS</span> void <span class="keyword">AS</span> $$</span><br><span class="line">plpy.error(&quot;custom exception message&quot;,</span><br><span class="line">           detail<span class="operator">=</span>&quot;some info about exception&quot;,</span><br><span class="line">           hint<span class="operator">=</span>&quot;hint for users&quot;)</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpythonu;</span><br><span class="line"></span><br><span class="line"><span class="operator">=</span># <span class="keyword">SELECT</span> raise_custom_exception();</span><br><span class="line">ERROR:  plpy.Error: custom exception message</span><br><span class="line">DETAIL:  <span class="keyword">some</span> info about exception</span><br><span class="line">HINT:  hint <span class="keyword">for</span> users</span><br><span class="line">CONTEXT:  Traceback (most recent <span class="keyword">call</span> <span class="keyword">last</span>):</span><br><span class="line">  PL<span class="operator">/</span>Python <span class="keyword">function</span> &quot;raise_custom_exception&quot;, line <span class="number">4</span>, <span class="keyword">in</span> <span class="operator">&lt;</span><span class="keyword">module</span><span class="operator">&gt;</span></span><br><span class="line">    hint<span class="operator">=</span>&quot;hint for users&quot;)</span><br><span class="line">PL<span class="operator">/</span>Python <span class="keyword">function</span> &quot;raise_custom_exception&quot;</span><br></pre></td></tr></table></figure>
<p>另一组实用函数是<code>plpy.quote_literal(string)</code>、<code>plpy.quote_nullable(string)</code>和<code>plpy.quote_ident(string)</code>。它们相当于内置引用函数。它们在构造特别查询时非常有用。一个PL/Python的动态SQL:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">plpy.execute(&quot;UPDATE tbl SET %s = %s WHERE key = %s&quot; <span class="operator">%</span> (</span><br><span class="line">    plpy.quote_ident(colname),</span><br><span class="line">    plpy.quote_nullable(newvalue),</span><br><span class="line">    plpy.quote_literal(keyvalue)))</span><br></pre></td></tr></table></figure>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>Python解释器接受的一些环境变量也可以用来影响PL/Python行为。它们需要设置在主PostgreSQL服务器进程的环境中，例如在启动脚本中。可用的环境变量取决于Python的版本;有关详细信息，请参阅Python文档。在编写本文时，以下环境变量对PL/Python有影响，假设有足够的Python版本:</p>
<ul>
<li>PYTHONHOME</li>
<li>PYTHONPATH</li>
<li>PYTHONY2K</li>
<li>PYTHONOPTIMIZE</li>
<li>PYTHONDEBUG</li>
<li>PYTHONVERBOSE</li>
<li>PYTHONCASEOK</li>
<li>PYTHONDONTWRITEBYTECODE</li>
<li>PYTHONIOENCODING</li>
<li>PYTHONUSERBASE</li>
<li>PYTHONHASHSEED</li>
</ul>
<p>(它似乎是一个Python实现的细节，超出了PL/Python的控制，在Python手册页上列出的一些环境变量只在命令行解释器中有效，而不是嵌入的Python解释器。)</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>PostgresSQL</category>
      </categories>
      <tags>
        <tag>PostgresSQL、Python</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7下安装PostgresSQL10</title>
    <url>/postgresql/install_postgres/</url>
    <content><![CDATA[<h2 id="CentOS7下安装PostgreSQL10"><a href="#CentOS7下安装PostgreSQL10" class="headerlink" title="CentOS7下安装PostgreSQL10"></a>CentOS7下安装PostgreSQL10</h2><h3 id="1、下载源代码并解压"><a href="#1、下载源代码并解压" class="headerlink" title="1、下载源代码并解压"></a>1、下载源代码并解压</h3><pre><code>1. sudo yum install readline-devel gcc gdal-devel libxml-devel proj-devel pcre-devel \
                    bison-devel flex-devel
2. wget https://ftp.postgresql.org/pub/source/v10.6/postgresql-10.6.tar.gz
2. tar -xvzf postgresql-10.6.tar.gz  #解压pg包
3. ./configure
4. sudo make
5. sudo make install
</code></pre>
<h3 id="2、创建用户组和用户"><a href="#2、创建用户组和用户" class="headerlink" title="2、创建用户组和用户"></a>2、创建用户组和用户</h3><a id="more"></a>
<pre><code>1. groupadd postgres    #新增用户组
2. useradd -g postgres postgres    #新增用户
3. passwd postgres    #为用户设置密码
</code></pre>
<h3 id="3、创建数据目录"><a href="#3、创建数据目录" class="headerlink" title="3、创建数据目录"></a>3、创建数据目录</h3><pre><code>1. mkdir /usr/local/pgsql/data
2. chown postgres /usr/local/pgsql/data    #设置data文件加属性
3. chmod 700 /usr/local/pgsql/data    #设置data文件夹权限
</code></pre>
<h3 id="4、数据库操作"><a href="#4、数据库操作" class="headerlink" title="4、数据库操作"></a>4、数据库操作</h3><pre><code>1. /usr/local/pgsql/bin/initdb -D /usr/local/pgsql/data    #初始化数据库
2. ./pg_ctl start、stop、restart -D /usr/local/pgsql/data/   #启动、停止、重启数据库
3. /usr/local/pgsql/bin/postgres -D /usr/local/pgsql/data &gt;logfile 2&gt;&amp;1 &amp;  #设置日志输出位置
4. /usr/local/pgsql/bin/createdb test    #创建测试数据库
5. /usr/local/pgsql/bin/psql test    #启动测试数据库
</code></pre>
<h3 id="5、修改postgresql-conf"><a href="#5、修改postgresql-conf" class="headerlink" title="5、修改postgresql.conf"></a>5、修改postgresql.conf</h3><pre><code>1. listen_addresses = &#39;*&#39;
2. port = 5432
</code></pre>
<h3 id="6、修改pg-hba-conf"><a href="#6、修改pg-hba-conf" class="headerlink" title="6、修改pg_hba.conf"></a>6、修改pg_hba.conf</h3><pre><code># &quot;local&quot; is for Unix domain socket connections only
local   all             all                                  trust
# IPv4 local connections:
host    all             all             0.0.0.0/0            trust
</code></pre>
]]></content>
      <categories>
        <category>BigData</category>
        <category>PostgresSQL</category>
      </categories>
      <tags>
        <tag>Postgres</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7下安装PostGIS</title>
    <url>/postgresql/install_postgis/</url>
    <content><![CDATA[<h2 id="CentOS7下安装PostGIS"><a href="#CentOS7下安装PostGIS" class="headerlink" title="CentOS7下安装PostGIS"></a>CentOS7下安装PostGIS</h2><h3 id="写在安装之前"><a href="#写在安装之前" class="headerlink" title="写在安装之前"></a>写在安装之前</h3><p>PostGIS的安装和运行需要在PostgreSQL环境下，故本人安装的环境是：</p>
<ul>
<li><p>CentOS 7 64位</p>
</li>
<li><p>PostgreSQL 10.3，具体安装可参考<a href="https://javyxu.cn/postgresql/install_postgres/">CentOS7 下安装 PostgreSQL10</a></p>
</li>
<li><p>PostGIS 2.4.3， 安装过程看本文介绍</p>
</li>
<li><p>geos 3.4.2， 可以使用<code>yum install geos geos-devel</code></p>
</li>
<li><p>gdal 1.11.4， 可以使用<code>yum install jdal gdal-devel</code></p>
</li>
<li><p>libxml 2 2.9.1， 可以使用<code>yum install libxml2 libxml2-devel</code></p>
</li>
<li><p>proj 4.8.0， 可以使用<code>yum install proj proj-devel</code></p>
</li>
<li><p>json-c 0.11， 可以使用<code>yum install json-c json-c-devel</code></p>
</li>
<li><p>pcre 8.32， 可以使用<code>yum install pcre pcre-devel</code></p>
</li>
<li><p>protobuf-c 1.02， 可以使用<code>yum install protobuf-c-devel</code></p>
</li>
</ul>
<p><strong>注：</strong> 具体PostgreSQL与PostGIS之间版本的对应可查看<a href="https://trac.osgeo.org/postgis/wiki/UsersWikiPostgreSQLPostGIS">osgeo官网说明文档</a></p>
<h3 id="PostGIS及其扩展的安装"><a href="#PostGIS及其扩展的安装" class="headerlink" title="PostGIS及其扩展的安装"></a>PostGIS及其扩展的安装</h3><a id="more"></a>
<ol>
<li><p>安装PostGIS</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;download.osgeo.org&#x2F;postgis&#x2F;source&#x2F;postgis-2.4.3.tar.gz</span><br><span class="line"></span><br><span class="line">tar -zxvf postgis-2.4.3.tar.gz</span><br><span class="line"></span><br><span class="line">cd postgis-2.4.3</span><br><span class="line"></span><br><span class="line">.&#x2F;configure --with-pgconfig&#x3D;&#x2F;usr&#x2F;local&#x2F;pgsql&#x2F;bin&#x2F;pg_config</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">make install</span><br></pre></td></tr></table></figure></li>
<li><p>安装PostGIS扩展</p>
<p> PostGIS扩展文件在解压后的源文件夹的<code>extension</code>文件夹下,<strong>具体安装如下所示：</strong></p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd extension</span><br><span class="line"></span><br><span class="line">cd postgis_sfcgal</span><br><span class="line"></span><br><span class="line">make clean &amp; make &amp;　make install</span><br><span class="line"></span><br><span class="line">cd postgis_tiger_geocoder</span><br><span class="line"></span><br><span class="line">make clean &amp; make &amp;　make install</span><br><span class="line"></span><br><span class="line">cd postgis_topology</span><br><span class="line"></span><br><span class="line">make clean &amp; make &amp;　make install</span><br><span class="line"></span><br><span class="line">cd address_standardizer</span><br><span class="line"></span><br><span class="line">make clean &amp; make &amp;　make install</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="在PostgresSQL数据库创建PostGIS"><a href="#在PostgresSQL数据库创建PostGIS" class="headerlink" title="在PostgresSQL数据库创建PostGIS"></a>在PostgresSQL数据库创建PostGIS</h3></li>
<li><p>使用已有的sql文件创建</p>
<p> 所有的SQL语句文件在PostGIS安装成功后，存放在<code>/usr/local/pgsql/data/share/contrib/postgis-2.4/</code>文件夹下</p>
<p> <strong>具体使用方法：</strong></p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;bin&#x2F;createdb postgisdb&#x2F;</span><br><span class="line">.&#x2F;bin&#x2F;psql -d postgisdb -f .&#x2F;share&#x2F;contrib&#x2F;postgis-</span><br><span class="line">2.4&#x2F;postgis.sql</span><br><span class="line"></span><br><span class="line">.&#x2F;bin&#x2F;psql -d postgisdb -f .&#x2F;share&#x2F;contrib&#x2F;postgis-</span><br><span class="line">2.4&#x2F;postgis_comments.sql</span><br><span class="line"></span><br><span class="line">.&#x2F;bin&#x2F;psql -d postgisdb -f .&#x2F;share&#x2F;contrib&#x2F;postgis-</span><br><span class="line">2.4&#x2F;spatial_ref_sys.sql</span><br><span class="line"></span><br><span class="line">.&#x2F;bin&#x2F;psql -d postgisdb -f .&#x2F;share&#x2F;contrib&#x2F;postgis-</span><br><span class="line">2.4&#x2F;topology.sql</span><br><span class="line"></span><br><span class="line">.&#x2F;bin&#x2F;psql -d postgisdb -f .&#x2F;share&#x2F;contrib&#x2F;postgis-</span><br><span class="line">2.4&#x2F;topology_comments.sql</span><br><span class="line"></span><br><span class="line">--Raster--</span><br><span class="line">.&#x2F;bin&#x2F;psql -d postgisdb -f .&#x2F;share&#x2F;contrib&#x2F;postgis-</span><br><span class="line">2.4&#x2F;rtpostgis.sql</span><br><span class="line"></span><br><span class="line">.&#x2F;bin&#x2F;psql -d postgisdb -f .&#x2F;share&#x2F;contrib&#x2F;postgis-</span><br><span class="line">2.4&#x2F;raster_comments.sql</span><br><span class="line"></span><br><span class="line">-sfcgal--</span><br><span class="line">.&#x2F;bin&#x2F;psql -d postgisdb -f .&#x2F;share&#x2F;contrib&#x2F;postgis-</span><br><span class="line">2.4&#x2F;sfcgal.sql</span><br><span class="line"></span><br><span class="line">.&#x2F;bin&#x2F;psql -d postgisdb -f .&#x2F;share&#x2F;contrib&#x2F;postgis-</span><br><span class="line">2.4&#x2F;sfcgal_comments.sql</span><br></pre></td></tr></table></figure></li>
<li><p>通过语言创建</p>
<p> <strong>具体创建方式如下：</strong></p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;bin&#x2F;psql -d postgisdb -c &quot;CREATE EXTESNSION postgis&quot;</span><br><span class="line"></span><br><span class="line">.&#x2F;bin&#x2F;psql -d postgisdb -c &quot;CREATE EXTESNSION postgis_topology&quot;</span><br></pre></td></tr></table></figure>
<h3 id="查看PostgreSQL的扩展"><a href="#查看PostgreSQL的扩展" class="headerlink" title="查看PostgreSQL的扩展"></a>查看PostgreSQL的扩展</h3></li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 显示所有扩展</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> pg_available_extensions;</span><br><span class="line"><span class="comment">-- 显示PostGIS扩展</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> pg_available_extensions <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;postgis%&#x27;</span> <span class="keyword">or</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;address%&#x27;</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>BigData</category>
        <category>PostgresSQL</category>
      </categories>
      <tags>
        <tag>Postgres扩展、PostGIS</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL语法</title>
    <url>/postgresql/basicSyntax/</url>
    <content><![CDATA[<h2 id="SQL语法"><a href="#SQL语法" class="headerlink" title="SQL语法"></a>SQL语法</h2><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><h4 id="1-SELECT"><a href="#1-SELECT" class="headerlink" title="1. SELECT"></a>1. SELECT</h4><h5 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h5><p><code>SELECT</code>语句用于从表中选取数据。结果被存储在一个结果表中（称为结果集）。</p>
<h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> columnname1, columnname2,... <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure>
<h4 id="2-DISTINCT"><a href="#2-DISTINCT" class="headerlink" title="2. DISTINCT"></a>2. DISTINCT</h4><h5 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h5><p>在表中，可能会包含重复值。这并不成问题，不过，有时您也许希望仅仅列出不同（distinct）的值。关键词<code>DISTINCT</code>用于返回唯一不同的值。</p>
<h5 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> column_name <span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure>
<h4 id="3-WHERE-子句"><a href="#3-WHERE-子句" class="headerlink" title="3. WHERE 子句"></a>3. WHERE 子句</h4><a id="more"></a>
<h5 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h5><p>有条件地从表中选取数据，可将<code>WHERE</code>子句添加到<code>SELECT</code>语句。</p>
<h5 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> <span class="keyword">condition</span>(s)</span><br></pre></td></tr></table></figure>
<p><strong>condition(s)：</strong> column_name operator value</p>
<table>
<thead>
<tr>
<th>操作符(operator)</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>等于</td>
</tr>
<tr>
<td>&lt;&gt;</td>
<td>不等于</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
</tr>
<tr>
<td>BETWEEN</td>
<td>在某个范围内</td>
</tr>
<tr>
<td>LIKE</td>
<td>搜索某种模式</td>
</tr>
</tbody></table>
<p><strong>例如：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Persons <span class="keyword">WHERE</span> City<span class="operator">=</span><span class="string">&#x27;Beijing&#x27;</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Persons <span class="keyword">WHERE</span> <span class="keyword">Year</span><span class="operator">&gt;</span><span class="number">1965</span></span><br></pre></td></tr></table></figure>
<h4 id="4-AND和OR"><a href="#4-AND和OR" class="headerlink" title="4. AND和OR"></a>4. AND和OR</h4><h5 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h5><p><code>AND</code>和<code>OR</code>可在<code>WHERE</code>子语句中把两个或多个条件结合起来。如果第一个条件和第二个条件都成立，则<code>AND</code>运算符显示一条记录。如果第一个条件和第二个条件中只要有一个成立，则<code>OR</code>运算符显示一条记录。</p>
<h5 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> (column_name1<span class="operator">=</span><span class="string">&#x27;value1&#x27;</span> <span class="keyword">OR</span> column_name1<span class="operator">=</span><span class="string">&#x27;value2&#x27;</span>)</span><br><span class="line"><span class="keyword">AND</span> column_name3<span class="operator">=</span><span class="string">&#x27;value3&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="5-ORDER-BY语句"><a href="#5-ORDER-BY语句" class="headerlink" title="5. ORDER BY语句"></a>5. ORDER BY语句</h4><h5 id="说明-4"><a href="#说明-4" class="headerlink" title="说明"></a>说明</h5><p><code>ORDER BY</code>语句用于根据指定的列对结果集进行排序。默认按照升序对记录进行排序。如果希望按照降序对记录进行排序，可以使用<em>DESC</em>关键字。</p>
<h5 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name <span class="keyword">FROM</span> table_name <span class="keyword">ORDER</span> <span class="keyword">BY</span> columnname1</span><br><span class="line"><span class="keyword">SELECT</span> column_name <span class="keyword">FROM</span> table_name <span class="keyword">ORDER</span> <span class="keyword">BY</span> columnname1, columnname2</span><br><span class="line"><span class="keyword">SELECT</span> column_name <span class="keyword">FROM</span> table_name <span class="keyword">ORDER</span> <span class="keyword">BY</span> columnname1 <span class="keyword">DESC</span>, columnname2 <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>
<h4 id="6-INSERT-INTO语句"><a href="#6-INSERT-INTO语句" class="headerlink" title="6. INSERT INTO语句"></a>6. INSERT INTO语句</h4><h5 id="说明-5"><a href="#说明-5" class="headerlink" title="说明"></a>说明</h5><p><code>INSERT INTO</code>语句用于向表格中插入新的行。</p>
<h5 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name <span class="keyword">VALUES</span> (value1, value2, value3)</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (column_name1, column_name2, column_name3) <span class="keyword">VALUES</span> (value1, value2, value3)</span><br></pre></td></tr></table></figure>
<h4 id="7-UDPATE语句"><a href="#7-UDPATE语句" class="headerlink" title="7. UDPATE语句"></a>7. UDPATE语句</h4><h5 id="说明-6"><a href="#说明-6" class="headerlink" title="说明"></a>说明</h5><p><code>UDPATE</code>语句用于修改表中的数据。</p>
<h5 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">UPDATE table_name <span class="keyword">SET</span> column_name <span class="operator">=</span> new_value <span class="keyword">WHERE</span> <span class="keyword">condition</span>(s)</span><br><span class="line">UPDATE table_name <span class="keyword">SET</span> column_name1 <span class="operator">=</span> new_value1, columnname2 <span class="operator">=</span> new_value2 <span class="keyword">WHERE</span> <span class="keyword">condition</span>(s)</span><br></pre></td></tr></table></figure>
<h4 id="8-DELETE语句"><a href="#8-DELETE语句" class="headerlink" title="8. DELETE语句"></a>8. <code>DELETE</code>语句</h4><h5 id="说明-7"><a href="#说明-7" class="headerlink" title="说明"></a>说明</h5><p><code>DELETE</code>语句用于删除表中的行。</p>
<h5 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> <span class="keyword">condition</span>(s)</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">DELETE</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure>
<h3 id="高级语法"><a href="#高级语法" class="headerlink" title="高级语法"></a>高级语法</h3><h4 id="1-TOP子句"><a href="#1-TOP子句" class="headerlink" title="1. TOP子句"></a>1. TOP子句</h4><h5 id="说明-8"><a href="#说明-8" class="headerlink" title="说明"></a>说明</h5><p><code>TOP</code>子句用于规定要返回的记录的数目。</p>
<p>对于拥有数千条记录的大型表来说，<code>TOP</code>子句是非常有用的。</p>
<p><em>注释：</em> 并非所有的数据库系统都支持<code>TOP</code>子句。</p>
<h5 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TOP number<span class="operator">|</span><span class="keyword">percent</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="comment">--Oracle</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> ROWNUM <span class="operator">&lt;=</span> number</span><br></pre></td></tr></table></figure>
<h4 id="2-LIKE操作符"><a href="#2-LIKE操作符" class="headerlink" title="2. LIKE操作符"></a>2. LIKE操作符</h4><h5 id="说明-9"><a href="#说明-9" class="headerlink" title="说明"></a>说明</h5><p><code>LIKE</code>操作符用于在<strong>WHERE</strong>子句中搜索列中的指定模式。</p>
<h5 id="语法-9"><a href="#语法-9" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">LIKE</span> <span class="keyword">pattern</span></span><br><span class="line"><span class="comment">-- 不包含</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">NOT</span> <span class="keyword">LIKE</span> <span class="keyword">pattern</span></span><br></pre></td></tr></table></figure>
<p><strong>patter：</strong></p>
<table>
<thead>
<tr>
<th>格式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>N%</td>
<td>以N开头</td>
</tr>
<tr>
<td>%N</td>
<td>以N结尾</td>
</tr>
<tr>
<td>%N%</td>
<td>中间包含N</td>
</tr>
</tbody></table>
<h4 id="3-通配符"><a href="#3-通配符" class="headerlink" title="3. 通配符"></a>3. 通配符</h4><h5 id="说明-10"><a href="#说明-10" class="headerlink" title="说明"></a>说明</h5><p>在搜索数据库中的数据时，SQL通配符可以替代一个或多个字符。</p>
<p>SQL通配符必须与<code>LIKE</code>运算符一起使用。</p>
<p>在SQL中，可使用以下通配符：</p>
<table>
<thead>
<tr>
<th>通配符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>%</td>
<td>代替一个或多个字符</td>
</tr>
<tr>
<td>_</td>
<td>仅代替一个字符</td>
</tr>
<tr>
<td>[charlist]</td>
<td>字符列表中的任何字符</td>
</tr>
<tr>
<td>[^charlist]</td>
<td>不在字符列中的任何单一字符</td>
</tr>
<tr>
<td>[!charlist]</td>
<td>不在字符列中的任何单一字符</td>
</tr>
</tbody></table>
<h5 id="语法-10"><a href="#语法-10" class="headerlink" title="语法"></a>语法</h5><p>同LIKE</p>
<p><strong>说明</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">LIKE</span> <span class="string">&#x27;[ALN]%&#x27;</span> <span class="comment">-- 从表中选取出列名以 &quot;A&quot; 或 &quot;L&quot; 或 &quot;N&quot; 开头的行</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">LIKE</span> <span class="string">&#x27;[!ALN]%&#x27;</span> <span class="comment">-- 从表中选取出列名不以 &quot;A&quot; 或 &quot;L&quot; 或 &quot;N&quot; 开头的行</span></span><br></pre></td></tr></table></figure>
<h4 id="4-IN操作符"><a href="#4-IN操作符" class="headerlink" title="4. IN操作符"></a>4. IN操作符</h4><h5 id="说明-11"><a href="#说明-11" class="headerlink" title="说明"></a>说明</h5><p><code>IN</code>操作符允许我们在<code>WHERE</code>子句中规定多个值。</p>
<h5 id="语法-11"><a href="#语法-11" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">IN</span> (value1,value2,...)</span><br></pre></td></tr></table></figure>
<h4 id="5-BETWEEN操作符"><a href="#5-BETWEEN操作符" class="headerlink" title="5. BETWEEN操作符"></a>5. BETWEEN操作符</h4><h5 id="说明-12"><a href="#说明-12" class="headerlink" title="说明"></a>说明</h5><p>操作符<code>BETWEEN ... AND</code>会选取介于两个值之间的数据范围。这些值可以是数值、文本或者日期。</p>
<h5 id="语法-12"><a href="#语法-12" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--介于</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name</span><br><span class="line"><span class="keyword">BETWEEN</span> value1 <span class="keyword">AND</span> value2</span><br><span class="line"><span class="comment">--范围之外的人</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name</span><br><span class="line"><span class="keyword">NOT</span> <span class="keyword">BETWEEN</span> value1 <span class="keyword">AND</span> value2</span><br></pre></td></tr></table></figure>
<h4 id="6-Alias（别名）"><a href="#6-Alias（别名）" class="headerlink" title="6. Alias（别名）"></a>6. Alias（别名）</h4><h5 id="说明-13"><a href="#说明-13" class="headerlink" title="说明"></a>说明</h5><p>通过使用SQL，可以为列名称和表名称指定别名（Alias）。</p>
<h5 id="语法-13"><a href="#语法-13" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--指定表别名</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">AS</span> alias_name</span><br><span class="line"><span class="comment">--指定列别名</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name <span class="keyword">AS</span> alias_name</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure>
<h4 id="7-JOIN"><a href="#7-JOIN" class="headerlink" title="7. JOIN"></a>7. JOIN</h4><h5 id="说明-14"><a href="#说明-14" class="headerlink" title="说明"></a>说明</h5><p>用于根据两个或多个表中的列之间的关系，从这些表中查询数据。</p>
<p>数据库中的表可通过键将彼此联系起来。主键（Primary Key）是一个列，在这个列中的每一行的值都是唯一的。在表中，每个主键的值都是唯一的。这样做的目的是在不重复每个表中的所有数据的情况下，把表间的数据交叉捆绑在一起。</p>
<h5 id="语法-14"><a href="#语法-14" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name1 <span class="keyword">as</span> t1</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> table_name2 <span class="keyword">as</span> t2</span><br><span class="line"><span class="keyword">ON</span> t1.id <span class="operator">=</span> t2.id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> column_name</span><br></pre></td></tr></table></figure>
<p><strong>例如：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Persons.LastName, Persons.FirstName, Orders.OrderNo</span><br><span class="line"><span class="keyword">FROM</span> Persons, Orders</span><br><span class="line"><span class="keyword">WHERE</span> Persons.Id_P <span class="operator">=</span> Orders.Id_P</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Persons.LastName, Persons.FirstName, Orders.OrderNo</span><br><span class="line"><span class="keyword">FROM</span> Persons</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> Orders</span><br><span class="line"><span class="keyword">ON</span> Persons.Id_P <span class="operator">=</span> Orders.Id_P</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Persons.LastName</span><br></pre></td></tr></table></figure>
<p><strong>注：</strong></p>
<p>JOIN: 如果表中有至少一个匹配，则返回行</p>
<p>LEFT JOIN: 即使右表中没有匹配，也从左表返回所有的行</p>
<p>RIGHT JOIN: 即使左表中没有匹配，也从右表返回所有的行</p>
<p>FULL JOIN: 只要其中一个表中存在匹配，就返回行</p>
<h4 id="8-INNER-JOIN"><a href="#8-INNER-JOIN" class="headerlink" title="8. INNER JOIN"></a>8. INNER JOIN</h4><h4 id="说明-15"><a href="#说明-15" class="headerlink" title="说明"></a>说明</h4><p>在表中存在至少一个匹配时，<code>INNER JOIN</code>关键字返回行。</p>
<h4 id="语法-15"><a href="#语法-15" class="headerlink" title="语法"></a>语法</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name1</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> table_name2</span><br><span class="line"><span class="keyword">ON</span> table_name1.column_name<span class="operator">=</span>table_name2.column_name</span><br></pre></td></tr></table></figure>
<p><strong>注：</strong><code>INNER JOIN</code>与<code>JOIN</code>是相同的。</p>
<h4 id="9-LEFT-JOIN"><a href="#9-LEFT-JOIN" class="headerlink" title="9. LEFT JOIN"></a>9. LEFT JOIN</h4><h5 id="说明-16"><a href="#说明-16" class="headerlink" title="说明"></a>说明</h5><p><code>LEFT JOIN</code>关键字会从左表(table_name1)那里返回所有的行，即使在右表 (table_name2)中没有匹配的行。</p>
<h5 id="语法-16"><a href="#语法-16" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name1</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> table_name2</span><br><span class="line"><span class="keyword">ON</span> table_name1.column_name<span class="operator">=</span>table_name2.column_name</span><br></pre></td></tr></table></figure>
<h4 id="10-RIGHT-JOIN"><a href="#10-RIGHT-JOIN" class="headerlink" title="10. RIGHT JOIN"></a>10. RIGHT JOIN</h4><h4 id="说明-17"><a href="#说明-17" class="headerlink" title="说明"></a>说明</h4><p><code>RIGHT JOIN</code>关键字会右表(table_name2)那里返回所有的行，即使在左表 (table_name1)中没有匹配的行。</p>
<h4 id="语法-17"><a href="#语法-17" class="headerlink" title="语法"></a>语法</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name1</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> table_name2</span><br><span class="line"><span class="keyword">ON</span> table_name1.column_name<span class="operator">=</span>table_name2.column_name</span><br></pre></td></tr></table></figure>
<h4 id="11-FULL-JOIN"><a href="#11-FULL-JOIN" class="headerlink" title="11. FULL JOIN"></a>11. FULL JOIN</h4><h5 id="说明-18"><a href="#说明-18" class="headerlink" title="说明"></a>说明</h5><p>只要其中某个表存在匹配，<code>FULL JOIN</code>关键字就会返回行。</p>
<h5 id="语法-18"><a href="#语法-18" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name1</span><br><span class="line"><span class="keyword">FULL</span> <span class="keyword">JOIN</span> table_name2</span><br><span class="line"><span class="keyword">ON</span> table_name1.column_name<span class="operator">=</span>table_name2.column_name</span><br></pre></td></tr></table></figure>
<h4 id="12-UNION和UNION-ALL"><a href="#12-UNION和UNION-ALL" class="headerlink" title="12.UNION和UNION ALL"></a>12.UNION和UNION ALL</h4><h5 id="说明-19"><a href="#说明-19" class="headerlink" title="说明"></a>说明</h5><p>UNION 操作符用于合并两个或多个 SELECT 语句的结果集。</p>
<p>请注意，<code>UNION</code>内部的<code>SELECT</code>语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条<code>SELECT</code>语句中的列的顺序必须相同。</p>
<h5 id="语法-19"><a href="#语法-19" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table_name1</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table_name2</span><br><span class="line"><span class="comment">-- UNION ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table_name1</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table_name2</span><br></pre></td></tr></table></figure>
<p><strong>注：</strong> 默认地，<code>UNION</code>操作符选取不同的值。如果允许重复的值，请使用<code>UNION ALL</code>。</p>
<h4 id="13-SELECT-INTO"><a href="#13-SELECT-INTO" class="headerlink" title="13. SELECT INTO"></a>13. SELECT INTO</h4><h5 id="说明-20"><a href="#说明-20" class="headerlink" title="说明"></a>说明</h5><p><code>SELECT INTO</code>语句从一个表中选取数据，然后把数据插入另一个表中。</p>
<p><code>SELECT INTO</code>语句常用于创建表的备份复件或者用于对记录进行存档。</p>
<h5 id="语法-20"><a href="#语法-20" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- INSERT ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">INTO</span> new_table_name [<span class="keyword">IN</span> externaldatabase]</span><br><span class="line"><span class="keyword">FROM</span> old_tablename</span><br><span class="line"><span class="comment">-- INSERT PATR</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">INTO</span> new_table_name [<span class="keyword">IN</span> externaldatabase]</span><br><span class="line"><span class="keyword">FROM</span> old_tablename</span><br></pre></td></tr></table></figure>
<h3 id="SQL语法-1"><a href="#SQL语法-1" class="headerlink" title="SQL语法"></a>SQL语法</h3><h4 id="1-CREATE-DATABASE"><a href="#1-CREATE-DATABASE" class="headerlink" title="1. CREATE DATABASE"></a>1. CREATE DATABASE</h4><h5 id="说明-21"><a href="#说明-21" class="headerlink" title="说明"></a>说明</h5><p>用于创建数据库。</p>
<h5 id="语法-21"><a href="#语法-21" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE database_name</span><br></pre></td></tr></table></figure>
<h4 id="2-CREATE-TABLE"><a href="#2-CREATE-TABLE" class="headerlink" title="2. CREATE TABLE"></a>2. CREATE TABLE</h4><h5 id="说明-22"><a href="#说明-22" class="headerlink" title="说明"></a>说明</h5><p>用于创建数据库中的表。</p>
<h5 id="语法-22"><a href="#语法-22" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line">(</span><br><span class="line">column_name1 data_type,</span><br><span class="line">column_name2 data_type,</span><br><span class="line">column_name3 data_type,</span><br><span class="line">....</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><strong>数据类型（data_type）说明：</strong></p>
<table>
<thead>
<tr>
<th>数据类型（data_type）</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>integer(size) int(size) smallint(size) tinyint(size)</td>
<td>仅容纳整数。在括号内规定数字的最大位数。</td>
</tr>
<tr>
<td>decimal(size,d) numeric(size,d)</td>
<td>容纳带有小数的数字。”size” 规定数字的最大位数。”d” 规定小数点右侧的最大位数。</td>
</tr>
<tr>
<td>char(size)</td>
<td>容纳固定长度的字符串（可容纳字母、数字以及特殊字符）。在括号中规定字符串的长度</td>
</tr>
<tr>
<td>varchar(size)</td>
<td>容纳可变长度的字符串（可容纳字母、数字以及特殊的字符）。在括号中规定字符串的最大长度。</td>
</tr>
<tr>
<td>date(yyyymmdd)</td>
<td>容纳日期。</td>
</tr>
</tbody></table>
<h4 id="3-Constraints"><a href="#3-Constraints" class="headerlink" title="3. Constraints"></a>3. Constraints</h4><h5 id="说明-23"><a href="#说明-23" class="headerlink" title="说明"></a>说明</h5><p>约束用于限制加入表的数据的类型。</p>
<p>可以在创建表时规定约束（通过CREATE TABLE语句），或者在表创建之后也可以（通过ALTER TABLE语句）。</p>
<p>主要探讨以下几种约束：</p>
<ul>
<li>NOT NULL</li>
<li>UNIQUE</li>
<li>PRIMARY KEY</li>
<li>FOREIGN KEY</li>
<li>CHECK</li>
<li>DEFAULT</li>
</ul>
<h4 id="4-NOT-NULL"><a href="#4-NOT-NULL" class="headerlink" title="4. NOT NULL"></a>4. NOT NULL</h4><h5 id="说明-24"><a href="#说明-24" class="headerlink" title="说明"></a>说明</h5><p><code>NOT NULL</code>约束强制列不接受<code>NULL</code>值。</p>
<p><code>NOT NULL</code>约束强制字段始终包含值。这意味着，如果不向字段添加值，就无法插入新记录或者更新记录。</p>
<h5 id="语法-23"><a href="#语法-23" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- NOT NULL</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line">(</span><br><span class="line">    column_name1 data_type <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    column_name2 data_type,</span><br><span class="line">    column_name3 data_type,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- NOT NULL</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line">(</span><br><span class="line">    column_name1 data_type <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    column_name2 data_type,</span><br><span class="line">    column_name3 data_type,</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- UNIQUE</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (</span><br><span class="line">    column_name1 data_type <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    column_name2 data_type,</span><br><span class="line">    column_name3 data_type,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h4 id="5-UNIQUE"><a href="#5-UNIQUE" class="headerlink" title="5. UNIQUE"></a>5. UNIQUE</h4><h5 id="说明-25"><a href="#说明-25" class="headerlink" title="说明"></a>说明</h5><p><code>UNIQUE</code>约束唯一标识数据库表中的每条记录。</p>
<p><code>UNIQUE</code>和<code>PRIMARY KEY</code>约束均为列或列集合提供了唯一性的保证。</p>
<p><code>PRIMARY KEY</code>拥有自动定义的<code>UNIQUE</code>约束。</p>
<p><strong>注：</strong>，每个表可以有多个<code>UNIQUE</code>约束，但是每个表只能有一个<code>PRIMARY KEY</code>约束。</p>
<h5 id="语法-24"><a href="#语法-24" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- Create UNIQUE To new Table</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (</span><br><span class="line">    column_name1 data_type <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    column_name2 data_type,</span><br><span class="line">    column_name3 data_type,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Create UNIQUES To new Table</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (</span><br><span class="line">    column_name1 data_type <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    column_name2 data_type,</span><br><span class="line">    column_name3 data_type,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> uc_name <span class="keyword">UNIQUE</span> (column_name1,column_name2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Create UNIQUE To old Table</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> (columnname)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Create UNIQUES To old Table</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> uc_name <span class="keyword">UNIQUE</span> (columnname1,columnname2)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Drop UNIQUES To Table</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">DROP</span> INDEX uc_name</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> uc_name</span><br></pre></td></tr></table></figure>
<h4 id="6-PRIMARY-KEY"><a href="#6-PRIMARY-KEY" class="headerlink" title="6. PRIMARY KEY"></a>6. PRIMARY KEY</h4><h5 id="说明-26"><a href="#说明-26" class="headerlink" title="说明"></a>说明</h5><p><code>PRIMARY KEY</code>约束唯一标识数据库表中的每条记录。</p>
<p>主键必须包含唯一的值。</p>
<p>主键列不能包含 NULL 值。</p>
<p>每个表都应该有一个主键，并且每个表只能有一个主键。</p>
<h5 id="语法-25"><a href="#语法-25" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- Create UNIQUE To new Table</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (</span><br><span class="line">    column_name1 data_type <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    column_name2 data_type,</span><br><span class="line">    column_name3 data_type,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Create UNIQUES To new Table</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (</span><br><span class="line">    column_name1 data_type <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    column_name2 data_type,</span><br><span class="line">    column_name3 data_type,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> pk_name <span class="keyword">PRIMARY</span> KEY (column_name1,column_name2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Create UNIQUE To old Table</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY (columnname)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Create UNIQUES To old Table</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> pk_name <span class="keyword">PRIMARY</span> KEY (columnname1,columnname2)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Drop UNIQUES To Table</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PRIMARY</span> KEY</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> pk_name</span><br></pre></td></tr></table></figure>
<h4 id="7-FOREIGN-KEY"><a href="#7-FOREIGN-KEY" class="headerlink" title="7. FOREIGN KEY"></a>7. FOREIGN KEY</h4><h5 id="说明-27"><a href="#说明-27" class="headerlink" title="说明"></a>说明</h5><p>一个表中的<code>FOREIGN KEY</code>指向另一个表中的<code>PRIMARY KEY</code>。</p>
<p><code>FOREIGN KEY</code>约束用于预防破坏表之间连接的动作。</p>
<p><code>FOREIGN KEY</code>约束也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</p>
<h5 id="语法-26"><a href="#语法-26" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- Create UNIQUE To new Table</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (</span><br><span class="line">    column_name1 data_type <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    column_name2 data_type,</span><br><span class="line">    column_name3 data_type,</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (column_name3) <span class="keyword">REFERENCES</span> table_name1(columnname)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Create UNIQUES To new Table</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (</span><br><span class="line">    column_name1 data_type <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    column_name2 data_type,</span><br><span class="line">    column_name3 data_type,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> fk_name <span class="keyword">FOREIGN</span> KEY (column_name1)</span><br><span class="line">    <span class="keyword">REFERENCES</span> table_name1(columnname)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Create UNIQUE To old Table</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">FOREIGN</span> KEY (columnname)</span><br><span class="line"><span class="keyword">REFERENCES</span> table_name1(columnname1)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Create UNIQUES To old Table</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> pk_name <span class="keyword">PRIMARY</span> KEY (columnname1,columnname2)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Drop UNIQUES To Table</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY fk_name</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> fk_name</span><br></pre></td></tr></table></figure>
<h4 id="8-CHECK"><a href="#8-CHECK" class="headerlink" title="8. CHECK"></a>8. CHECK</h4><h5 id="说明-28"><a href="#说明-28" class="headerlink" title="说明"></a>说明</h5><p><code>CHECK</code>约束用于限制列中的值的范围。</p>
<p>如果对单个列定义<code>CHECK</code>约束，那么该列只允许特定的值。</p>
<p>如果对一个表定义<code>CHECK</code>约束，那么此约束会在特定的列中对值进行限制。</p>
<h5 id="语法-27"><a href="#语法-27" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- Create</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (</span><br><span class="line">    column_name1 data_type <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">CHECK</span> (column_name1<span class="operator">&gt;</span><span class="number">0</span>),</span><br><span class="line">    column_name2 data_type,</span><br><span class="line">    column_name3 data_type,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Create</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (</span><br><span class="line">    column_name1 data_type <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    column_name2 data_type,</span><br><span class="line">    column_name3 data_type,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> chk_name <span class="keyword">CHECK</span> (column_name1<span class="operator">&gt;</span><span class="number">0</span> <span class="keyword">AND</span> column_name2<span class="operator">=</span>value1)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Create To old Table</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CHECK</span> (column_name1<span class="operator">&gt;</span><span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Create To old Table</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> chk_name <span class="keyword">CHECK</span> (column_name1<span class="operator">&gt;</span><span class="number">0</span> <span class="keyword">AND</span> column_name2<span class="operator">=</span>value1)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Drop To Table</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> chk_name</span><br></pre></td></tr></table></figure>
<h4 id="9-DEFAULT"><a href="#9-DEFAULT" class="headerlink" title="9. DEFAULT"></a>9. DEFAULT</h4><h5 id="说明-29"><a href="#说明-29" class="headerlink" title="说明"></a>说明</h5><p><code>DEFAULT</code>约束用于向列中插入默认值。</p>
<p>如果没有规定其他的值，那么会将默认值添加到所有的新记录。</p>
<h5 id="语法-28"><a href="#语法-28" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- Create DEFAULT To new Table</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (</span><br><span class="line">    column_name1 data_type <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    column_name2 data_type,</span><br><span class="line">    column_name3 data_type <span class="keyword">DEFAULT</span> <span class="keyword">value</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Create DEFAULT To old Table</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">ALTER</span> column_name <span class="keyword">SET</span> <span class="keyword">DEFAULT</span> <span class="keyword">value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Drop DEFAULT To Table</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">ALTER</span> column_name <span class="keyword">DROP</span> <span class="keyword">DEFAULT</span></span><br></pre></td></tr></table></figure>
<h4 id="9-CREATE-INDEX"><a href="#9-CREATE-INDEX" class="headerlink" title="9. CREATE INDEX"></a>9. CREATE INDEX</h4><h5 id="说明-30"><a href="#说明-30" class="headerlink" title="说明"></a>说明</h5><p>在表中创建索引，以便更加快速高效地查询数据。</p>
<p>用户无法看到索引，它们只能被用来加速搜索/查询。</p>
<p><strong>注：</strong> 更新一个包含索引的表需要比更新一个没有索引的表更多的时间，这是由于索引本身也需要更新。因此，理想的做法是仅仅在常常被搜索的列（以及表）上面创建索引。</p>
<h5 id="语法-29"><a href="#语法-29" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name</span><br><span class="line"><span class="keyword">ON</span> table_name (column_name)</span><br><span class="line"><span class="comment">-- UNIQUE INDEX</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX index_name</span><br><span class="line"><span class="keyword">ON</span> table_name (column_name)</span><br><span class="line"><span class="comment">-- 对列创建索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX column_index</span><br><span class="line"><span class="keyword">ON</span> table_name (column_name)</span><br><span class="line"><span class="comment">-- 对列创建降序索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX column_index</span><br><span class="line"><span class="keyword">ON</span> table_name (column_name <span class="keyword">DESC</span>)</span><br><span class="line"><span class="comment">-- 对多列创建索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX column_index</span><br><span class="line"><span class="keyword">ON</span> table_name (column_name1, column_name2)</span><br></pre></td></tr></table></figure>
<h4 id="10-撤销索引、表以及数据库"><a href="#10-撤销索引、表以及数据库" class="headerlink" title="10. 撤销索引、表以及数据库"></a>10. 撤销索引、表以及数据库</h4><h5 id="说明-31"><a href="#说明-31" class="headerlink" title="说明"></a>说明</h5><p>通过使用<code>DROP</code>语句，可以轻松地删除索引、表和数据库。</p>
<h5 id="语法-30"><a href="#语法-30" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- Drop INDEX</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">DROP</span> INDEX index_name</span><br><span class="line"><span class="comment">-- Drop TABLE</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="comment">-- Drop DATABASE</span></span><br><span class="line"><span class="keyword">DROP</span> DATABASE database_name</span><br><span class="line"><span class="comment">-- clear data</span></span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> table_name</span><br></pre></td></tr></table></figure>
<h4 id="11-ALTER-TABLE"><a href="#11-ALTER-TABLE" class="headerlink" title="11. ALTER TABLE"></a>11. ALTER TABLE</h4><h5 id="说明-32"><a href="#说明-32" class="headerlink" title="说明"></a>说明</h5><p>用于在已有的表中添加、修改或删除列。</p>
<h5 id="语法-31"><a href="#语法-31" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- add column</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">ADD</span> column_name datatype</span><br><span class="line"><span class="comment">-- delete column</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> column_name</span><br><span class="line"><span class="comment">-- modify column</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> column_name datatype</span><br></pre></td></tr></table></figure>
<h4 id="12-AUTO-INCREMENT字段"><a href="#12-AUTO-INCREMENT字段" class="headerlink" title="12. AUTO INCREMENT字段"></a>12. AUTO INCREMENT字段</h4><h5 id="说明-33"><a href="#说明-33" class="headerlink" title="说明"></a>说明</h5><p>我们通常希望在每次插入新记录时，自动地创建主键字段的值。</p>
<p>我们可以在表中创建一个<code>auto-increment</code>字段。</p>
<h5 id="语法-32"><a href="#语法-32" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- CREATE</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line">(</span><br><span class="line">    columnname1 data_type <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    column_name2 data_type <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (columnname1)</span><br><span class="line">)</span><br><span class="line"><span class="comment">-- 以100开始</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name AUTO_INCREMENT<span class="operator">=</span><span class="number">100</span></span><br></pre></td></tr></table></figure>
<h4 id="13-VIEW"><a href="#13-VIEW" class="headerlink" title="13. VIEW"></a>13. VIEW</h4><h5 id="说明-34"><a href="#说明-34" class="headerlink" title="说明"></a>说明</h5><p>在SQL中，视图是基于SQL语句的结果集的可视化的表。</p>
<p>视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。我们可以向视图添加SQL函数、WHERE以及JOIN语句，我们也可以提交数据，就像这些来自于某个单一的表。</p>
<p><strong>注：</strong> 数据库的设计和结构不会受到视图中的函数、where或join语句的影响。</p>
<h5 id="语法-33"><a href="#语法-33" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- CREATE</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span></span><br><span class="line"><span class="comment">-- UPDATE</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span></span><br><span class="line"><span class="comment">-- Drop</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> view_name</span><br></pre></td></tr></table></figure>
<h4 id="14-NULL"><a href="#14-NULL" class="headerlink" title="14. NULL"></a>14. NULL</h4><h5 id="说明-35"><a href="#说明-35" class="headerlink" title="说明"></a>说明</h5><p>如果表中的某个列是可选的，那么我们可以在不向该列添加值的情况下插入新记录或更新已有的记录。这意味着该字段将以<code>NULL</code>值保存。</p>
<p><code>NULL</code>值的处理方式与其他值不同。</p>
<p><code>NULL</code>用作未知的或不适用的值的占位符。</p>
<p><strong>注：</strong> 无法比较<code>NULL</code>和<code>0</code>；它们是不等价的。</p>
<h5 id="语法-34"><a href="#语法-34" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- IS NULL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="comment">-- IS NOT NULL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure>
<h3 id="SQL函数"><a href="#SQL函数" class="headerlink" title="SQL函数"></a>SQL函数</h3><h4 id="1-AVG"><a href="#1-AVG" class="headerlink" title="1. AVG"></a>1. AVG</h4><h5 id="说明-36"><a href="#说明-36" class="headerlink" title="说明"></a>说明</h5><p>AVG函数返回数值列的平均值。NULL值不包括在计算中。</p>
<h5 id="语法-35"><a href="#语法-35" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(column_name) <span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure>
<h4 id="2-COUNT"><a href="#2-COUNT" class="headerlink" title="2. COUNT"></a>2. COUNT</h4><h5 id="说明-37"><a href="#说明-37" class="headerlink" title="说明"></a>说明</h5><p>返回匹配指定条件的行数。</p>
<h5 id="语法-36"><a href="#语法-36" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(column_name) <span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure>
<h4 id="2-AVG"><a href="#2-AVG" class="headerlink" title="2. AVG"></a>2. AVG</h4><h5 id="说明-38"><a href="#说明-38" class="headerlink" title="说明"></a>说明</h5><p>AVG函数返回数值列的平均值。NULL值不包括在计算中。</p>
<h5 id="语法-37"><a href="#语法-37" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 指定某列</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(column_name) <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="comment">-- 所有</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="comment">-- 唯一值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> column_name) <span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure>
<h4 id="3-FIRST"><a href="#3-FIRST" class="headerlink" title="3. FIRST"></a>3. FIRST</h4><h5 id="说明-39"><a href="#说明-39" class="headerlink" title="说明"></a>说明</h5><p><code>FIRST()</code>函数返回指定的字段中第一个记录的值。</p>
<h5 id="语法-38"><a href="#语法-38" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FIRST</span>(column_name) <span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure>
<h4 id="3-FIRST-1"><a href="#3-FIRST-1" class="headerlink" title="3. FIRST"></a>3. FIRST</h4><h5 id="说明-40"><a href="#说明-40" class="headerlink" title="说明"></a>说明</h5><p><code>FIRST()</code>函数返回指定的字段中第一个记录的值。</p>
<h5 id="语法-39"><a href="#语法-39" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FIRST</span>(column_name) <span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure>
<h4 id="4-LAST"><a href="#4-LAST" class="headerlink" title="4. LAST"></a>4. LAST</h4><h5 id="说明-41"><a href="#说明-41" class="headerlink" title="说明"></a>说明</h5><p><code>LAST()</code>函数返回指定的字段中最后一个记录的值。</p>
<h5 id="语法-40"><a href="#语法-40" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LAST</span>(column_name) <span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure>
<h4 id="5-MAX"><a href="#5-MAX" class="headerlink" title="5. MAX"></a>5. MAX</h4><h5 id="说明-42"><a href="#说明-42" class="headerlink" title="说明"></a>说明</h5><p><code>MAX()</code>函数返回指定的字段中最大的值。NULL值不包括在计算中。</p>
<h5 id="语法-41"><a href="#语法-41" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(column_name) <span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure>
<h4 id="6-MIN"><a href="#6-MIN" class="headerlink" title="6. MIN"></a>6. MIN</h4><h5 id="说明-43"><a href="#说明-43" class="headerlink" title="说明"></a>说明</h5><p><code>MIN()</code>函数返回指定的字段胡最小值。NULL值不包括在计算中。</p>
<h5 id="语法-42"><a href="#语法-42" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(column_name) <span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure>
<h4 id="7-SUM"><a href="#7-SUM" class="headerlink" title="7. SUM"></a>7. SUM</h4><h5 id="说明-44"><a href="#说明-44" class="headerlink" title="说明"></a>说明</h5><p><code>SUM()</code>函数返回数值列的总和。</p>
<h5 id="语法-43"><a href="#语法-43" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(column_name) <span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure>
<h4 id="8-GROUP-BY"><a href="#8-GROUP-BY" class="headerlink" title="8. GROUP BY"></a>8. GROUP BY</h4><h5 id="说明-45"><a href="#说明-45" class="headerlink" title="说明"></a>说明</h5><p><code>GROUP BY</code>用于结合合计函数，根据一个或多个列对结果集进行分组。</p>
<h5 id="语法-44"><a href="#语法-44" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name, aggregate_function(column_name)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name operator <span class="keyword">value</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> column_name</span><br></pre></td></tr></table></figure>
<h4 id="9-HAVING"><a href="#9-HAVING" class="headerlink" title="9. HAVING"></a>9. HAVING</h4><h5 id="说明-46"><a href="#说明-46" class="headerlink" title="说明"></a>说明</h5><p>在SQL中增加<code>HAVING</code>子句原因是，WHERE关键字无法与合计函数一起使用。</p>
<h5 id="语法-45"><a href="#语法-45" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name, aggregate_function(column_name)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name operator <span class="keyword">value</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> column_name</span><br><span class="line"><span class="keyword">HAVING</span> aggregate_function(column_name) operator <span class="keyword">value</span></span><br></pre></td></tr></table></figure>
<h4 id="10-UCASE"><a href="#10-UCASE" class="headerlink" title="10. UCASE"></a>10. UCASE</h4><h5 id="说明-47"><a href="#说明-47" class="headerlink" title="说明"></a>说明</h5><p><code>UCASE</code>函数把字段的值转换为大写。</p>
<h5 id="语法-46"><a href="#语法-46" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UCASE(column_name) <span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure>
<h4 id="11-LCASE"><a href="#11-LCASE" class="headerlink" title="11. LCASE"></a>11. LCASE</h4><h5 id="说明-48"><a href="#说明-48" class="headerlink" title="说明"></a>说明</h5><p><code>LCASE</code>函数把字段的值转换为小写。</p>
<h5 id="语法-47"><a href="#语法-47" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> LCASE(column_name) <span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure>
<h4 id="10-MID"><a href="#10-MID" class="headerlink" title="10. MID"></a>10. MID</h4><h5 id="说明-49"><a href="#说明-49" class="headerlink" title="说明"></a>说明</h5><p><code>MID</code>函数用于从文本字段中提取字符。</p>
<h5 id="语法-48"><a href="#语法-48" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> MID(column_name,<span class="keyword">start</span>[,length]) <span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>column_name</td>
<td>必需。要提取字符的字段。</td>
</tr>
<tr>
<td>start</td>
<td>必需。规定开始位置（起始值是 1）。</td>
</tr>
<tr>
<td>length</td>
<td>可选。要返回的字符数。如果省略，则 MID() 函数返回剩余文本。</td>
</tr>
</tbody></table>
<h4 id="11-LEN"><a href="#11-LEN" class="headerlink" title="11. LEN"></a>11. LEN</h4><h5 id="说明-50"><a href="#说明-50" class="headerlink" title="说明"></a>说明</h5><p><code>LEN</code>函数返回文本字段中值的长度。</p>
<h5 id="语法-49"><a href="#语法-49" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> LEN(column_name) <span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure>
<h4 id="12-ROUND"><a href="#12-ROUND" class="headerlink" title="12. ROUND"></a>12. ROUND</h4><h5 id="说明-51"><a href="#说明-51" class="headerlink" title="说明"></a>说明</h5><p><code>ROUND</code>函数用于把数值字段舍入为指定的小数位数。</p>
<h5 id="语法-50"><a href="#语法-50" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ROUND(column_name,decimals) <span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure>
<h4 id="13-NOW"><a href="#13-NOW" class="headerlink" title="13. NOW"></a>13. NOW</h4><h5 id="说明-52"><a href="#说明-52" class="headerlink" title="说明"></a>说明</h5><p><code>NOW</code>函数返回当前的日期和时间。</p>
<h5 id="语法-51"><a href="#语法-51" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> NOW() <span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure>
<h4 id="11-FORMAT"><a href="#11-FORMAT" class="headerlink" title="11. FORMAT"></a>11. FORMAT</h4><h5 id="说明-53"><a href="#说明-53" class="headerlink" title="说明"></a>说明</h5><p><code>FORMAT</code>函数用于对字段的显示进行格式化。</p>
<h5 id="语法-52"><a href="#语法-52" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> FORMAT(column_name,format) <span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure>
<h3 id="SQL数据类型"><a href="#SQL数据类型" class="headerlink" title="SQL数据类型"></a>SQL数据类型</h3>]]></content>
      <categories>
        <category>PostgresSQL</category>
      </categories>
      <tags>
        <tag>PostgresSQL、SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令——find使用</title>
    <url>/linux/linux_find/</url>
    <content><![CDATA[<h2 id="Linux命令——find使用"><a href="#Linux命令——find使用" class="headerlink" title="Linux命令——find使用"></a>Linux命令——find使用</h2><h3 id="find常用格式"><a href="#find常用格式" class="headerlink" title="find常用格式"></a>find常用格式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find [-H | -L | -P] [-EXdsx] [-f path] path ... [expression]</span><br><span class="line">find [-H | -L | -P] [-EXdsx] -f path [path ...] [expression]</span><br></pre></td></tr></table></figure>
<p><strong>参数详解：</strong></p>
<a id="more"></a>
<ol>
<li><p>使用-name按名称查找</p>
<p> 文件名选项是find命令最常用的选项，要么单独使用该选项，要么和其他选项一起使用。可以使用某种文件名模式来匹配文件，记住要用引号将文件名模式引起来。不管当前路径是什么，如果想要在自己的根目录$HOME中查找文件名符合*.log的文件，使用<del>作为’pathname’参数，波浪号</del>代表了你的$HOME目录。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find ~ -name &quot;*.log&quot; -print  </span><br></pre></td></tr></table></figure>
<p> 想要在当前目录及子目录中查找所有的’*.log’ 文件，可以用：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find . -name &quot;*.log&quot; -print  </span><br></pre></td></tr></table></figure>
<p> 想要的当前目录及子目录中查找文件名以一个大写字母开头的文件，可以用：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find . -name &quot;[A-Z]*&quot; -print</span><br></pre></td></tr></table></figure>
<p> 想要在/etc目录中查找文件名以host开头的文件，可以用：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F;etc -name &quot;host*&quot; -print  </span><br></pre></td></tr></table></figure>
<p> 想要查找$HOME目录中的文件，可以用：  </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find ~ -name &quot;*&quot; -print 或find . -print  </span><br></pre></td></tr></table></figure></li>
<li><p>使用-perm按文件权限查找</p>
<p> 最好使用八进制的权限表示法。如在当前目录下查找文件权限位为755的文件，即文件属主可以读、写、执行，其他用户可以读、执行的文件，可以用：  </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find . -perm 755 -print</span><br></pre></td></tr></table></figure></li>
<li><p>使用-user username按文件所属用户查找</p>
<p> 在etc目录中查找文件属主为postgres的文件</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F;etc -user postgres -print</span><br></pre></td></tr></table></figure></li>
<li><p>使用-nouser按文件的属主在是否在/etc/passwd中没有有效账户的查找</p>
<p> 为了查找属主帐户已经被删除的文件，可以使用-nouser选项。在/etc目录下查找所有的这类文件</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F;etc -nouser -print</span><br></pre></td></tr></table></figure></li>
<li><p>使用-group groupname按文件所属组查找</p>
<p> 在etc目录中查找文件属组为postgres的文件</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F;etc -group postgres -print</span><br></pre></td></tr></table></figure></li>
<li><p>使用-nogroup查找没有有效所属用户组的所有文件</p>
<p> 从文件系统的etc目录处查找这样的文件:</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F;etc -nogroup -print</span><br></pre></td></tr></table></figure></li>
<li><p>使用-mtime按文件更改时间来查找</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F;etc -mtime  -n +n -print   #按文件更改时间来查找文件，-n指n天以内，+n指n天以前</span><br></pre></td></tr></table></figure></li>
<li><p>使用-atime按文件访问时间来查找</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F;etc -atime -n +n -print   #按文件访问时间来查GIN: 0px&quot;&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>使用-ctime按文件创建时间来查找</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F;etc -ctime -n +n -print   #按文件创建时间来查找文件，-n指n天以内，+n指n天以前</span><br></pre></td></tr></table></figure></li>
<li><p>使用-newer按更改时间进行查找</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F;etc -newer f1 !f2 -print     #查更改时间比f1新但比f2旧的文件</span><br></pre></td></tr></table></figure></li>
<li><p>使用-type按文件类型进行查找</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F;etc -type b&#x2F;d&#x2F;c&#x2F;p&#x2F;l&#x2F;f -print   #查是块设备、目录、字符设备、管道、符号链接、普通文件</span><br></pre></td></tr></table></figure></li>
<li><p>使用-size按文件长度进行查找</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F;etc -size n[c] -print   #查长度为n块[或n字节]的文件</span><br></pre></td></tr></table></figure></li>
<li><p>使用-depth按在进入子目录前先行查完本目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F;etc -depth -print    #使查找在进入子目录前先行查找完本目录</span><br></pre></td></tr></table></figure></li>
<li><p>使用-fstype按更改时间进行查找</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F;etc -fstype -print         #查更改时间比f1新但比f2旧的文件</span><br></pre></td></tr></table></figure></li>
<li><p>使用-mount说明查找文件时是否不跨越文件系统mount点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F;etc -mount -print #查文件时不跨越文件系统mount点</span><br></pre></td></tr></table></figure></li>
<li><p>使用-follow说明遇到符号链接文件就跟踪链接所指的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F;etc -follow -print</span><br></pre></td></tr></table></figure></li>
<li><p>使用-cpio %查找位于某一类型文件系统中的文件，这些文件系统类型通常可 在/etc/fstab中找到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F;etc -cpio % -print</span><br></pre></td></tr></table></figure></li>
<li><p>使用-prune可忽略某个目录</p>
<p>如果在查找文件时希望忽略某个目录，因为你知道那个目录中没有你所要查找的文件，在使用-prune选项时要当心，因为如果你同时使用了-depth选项，那么-prune选项就会被find命令忽略。如果希望在etc目录下查找文件，但不希望在test/test3目录下查找，可以用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find etc -path &quot;test&#x2F;test3&quot; -prune -o -print</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>在CentOS下安装和配置rasdaman</title>
    <url>/bigdata/install_rasdaman/</url>
    <content><![CDATA[<h2 id="安装和配置rasdaman"><a href="#安装和配置rasdaman" class="headerlink" title="安装和配置rasdaman"></a>安装和配置rasdaman</h2><h3 id="rasdaman简介"><a href="#rasdaman简介" class="headerlink" title="rasdaman简介"></a>rasdaman简介</h3><p><strong>rasdaman（”raster data manager”）栅格数据管理器：</strong> 号称是世界上最灵活和可伸缩的阵列引擎。</p>
<p>它允许存储和查询大量多维数组，如传感器、图像、模拟和统计数据，这些数据出现在地球、空间和生命科学等领域。这个全球领先的阵列分析引擎以其灵活性、性能和可扩展性而著称。rasdaman可以处理驻留在文件系统目录和数据库中的数组。</p>
<p>一个常用的同义词是栅格数据阵列，如二维光栅图形；这实际上促使名称rasdaman。然而，rasdaman在维度数目没有限制它可以，例如，一维二维测量数据、卫星图像、三维X/Y/T的时间序列图像和X、Y、Z的勘探资料，四维的海洋和气候数据，甚至超越时空的维度。</p>
<p><strong>新一代地理栅格服务器</strong> ：从简单的地理图像服务到复杂的分析，rasdaman提供了时空光栅数据的所有功能——包括规则网格和不规则网格。正如最近的科学基准所显示的那样，它的性能和可扩展性是前所未有的。为了利用这种支持技术，用户不必学习新的接口:rasdaman与R、OpenLayers、Leaflet、NASA WorldWind、GDAL、MapServer、ESRI ArcGIS等软件进行了平滑集成，想要了解更多可点击<a href="http://rasdaman.org/wiki/Clients">这里</a>。</p>
<p>下面介绍一下rasdaman的几种安装方法：</p>
<h3 id="一、通过rpm安装rasdaman"><a href="#一、通过rpm安装rasdaman" class="headerlink" title="一、通过rpm安装rasdaman"></a>一、通过rpm安装rasdaman</h3><h4 id="下载并安装"><a href="#下载并安装" class="headerlink" title="下载并安装"></a>下载并安装</h4><ol>
<li><p>向yum添加rasdaman仓库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo - root</span><br><span class="line">curl &quot;http:&#x2F;&#x2F;download.rasdaman.org&#x2F;packages&#x2F;rpm&#x2F;stable&#x2F;CentOS&#x2F;7&#x2F;x86_64&#x2F;rasdaman.repo&quot; -o &#x2F;etc&#x2F;yum.repos.d&#x2F;rasdaman.repo</span><br></pre></td></tr></table></figure></li>
<li><p>现在在yum下可以使用rasdaman包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">yum update</span><br><span class="line">yum search rasdaman</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rasdaman.x86_64 : Rasdaman is the leading Array Database for flexible, scalable</span><br><span class="line">                : analytics of massive multi-dimensional array (raster) data,</span><br><span class="line">                : such as spatio-temporal datacubes.</span><br></pre></td></tr></table></figure></li>
<li><p>向yum添加EPEL仓库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install epel-release</span><br></pre></td></tr></table></figure></li>
<li><p>安装rasdaman包，并启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install rasdaman</span><br><span class="line">source &#x2F;etc&#x2F;profile.d&#x2F;rasdaman.sh</span><br></pre></td></tr></table></figure></li>
</ol>
<p>  <strong>注：</strong> 要想使用petascope，必须配置数据库为postgres，目前的rpm包都是以sqlite为默认包，后期会有更想，请期待！</p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><a id="more"></a>
<ol>
<li><p>检查</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">rasql <span class="operator">-</span>q <span class="string">&#x27;select c from RAS_COLLECTIONNAMES as c&#x27;</span> <span class="comment">--out string</span></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rasql: rasdaman query tool v1.0, rasdaman v9.7.0 -- generated on 02.07.2015 08:44:56.</span><br><span class="line">opening database RASBASE at localhost:7001...ok</span><br><span class="line">Executing retrieval query...ok</span><br><span class="line">Query result collection has 0 element(s):</span><br><span class="line">rasql done.</span><br></pre></td></tr></table></figure></li>
<li><p>检查petascope是否初始化，这是地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;rasdaman&#x2F;ows</span><br><span class="line"># http:&#x2F;&#x2F;192.168.231.131:8080&#x2F;rasdaman&#x2F;ows</span><br></pre></td></tr></table></figure></li>
</ol>
<p>  <strong>注：</strong> 这个在其他机器启动时会出现不能链接情况，需要将端口号开放或者关闭服务器的防火墙。</p>
<ol start="3">
<li>rasdaman被安装在<code>/opt/rasdaman</code>下</li>
</ol>
<h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>无论什么时候有一个新的版本发布，通过以下步骤便进行升级更新：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su - root</span><br><span class="line"></span><br><span class="line">service rasdaman stop</span><br><span class="line">yum clean all</span><br><span class="line">yum update rasdaman</span><br><span class="line">service rasdaman start</span><br><span class="line"></span><br><span class="line">#如果使用petascope需要启动下面的</span><br><span class="line">service tomcat restart</span><br><span class="line">migrate_petascopedb.sh</span><br></pre></td></tr></table></figure>
<p>执行完以上步骤后，你的rasdaman将会被更新。</p>
<h4 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h4><p>当以上步骤被执行完成后，rasdaman安装或者根更新完成后，这部分提供管理者一些额外后台信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service rasdaman start</span><br><span class="line">service rasdaman stop</span><br><span class="line">service rasdaman status</span><br></pre></td></tr></table></figure>
<p>相似的，<code>tomact</code>/<code>tomact6</code>和<code>postgresql</code>服务也可以被启动或者停止。</p>
<h3 id="二、通过source安装rasdaman"><a href="#二、通过source安装rasdaman" class="headerlink" title="二、通过source安装rasdaman"></a>二、通过source安装rasdaman</h3><h4 id="创建rasdaman用户"><a href="#创建rasdaman用户" class="headerlink" title="创建rasdaman用户"></a>创建rasdaman用户</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install epel-release</span><br><span class="line">adduser rasdaman</span><br><span class="line">passwd rasdaman</span><br><span class="line"></span><br><span class="line"># 切换到rasdaman用户</span><br><span class="line">sudo -u rasdaman -i</span><br></pre></td></tr></table></figure>
<p><strong>注：</strong>  修改/etc/sudoers</p>
<h5 id="修改sudoers方法"><a href="#修改sudoers方法" class="headerlink" title="修改sudoers方法"></a>修改sudoers方法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;sudoers</span><br><span class="line"></span><br><span class="line">## 方法一： 把前面的注释（#）去掉</span><br><span class="line">## Allows people in group wheel to run all commands</span><br><span class="line">%wheel    ALL&#x3D;(ALL)    ALL</span><br><span class="line"></span><br><span class="line">## 然后修改用户，使其属于root组（wheel），命令如下：</span><br><span class="line"></span><br><span class="line">#usermod -g root tommy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 方法二：在root下面添加一行，如下所示：</span><br><span class="line"></span><br><span class="line">## Allow root to run any commands anywhere</span><br><span class="line">root    ALL&#x3D;(ALL)     ALL</span><br><span class="line">rasdaman   ALL&#x3D;(ALL)     ALL</span><br></pre></td></tr></table></figure>
<h4 id="需要包的说明和安装"><a href="#需要包的说明和安装" class="headerlink" title="需要包的说明和安装"></a>需要包的说明和安装</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install \</span><br><span class="line">  git make libtool pkgconfig m4 unzip curl \</span><br><span class="line">  bison gcc gcc-c++ libedit-devel zlib-devel openssl-devel \</span><br><span class="line">  flex flex-devel boost-devel libstdc++-static \</span><br><span class="line">  gdal-devel hdf-devel netcdf-devel grib_api-devel netcdf-cxx-devel netcdf4-python \</span><br><span class="line">  postgresql-devel postgresql-contrib postgresql-server sqlite-devel \</span><br><span class="line">  gdal-python gdal-java python-setuptools python-pip python-magic python2-netcdf4 grib_api\</span><br><span class="line">  java-1.8.0-openjdk java-1.8.0-openjdk-devel java-1.8.0-openjdk-headless tomcat maven2 \</span><br><span class="line">  libgeotiff libgeotiff-devel libtiff libtiff-devel \</span><br><span class="line">  doxygen</span><br><span class="line">sudo yum install cmake3</span><br><span class="line">sudo pip install glob2</span><br></pre></td></tr></table></figure>
<p><strong>注</strong>：源码编译安装boost,安装过程请参考<a href="">boost1.67</a>，</p>
<h4 id="配置条件"><a href="#配置条件" class="headerlink" title="配置条件"></a>配置条件</h4><ol>
<li><p>确保java和javac版本一致</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -version</span><br><span class="line">javac -version</span><br></pre></td></tr></table></figure></li>
<li><p>允许用户添加部署tomcat webapps目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo adduser $USER tomcat</span><br><span class="line"># reboot or logout&#x2F;login is necessary for this command to take effect</span><br></pre></td></tr></table></figure></li>
<li><p>如果支持PostgresSQL，请添加postgres用户：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo -u postgres createuser -s $USER</span><br></pre></td></tr></table></figure></li>
<li><p>如果使用tomcat，请设置tomacat最大heap空间&gt;=1GB。设置方式如下：</p>
<p>修改etc/default/tomcat7的JAVA_OPTS=Xmx1024m，然重启tomcat <code>sudo service tomcat restart.</code>。</p>
</li>
</ol>
<h4 id="获取源代码并安装"><a href="#获取源代码并安装" class="headerlink" title="获取源代码并安装"></a>获取源代码并安装</h4><ol>
<li><p>获取源代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;javyxu&#x2F;rasdaman.git # this creates subdirectory   rasdaman&#x2F;</span><br><span class="line">cd rasdaman&#x2F;</span><br></pre></td></tr></table></figure></li>
<li><p>编译并安装</p>
</li>
</ol>
<ul>
<li><p>配置<code>～/.bashrc</code>文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export RMANHOME&#x3D;&#x2F;var&#x2F;local&#x2F;rasdaman</span><br><span class="line">export RMANSRC&#x3D;&#x2F;home&#x2F;rasdaman&#x2F;Downloads&#x2F;rasdaman # rasdaman sources</span><br><span class="line">export RASDATA&#x3D;&quot;$RMANHOME&#x2F;data&quot;</span><br><span class="line">export CATALINA_HOME&#x3D;&#x2F;var&#x2F;local&#x2F;tomcat-8.5</span><br><span class="line">export PATH&#x3D;$PATH:$RMANHOME&#x2F;bin</span><br></pre></td></tr></table></figure></li>
<li><p>确保正确加载以上配置：<code>source ～/.bashrc</code></p>
</li>
<li><p>利用CMake（v3+）以上版本进行安装，本文安装的是cmake的版本是3.11.2，对应的boost版本是1.76</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake3 ..&#x2F;rasdaman -DCMAKE_INSTALL_PREFIX&#x3D;&#x2F;var&#x2F;local&#x2F;rasdaman \</span><br><span class="line">-DFILE_DATA_DIR&#x3D;&#x2F;var&#x2F;local&#x2F;rasdaman&#x2F;data -DDEFAULT_BASEDB&#x3D;postgresql \w</span><br><span class="line">-DENABLE_PROFILING&#x3D;ON -DGENERATE_DOCS&#x3D;ON -DUSE_GRIB&#x3D;ON -DUSE_NETCDF&#x3D;ON \</span><br><span class="line">-DENABLE_BENCHMARK&#x3D;ON</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></li>
<li><p>*cmake参数的数码： **</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>可选</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>CMAKE_INSTALL_PREFIX</td>
<td><path> (default /opt/rasdaman)</td>
<td>安装目录</td>
</tr>
<tr>
<td>CMAKE_BUILD_TYPE</td>
<td>Release,Debug (default Release)</td>
<td>指定编译类型</td>
</tr>
<tr>
<td>CMAKE_VERBOSE_OUTPUT</td>
<td>ON/<strong>OFF</strong></td>
<td>是否输出make的详细信息</td>
</tr>
<tr>
<td>DEFAULT_BASEDB</td>
<td><strong>sqlite</strong>/postgresql</td>
<td>知道存储RASBASE的数据库</td>
</tr>
<tr>
<td>ENABLE_BENCHMARK</td>
<td>ON/OFF</td>
<td>生成输出的二进制文件</td>
</tr>
<tr>
<td>ENABLE_PROFILING</td>
<td>ON/OFF</td>
<td>是否用google-perftools进行分析查询</td>
</tr>
<tr>
<td>ENABLE_DEBUG</td>
<td>ON/OFF</td>
<td>生成可以调试/生成调试日志的二进制文件</td>
</tr>
<tr>
<td>ENABLE_STRICT</td>
<td>ON/OFF</td>
<td>在严格模式下启用编译(警告终止编译)</td>
</tr>
<tr>
<td>ENABLE_R</td>
<td>ON/OFF</td>
<td>是否支持R编译</td>
</tr>
<tr>
<td>GENERATE_DOCS</td>
<td>ON/OFF</td>
<td>生成安装文档</td>
</tr>
<tr>
<td>GENERATE_PIC</td>
<td>ON/OFF</td>
<td>生成位置独立的代码</td>
</tr>
<tr>
<td>ENABLE_JAVA</td>
<td>ON/OFF</td>
<td>生成和安装基于java的组件(rasj, petascope, secore)</td>
</tr>
<tr>
<td>JAVA_SERVER</td>
<td>external/embedded</td>
<td>设置Java应用程序部署模式</td>
</tr>
<tr>
<td>USE_GDAL</td>
<td>ON/OFF</td>
<td>安装的时候是否包含GDAL</td>
</tr>
<tr>
<td>USE_GRIB</td>
<td>ON/OFF</td>
<td>安装的时候是否包含GRIB</td>
</tr>
<tr>
<td>USE_HDF4</td>
<td>ON/OFF</td>
<td>安装的时候是否包含HDF4</td>
</tr>
<tr>
<td>USE_NETCDF</td>
<td>ON/OFF</td>
<td>安装的时候是否包含netCDF</td>
</tr>
<tr>
<td>FILE_DATA_DIR</td>
<td><path>(default $RMANHOME/data)</td>
<td>服务器存储切片文件地址</td>
</tr>
<tr>
<td>WAR_DIR</td>
<td><path>(default</td>
<td></td>
</tr>
<tr>
<td>$RMANHOME/share/rasdaman/war)</td>
<td>Java war 文件被安装的路径</td>
<td></td>
</tr>
</tbody></table>
<h4 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h4><ol>
<li><p>初始化rasdaman:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create_db.sh</span><br></pre></td></tr></table></figure></li>
<li><p>启动rasdaman服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start_rasdaman.sh</span><br></pre></td></tr></table></figure></li>
<li><p>导入demo数据:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rasdaman_insertdemo.sh [r]: url &quot;title&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>检查数据库是否正常:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rasql -q &#39;select c from RAS_COLLECTIONNAMES as c&#39; --out string</span><br></pre></td></tr></table></figure></li>
<li><p>停止/重启数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stop_rasdaman.sh</span><br><span class="line">start_rasdaman.sh</span><br></pre></td></tr></table></figure>
<h4 id="初始化GEO服务"><a href="#初始化GEO服务" class="headerlink" title="初始化GEO服务"></a>初始化GEO服务</h4></li>
</ol>
<h5 id="petascope"><a href="#petascope" class="headerlink" title="petascope"></a>petascope</h5><p>Petascope是rasdaman的geo Web服务前端。它在数组之上添加了geo语义，从而支持基于OGC覆盖标准的规则网格和不规则网格。</p>
<p>Petascope自动安装为rasdaman.war，除非指定了-DENABLE_JAVA=OFF cmake选项。所有war文件的部署目录可以在cmake选项设置<code>-dwarf _dir =&lt;DIR&gt;</code>;默认情况下，这是$RMANHOME/share/rasdaman/war。</p>
<p>安装petascope</p>
<ol>
<li><p><a href="http://rasdaman.org/wiki/rasdamanStoragePostgreSQL">在rasdaman下配置postgresql</a></p>
</li>
<li><p>为petascope添加一个postgresql用户:</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo -u postgres createuser -s &lt;username&gt; -P</span><br><span class="line">&gt; enter password</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><p>在<code>$RMANHOME/etc/petascope.properties </code>设置参数 <code>spring.datasource.username=petauser</code>/<code>spring.datasource.password=petapasswd</code> 和<code>metadata_user/metadata_pass</code></p>
</li>
<li><p>确保PostgreSQL允许，拷贝rasdaman.war向tomcat目录下，并启动或者重启tomcat。</p>
</li>
</ol>
<p>完全部署成功后，可以在<a href="http://localhost:8080/rasdaman/ows%E3%80%82">http://localhost:8080/rasdaman/ows。</a></p>
<h5 id="secore"><a href="#secore" class="headerlink" title="secore"></a>secore</h5><p>SECORE(语义坐标引用系统解析器)是一个将CRS url映射到CRS定义的服务。这个组件是标准rasdaman分布的一部分，被<a href="http://www.opengeospatial.org/">开放地理空间联盟</a>(OGC)用于运行他们的官方CRS解析器。Petascope使用SECORE来解析它所持有的覆盖率的CRS定义，如果SECORE作为<code>def.war</code>在本地部署，最好与Petascope的<code>rasdaman.war</code>一起部署。配置安装路径或禁用安装的方式与petascope相同。</p>
<h3 id="三、通过脚本文件安装rasdaman"><a href="#三、通过脚本文件安装rasdaman" class="headerlink" title="三、通过脚本文件安装rasdaman"></a>三、通过脚本文件安装rasdaman</h3><p>vi default.toml</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[general]</span><br><span class="line"><span class="meta">#</span><span class="bash"> The user running rasdaman</span></span><br><span class="line">user = &quot;rasdaman&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Run the installation automatically without requiring any user input</span></span><br><span class="line">auto = false</span><br><span class="line"><span class="meta">#</span><span class="bash"> Build and install rasdaman? Updating an existing installation is supported</span></span><br><span class="line">install = true</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Configure actions before rasdaman building and installation starts</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash">[pre_install]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Install third party dependencies needed to compile / run rasdaman with</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> apt-get/yum <span class="keyword">for</span> packages available <span class="keyword">in</span> the standard package manager, or with</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> pip <span class="keyword">for</span> python packages.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> If this is <span class="built_in">set</span> to <span class="literal">false</span>, the installer will just <span class="built_in">print</span> the package list and</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> probably fail compilation or some further step <span class="keyword">if</span> a package is missing.</span></span><br><span class="line">install_dependencies = true</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Configure how to install rasdaman</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash">[install]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Install rasdaman from: <span class="string">&quot;source&quot;</span> or <span class="string">&quot;package&quot;</span></span></span><br><span class="line">from = &quot;source&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Target installation directory (<span class="variable">$RMANHOME</span>)</span></span><br><span class="line">install_path = &quot;/opt/rasdaman/&quot;</span><br><span class="line"></span><br><span class="line">[install.source]</span><br><span class="line"><span class="meta">#</span><span class="bash"> Rasdaman sources will be fetched from this repo</span></span><br><span class="line">repository = &quot;git://rasdaman.org/rasdaman.git&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Rasdaman version to compile, e.g. master, v9.5.0, etc.</span></span><br><span class="line">version = &quot;master&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Generate debug-ready binaries (slower performance)</span></span><br><span class="line">debug = false</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Common servlet container settings <span class="keyword">for</span> an externally deployed petascope/SECORE.</span></span><br><span class="line">[install.webapps]</span><br><span class="line"><span class="meta">#</span><span class="bash"> Install Java web applications (petascope, SECORE)</span></span><br><span class="line">enable = true</span><br><span class="line"><span class="meta">#</span><span class="bash"> Deployment <span class="built_in">type</span>: <span class="string">&quot;external&quot;</span> (e.g. <span class="keyword">in</span> Tomcat), or <span class="string">&quot;standalone&quot;</span></span></span><br><span class="line">deployment = &quot;external&quot;</span><br><span class="line"></span><br><span class="line">[install.webapps.petascope]</span><br><span class="line"><span class="meta">#</span><span class="bash"> petascope will use this port when deployment is <span class="string">&quot;standalone&quot;</span></span></span><br><span class="line">standalone_port = 9009</span><br><span class="line"><span class="meta">#</span><span class="bash"> JDBC connection URL</span></span><br><span class="line">petascopedb_url = &quot;jdbc:postgresql://localhost:5432/petascopedb&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Database username</span></span><br><span class="line">petascopedb_username = &quot;petauser&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Database password; a random password will be generated <span class="keyword">if</span> it is empty</span></span><br><span class="line">petascopedb_password = &quot;&quot;</span><br><span class="line"></span><br><span class="line">[install.webapps.secore]</span><br><span class="line"><span class="meta">#</span><span class="bash"> SECORE will use this port when deployment is <span class="string">&quot;standalone&quot;</span></span></span><br><span class="line">standalone_port = 9010</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Configure what to do after rasdaman is installed and running</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash">[post_install]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Ingest demo collections (with rasdaman_insertdemo.sh) and demo coverages</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> (with petascope_insertdemo.sh)</span></span><br><span class="line">insert_demo = true</span><br><span class="line"><span class="meta">#</span><span class="bash"> Run the systemtest</span></span><br><span class="line">systemtest = false</span><br></pre></td></tr></table></figure>
<h4 id="第一次安装"><a href="#第一次安装" class="headerlink" title="第一次安装"></a>第一次安装</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;download.rasdaman.org&#x2F;installer&#x2F;install.sh</span><br><span class="line">bash install.sh -j default.toml</span><br></pre></td></tr></table></figure>
<h4 id="更新-1"><a href="#更新-1" class="headerlink" title="更新"></a>更新</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update_rasdaman.sh</span><br></pre></td></tr></table></figure>
<h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><p>在安过程中也许会出现cmake下载失败的错误</p>
<p>解决方法：可以先安装cmake3，安装方法<code>sudo yum install cmake3</code></p>
<p>使用配置文件安装存在会有很多缺点，出现很多意想不到的问题</p>
]]></content>
      <categories>
        <category>BigData</category>
      </categories>
      <tags>
        <tag>BigData</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux与Windows命令的比较</title>
    <url>/linux/linux_win_command/</url>
    <content><![CDATA[<h2 id="Linux与Windows命令的比较"><a href="#Linux与Windows命令的比较" class="headerlink" title="Linux与Windows命令的比较"></a>Linux与Windows命令的比较</h2><h3 id="文件目录操作"><a href="#文件目录操作" class="headerlink" title="文件目录操作"></a>文件目录操作</h3><table>
<thead>
<tr>
<th>Command</th>
<th>Linux</th>
<th>Windows</th>
</tr>
</thead>
<tbody><tr>
<td>批处理</td>
<td>.sh</td>
<td>.bat</td>
</tr>
<tr>
<td>帮助</td>
<td>cmd –help / -h</td>
<td></td>
</tr>
<tr>
<td>列出目录文件</td>
<td>ls/ ls -l</td>
<td>dir</td>
</tr>
<tr>
<td>改变当前目录</td>
<td>cd</td>
<td>cd</td>
</tr>
<tr>
<td>进父目录</td>
<td>cd ..</td>
<td>cd ..</td>
</tr>
<tr>
<td>进home目录</td>
<td>cd ~</td>
<td></td>
</tr>
<tr>
<td>复制</td>
<td>cp</td>
<td>copy</td>
</tr>
<tr>
<td>删除</td>
<td>rm file_name</td>
<td>del file_name</td>
</tr>
<tr>
<td>建目录</td>
<td>mkdir folderName</td>
<td>md folderName</td>
</tr>
<tr>
<td>建文件</td>
<td>touch fileName</td>
<td>touch fileName</td>
</tr>
<tr>
<td>删目录</td>
<td>rmdir folderName</td>
<td>rmdir folderName</td>
</tr>
<tr>
<td>设置目录文件权限</td>
<td>chmod u+rwx file</td>
<td></td>
</tr>
<tr>
<td>设置目录文件所有者</td>
<td>chown user.group file</td>
<td></td>
</tr>
</tbody></table>
<h3 id="文件内容操作"><a href="#文件内容操作" class="headerlink" title="文件内容操作"></a>文件内容操作</h3><table>
<thead>
<tr>
<th>Command</th>
<th>Linux</th>
<th>Windows</th>
</tr>
</thead>
<tbody><tr>
<td>显示文件内容</td>
<td>cat</td>
<td>type</td>
</tr>
<tr>
<td></td>
<td>more，less</td>
<td>more</td>
</tr>
<tr>
<td></td>
<td>head、tail</td>
<td></td>
</tr>
<tr>
<td>统计行数</td>
<td>wc</td>
<td></td>
</tr>
<tr>
<td>显示文件信息</td>
<td>file</td>
<td></td>
</tr>
<tr>
<td>查找文件</td>
<td>find /bin -name ls</td>
<td></td>
</tr>
<tr>
<td>定位可执行文件位置</td>
<td>which</td>
<td></td>
</tr>
<tr>
<td>在文本文件内查找</td>
<td>grep str1 1.txt</td>
<td>find</td>
</tr>
<tr>
<td>启动运行程序</td>
<td>gnome-open/open</td>
<td>start</td>
</tr>
</tbody></table>
<h3 id="系统信息查询"><a href="#系统信息查询" class="headerlink" title="系统信息查询"></a>系统信息查询</h3><a id="more"></a>
<table>
<thead>
<tr>
<th>Command</th>
<th>Linux</th>
<th>Windows</th>
</tr>
</thead>
<tbody><tr>
<td>显示内核版本</td>
<td>uname -a</td>
<td></td>
</tr>
<tr>
<td>显示发布版本</td>
<td>lsb_release -a</td>
<td></td>
</tr>
<tr>
<td></td>
<td>cat /etc/issue</td>
<td></td>
</tr>
<tr>
<td>显示id信息</td>
<td>id/whoami</td>
<td></td>
</tr>
<tr>
<td>显示当前登陆用户</td>
<td>who</td>
<td></td>
</tr>
<tr>
<td>显示当前环境信息</td>
<td>env</td>
<td></td>
</tr>
<tr>
<td>显示启动中检测到的硬件信息</td>
<td>dmesg</td>
<td></td>
</tr>
<tr>
<td>显示系统的PCI设备</td>
<td>lspci</td>
<td></td>
</tr>
<tr>
<td>显示系统的USB</td>
<td>lsusb</td>
<td></td>
</tr>
<tr>
<td>显示cpu信息</td>
<td>less /proc/cpuinfo</td>
<td></td>
</tr>
<tr>
<td>显示内存</td>
<td>less /proc/menminfo</td>
<td></td>
</tr>
<tr>
<td>显示硬盘存储信息</td>
<td>df -h</td>
<td></td>
</tr>
</tbody></table>
<h3 id="进程-任务控制"><a href="#进程-任务控制" class="headerlink" title="进程/任务控制"></a>进程/任务控制</h3><table>
<thead>
<tr>
<th>Command</th>
<th>Linux</th>
<th>Windows</th>
</tr>
</thead>
<tbody><tr>
<td>显示进程信息</td>
<td>ps -auxf</td>
<td></td>
</tr>
<tr>
<td>杀死进程</td>
<td>kill proc_id</td>
<td></td>
</tr>
<tr>
<td>杀死所有</td>
<td>killall postgresql</td>
<td></td>
</tr>
<tr>
<td>暂停中断当前前台任务</td>
<td>ctrl - z</td>
<td></td>
</tr>
<tr>
<td>恢复任务到后台</td>
<td>bg</td>
<td></td>
</tr>
<tr>
<td>恢复任务到前台</td>
<td>fg</td>
<td></td>
</tr>
</tbody></table>
<h3 id="网络命令"><a href="#网络命令" class="headerlink" title="网络命令"></a>网络命令</h3><table>
<thead>
<tr>
<th>Command</th>
<th>Linux</th>
<th>Windows</th>
</tr>
</thead>
<tbody><tr>
<td>显示启动的网络服务</td>
<td>netstat -anli  less</td>
<td>netstat</td>
</tr>
<tr>
<td>显示路由表信息</td>
<td>netstat -r</td>
<td>netstat -r</td>
</tr>
<tr>
<td>显示ip</td>
<td>ip a/ifconfig</td>
<td>ipconfig</td>
</tr>
<tr>
<td>显示防火墙信息</td>
<td>iptables -list</td>
<td></td>
</tr>
<tr>
<td>远程登陆</td>
<td>ssh user@host</td>
<td></td>
</tr>
<tr>
<td>发送ping信息</td>
<td>ping ip</td>
<td>ping ip</td>
</tr>
<tr>
<td>命令行下载</td>
<td>wget url/curl -o url</td>
<td></td>
</tr>
</tbody></table>
<h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><table>
<thead>
<tr>
<th>Command</th>
<th>Linux</th>
<th>Windows</th>
</tr>
</thead>
<tbody><tr>
<td>修改命令</td>
<td>passwd</td>
<td></td>
</tr>
<tr>
<td>创建用户</td>
<td>useradd</td>
<td></td>
</tr>
<tr>
<td>删除用户</td>
<td>userdel</td>
<td></td>
</tr>
<tr>
<td>修改用户</td>
<td>usermod</td>
<td></td>
</tr>
<tr>
<td>退出</td>
<td>exit / ctrl + D</td>
<td></td>
</tr>
<tr>
<td>切换用户至（默认root）</td>
<td>su [-]user</td>
<td></td>
</tr>
<tr>
<td>以su后的权限执行</td>
<td>sudo -u user cmd</td>
<td></td>
</tr>
</tbody></table>
<h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><ol>
<li>查看防火墙是否关闭：firewall-cmd –state</li>
<li>启动服务：systemctl start firewalld.service</li>
<li>关闭服务：systemctl stop firewalld.service</li>
<li>重启服务：systemctl restart firewalld.service</li>
<li>显示服务的状态：systemctl status firewalld.service</li>
<li>在开机时启用服务：systemctl enable firewalld.service</li>
<li>在开机时禁用服务：systemctl disable firewalld.service</li>
<li>查看服务是否开机启动：systemctl is-enabled firewalld.service;echo $?</li>
<li>查看已启动的服务列表：systemctl list-unit-files|grep enabled</li>
<li>添加开发端口：firewall-cmd –zone=public –add-port=5432/tcp –permanent</li>
<li>重新加载防火墙：firewall-cmd –reload</li>
</ol>
<h3 id="Linux挂载其他盘"><a href="#Linux挂载其他盘" class="headerlink" title="Linux挂载其他盘"></a>Linux挂载其他盘</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fdisk -l</span><br><span class="line">mkfs -t ext4 &#x2F;dev&#x2F;sdb</span><br><span class="line">mkdir &#x2F;mnt&#x2F;sdb</span><br><span class="line">mount &#x2F;dev&#x2F;sdb &#x2F;mnt&#x2F;sdb</span><br><span class="line">df -h</span><br></pre></td></tr></table></figure>
<h2 id="Linux下开放端口"><a href="#Linux下开放端口" class="headerlink" title="Linux下开放端口"></a>Linux下开放端口</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;5432&#x2F;tcp --permanent</span><br><span class="line">firewall-cmd --zone&#x3D;public --query-port&#x3D;5432&#x2F;tcp</span><br><span class="line">firewall-cmd --zone&#x3D;public --remove-port&#x3D;5432&#x2F;tcp --permanent</span><br></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><table>
<thead>
<tr>
<th>Command</th>
<th>Linux</th>
<th>Windows</th>
</tr>
</thead>
<tbody><tr>
<td>显示日期时间</td>
<td>date</td>
<td>date</td>
</tr>
<tr>
<td>日历</td>
<td>cal2014</td>
<td></td>
</tr>
<tr>
<td>清除屏幕</td>
<td>clear</td>
<td>cls</td>
</tr>
<tr>
<td>搜索软件包</td>
<td>yum search tree</td>
<td></td>
</tr>
<tr>
<td>删除软件包</td>
<td>yum remove pkg_name</td>
<td></td>
</tr>
<tr>
<td>安装软件包</td>
<td>yum install pkg_name</td>
<td></td>
</tr>
<tr>
<td>重启系统</td>
<td>reboot</td>
<td></td>
</tr>
<tr>
<td>关闭系统</td>
<td>halt -p</td>
<td></td>
</tr>
<tr>
<td>设置环境变量</td>
<td>export PATH=SPATH：～/bin</td>
<td>set</td>
</tr>
<tr>
<td>显示信息/环境变量</td>
<td>echo $HOME</td>
<td>echo</td>
</tr>
</tbody></table>
<h3 id="vi-vim编辑器使用"><a href="#vi-vim编辑器使用" class="headerlink" title="vi/vim编辑器使用"></a>vi/vim编辑器使用</h3><p>在Linux下打开vim的命令：<code>vi</code> 或者 <code>vim</code></p>
<p>vi的三种模式：</p>
<ul>
<li>ESC</li>
<li>：命令行</li>
<li>i  编辑模式</li>
</ul>
<p>** i： ** 编辑模式</p>
<p>** I： ** 行首插入</p>
<p>** a： ** 追加</p>
<p>** A： ** 行尾插入</p>
<p>** R： ** 替换文字</p>
<p>** v： ** 选择</p>
<p>** ctrl-v： ** 选择举行区域</p>
<p>** x：  ** 删除</p>
<p>** dd： ** 剪切/删除行</p>
<p>** dw： ** 剪切/删除字</p>
<p>** yy： ** 拷贝行</p>
<p>** p： ** 光标之后粘贴</p>
<p>** P： ** 光标之前粘贴</p>
<p>** r： ** 替换单个字符</p>
<p>** J： ** 连接两行</p>
<p>** /： ** 搜索</p>
<p>** n： ** 下一个搜索结果</p>
<p>** :s///：** substitute</p>
<p>** cw： ** 修改词语</p>
<p>** .: ** 重复最后一个命令</p>
<p>** u： ** 撤销</p>
<p>** ctr-r： ** 重做</p>
<p>** :w ** 保存</p>
<p>** :q ** 关闭</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Hexo在github上搭建个人博客</title>
    <url>/rests/hexo_blog_install_config/</url>
    <content><![CDATA[<h2 id="利用Hexo在github上搭建个人博客"><a href="#利用Hexo在github上搭建个人博客" class="headerlink" title="利用Hexo在github上搭建个人博客"></a>利用Hexo在github上搭建个人博客</h2><h3 id="一、前期准备"><a href="#一、前期准备" class="headerlink" title="一、前期准备"></a>一、前期准备</h3><h4 id="1-申请Github账户"><a href="#1-申请Github账户" class="headerlink" title="1. 申请Github账户"></a>1. 申请Github账户</h4><p>进入<a href="https://github.com/">Github</a>网站，按照提示进行注册，然后登录。</p>
<p><img src="hexo_blog_install_config/Github_main.png" alt="Github主界面"></p>
<p>登录完成之后，在你的主页点击图标<a href="https://github.com/new">New Repository</a>创建一个新的版本库，因为我们是使用<a href="https://pages.github.com/">Github Pages</a>去搭建我们的静态博客，所以版本库的名称应该是:<code>用户名+.github.io</code>。如：我的用户名是：javyxu，那么版本库的名字应该是：<code>javyxu.github.io</code>，这个是一定不能出错的。因为之后你将要访问的你的博客地址就是：<a href="https://javyxu.cn/">https://javyxu.cn</a> 。</p>
<p><img src="hexo_blog_install_config/new.png" alt="新建仓库界面"></p>
<p>至此，Github账号创建完成，GIthub Pages 所需要的版本库也创建好了。</p>
<h4 id="2-申请leancloud账户"><a href="#2-申请leancloud账户" class="headerlink" title="2. 申请leancloud账户"></a>2. 申请leancloud账户</h4><p>为何要注册Leancloud，因为我们的统计量、评论系统其实是放在Leancloud上的，因此首先需要去注册一个账号。<a href="https://leancloud.cn/">Leancloud官网，点我注册</a></p>
<p>注册完以后需要创建一个应用，名字可以随便起，比如<strong>blog</strong>，为了我们的评论和统计可以使用，我们新建两个Class，分别命名为<strong>Comment</strong>和<strong>Counter</strong>，如下图所示</p>
<p><img src="hexo_blog_install_config/leancloud1.png" alt="leancloud1"></p>
<p>最后进入应用-&gt;设置-&gt;应用key获取你的<strong>appid</strong>和<strong>appkey</strong>如图所示：</p>
<p><img src="hexo_blog_install_config/leancloud2.png" alt="leancloud2"></p>
<p>这两个信息在后期的主题配置文件中会用到。</p>
<h4 id="3-申请clustrmaps账户"><a href="#3-申请clustrmaps账户" class="headerlink" title="3. 申请clustrmaps账户"></a>3. 申请clustrmaps账户</h4><a id="more"></a>
<p>为何要注册clustrmaps，因为我想知道每天有些人，来自哪里的人查看了我的博客，因此首先需要去注册一个账号。<a href="https://clustrmaps.com/">clustrmaps官网，点我注册</a></p>
<p>注册完以后点击<strong>Create New Widget</strong> 创建新的网址：</p>
<p><img src="hexo_blog_install_config/clustrmaps_01.png"></p>
<p>然后选择你的<strong>Widget</strong> 类型，本人选择的是<strong>Globe Widget</strong> ：</p>
<p><img src="hexo_blog_install_config/clustrmaps_02.png"></p>
<p>然后拷贝下图显示的安装代码：</p>
<p><img src="hexo_blog_install_config/clustrmaps_03.png"></p>
<p>将代码放置在何处请看文章2-16处。</p>
<h3 id="二、-hexo安装和配置"><a href="#二、-hexo安装和配置" class="headerlink" title="二、 hexo安装和配置"></a>二、 hexo安装和配置</h3><p>Hexo的安装在其<a href="https://hexo.io/zh-cn/docs/">官方文档</a>中有很详细的说明。下面将简单介绍Hexo的安装。</p>
<h4 id="1-安装前提"><a href="#1-安装前提" class="headerlink" title="1. 安装前提"></a>1. 安装前提</h4><p>安装 Hexo 相当简单。然而在安装前，检查电脑中是否已安装下列应用程序：<code>Node.js</code>和<code>Git</code>。</p>
<ul>
<li><p>安装 git</p>
<p>Windows：下载并安装<a href="https://git-scm.com/download/win">git</a>.<br>Mac：使用<a href="https://brew.sh/">Homebrew</a>：brew install git。<br>Linux (Ubuntu, Debian)：sudo apt-get install git-core<br>Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core</p>
</li>
<li><p>安装 Node.js</p>
<p>安装Node.js的最佳方式是使用<a href="https://github.com/creationix/nvm">nvm</a>。</p>
<p>cURL:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl https:&#x2F;&#x2F;raw.github.com&#x2F;creationix&#x2F;nvm&#x2F;v0.33.11&#x2F;install.sh | sh</span><br></pre></td></tr></table></figure>
<p>Wget:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -qO- https:&#x2F;&#x2F;raw.github.com&#x2F;creationix&#x2F;nvm&#x2F;v0.33.11&#x2F;install.sh | sh</span><br></pre></td></tr></table></figure>
<p>安装完成后，重启终端并执行下列命令即可安装 Node.js。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvm install stable</span><br></pre></td></tr></table></figure>
<h4 id="2-hexo安装和配置"><a href="#2-hexo安装和配置" class="headerlink" title="2. hexo安装和配置"></a>2. hexo安装和配置</h4></li>
<li><p>安装并初始化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">hexo init hexo_blog</span><br><span class="line">cd hexo_blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></li>
<li><p>新建完成后，指定文件夹的目录如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure></li>
<li><p>_config.yml</p>
<p>可以在此配置大部分的参数。</p>
</li>
<li><p>package.json</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;name&quot;: &quot;hexo-site&quot;,</span><br><span class="line">&quot;version&quot;: &quot;0.0.0&quot;,</span><br><span class="line">&quot;private&quot;: true,</span><br><span class="line">&quot;hexo&quot;: &#123;</span><br><span class="line">  &quot;version&quot;: &quot;3.8.0&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;dependencies&quot;: &#123;</span><br><span class="line">  &quot;hexo&quot;: &quot;^3.8.0&quot;,</span><br><span class="line">  &quot;hexo-asset-image&quot;: &quot;0.0.3&quot;,</span><br><span class="line">  &quot;hexo-deployer-git&quot;: &quot;^0.3.1&quot;,</span><br><span class="line">  &quot;hexo-generator-archive&quot;: &quot;^0.1.5&quot;,</span><br><span class="line">  &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;,</span><br><span class="line">  &quot;hexo-generator-index-pin-top&quot;: &quot;^0.2.2&quot;,</span><br><span class="line">  &quot;hexo-generator-searchdb&quot;: &quot;^1.0.8&quot;,</span><br><span class="line">  &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;,</span><br><span class="line">  &quot;hexo-renderer-ejs&quot;: &quot;^0.3.1&quot;,</span><br><span class="line">  &quot;hexo-renderer-marked&quot;: &quot;^0.3.2&quot;,</span><br><span class="line">  &quot;hexo-renderer-stylus&quot;: &quot;^0.3.3&quot;,</span><br><span class="line">  &quot;hexo-server&quot;: &quot;^0.3.1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>source</p>
<p>资源文件夹是存放用户资源的地方。除<code>_posts </code>文件夹之外，开头命名为<code>_</code>(下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到<code>public</code>文件夹，而其他文件会被拷贝过去。</p>
</li>
<li><p>themes</p>
<p>是主题文件夹，Hexo会根据主题来生成不同的静态页面。</p>
</li>
<li><p>scaffolds</p>
<p>是模板件夹，当新建文章的时候，Hexo会根据模板来建立文件。</p>
</li>
</ul>
<h3 id="二、优化个人博客"><a href="#二、优化个人博客" class="headerlink" title="二、优化个人博客"></a>二、优化个人博客</h3><ol start="0">
<li>安装<code>next</code> 主题</li>
</ol>
<ul>
<li><p>下载next主题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd .&#x2F;themes</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;iissnan&#x2F;hexo-theme-next next</span><br></pre></td></tr></table></figure></li>
<li><p>修改hexo配置文件</p>
<p>vi _config.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;</span><br><span class="line">## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;</span><br><span class="line">theme: next # landscape</span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li><p>修改的站点显示信息</p>
<p>vi ./_config.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: S.T.DB  # 修改站点标题</span><br><span class="line">subtitle: Javy&#39;s Blog # 修改站点子标题</span><br><span class="line">description: # 站点描述信息</span><br><span class="line">keywords:</span><br><span class="line">author:</span><br><span class="line">email:</span><br><span class="line">language:</span><br><span class="line">timezone:</span><br></pre></td></tr></table></figure></li>
<li><p>修改菜单信息</p>
<p>vi ./theme/next/_config.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">home: &#x2F; || home</span><br><span class="line">about: &#x2F;about&#x2F; || user</span><br><span class="line">tags: &#x2F;tags&#x2F; || tags</span><br><span class="line">categories: &#x2F;categories&#x2F; || th</span><br><span class="line">archives: &#x2F;archives&#x2F; || archive</span><br></pre></td></tr></table></figure></li>
<li><p>修改背景动图</p>
<p>vi ./theme/next/_config.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Schemes</span><br><span class="line">#scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br><span class="line">scheme: Gemini 本人设置的是这种</span><br></pre></td></tr></table></figure></li>
<li><p>设置社交信息</p>
<p>vi ./theme/next/_config.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">social:</span><br><span class="line">GitHub: https:&#x2F;&#x2F;github.com&#x2F;javyxu || GitHub</span><br><span class="line">E-Mail: mailto:xujavy@gmail.com || G-Mail</span><br></pre></td></tr></table></figure></li>
<li><p>设置侧边栏的显示位置</p>
<p>vi ./theme/next/_config.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sidebar:</span><br><span class="line"># Sidebar Position, available value: left | right (only for Pisces | Gemini).</span><br><span class="line">#position: left</span><br><span class="line">position: right</span><br></pre></td></tr></table></figure></li>
<li><p>设置站点显示头像图片</p>
<p>vi ./theme/next/_config.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Sidebar Avatar</span><br><span class="line"># in theme directory(source&#x2F;images): &#x2F;images&#x2F;avatar.gif</span><br><span class="line"># in site  directory(source&#x2F;uploads): &#x2F;uploads&#x2F;avatar.gif</span><br><span class="line">#avatar: &#x2F;images&#x2F;avatar.gif</span><br><span class="line">avatar: &#x2F;images&#x2F;avatar.jpg</span><br></pre></td></tr></table></figure>
<p>讲头像图片放置在根目录下的imgaes下</p>
</li>
<li><p>设置查询</p>
<p>vi ./_config.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure></li>
<li><p>设置底部心形图标</p>
<p>vi ./themes/next/layout/_partials/footer.swig</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;span class&#x3D;&quot;with-love&quot;&gt;</span><br><span class="line">  &lt;!-- &lt;i class&#x3D;&quot;fa fa-&#123;&#123; theme.footer.icon &#125;&#125;&quot;&gt;&lt;&#x2F;i&gt; --&gt;</span><br><span class="line">  &lt;i class&#x3D;&quot;fa fa-heart&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>发布文章中图片的显示</p>
<p>图片除了可以放在统一的images文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置_config.yml来生成。</p>
<p>vi ./_config.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure>
<p>执行命令<code>hexo new post_name</code>，在source/_posts中会生成文章post_name.md和同名文件夹post_name。将图片资源放在post_name中，文章就可以使用相对路径引用图片资源了。</p>
<p><code>![imgae](post_name/image.jpg)</code></p>
</li>
<li><p>设置文章阅读量</p>
<p>vi ./themes/next/layout/_partials/footer.swig</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Show number of visitors to each article.</span><br><span class="line"># You can visit https:&#x2F;&#x2F;leancloud.cn get AppID and AppKey.</span><br><span class="line">leancloud_visitors:</span><br><span class="line">  enable: true</span><br><span class="line">  app_id: #&lt;app_id&gt;</span><br><span class="line">  app_key: #&lt;app_key&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>设置博客访问人次和总体访问量</p>
<p>vi ./theme/next/_config.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Show PV&#x2F;UV of the website&#x2F;page with busuanzi.</span><br><span class="line"># Get more information on http:&#x2F;&#x2F;ibruce.info&#x2F;2015&#x2F;04&#x2F;04&#x2F;busuanzi&#x2F;</span><br><span class="line">busuanzi_count:</span><br><span class="line">  # count values only if the other configs are false</span><br><span class="line">  enable: true</span><br><span class="line">  # custom uv span for the whole site</span><br><span class="line">  site_uv: true</span><br><span class="line">  site_uv_header: &lt;i class&#x3D;&quot;fa fa-user&quot;&gt;&lt;&#x2F;i&gt; 访问人数</span><br><span class="line">  site_uv_footer: 人次</span><br><span class="line">  # custom pv span for the whole site</span><br><span class="line">  site_pv: true</span><br><span class="line">  site_pv_header: &lt;i class&#x3D;&quot;fa fa-eye&quot;&gt;&lt;&#x2F;i&gt; 总访问量</span><br><span class="line">  site_pv_footer: 次</span><br><span class="line">  # custom pv span for one page only</span><br><span class="line">  page_pv: false</span><br><span class="line">  page_pv_header: &lt;i class&#x3D;&quot;fa fa-file-o&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">  page_pv_footer:</span><br></pre></td></tr></table></figure>
<p>vi ./themes/next/layout/_partials/footer.swig</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script async src&#x3D;&quot;&#x2F;&#x2F;busuanzi.ibruce.info&#x2F;busuanzi&#x2F;2.3&#x2F;busuanzi.pure.mini.js&quot;&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>设置评论区</p>
<p>vi ./theme/next/_config.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Valine.</span><br><span class="line"># You can get your appid and appkey from https:&#x2F;&#x2F;leancloud.cn</span><br><span class="line"># more info please open https:&#x2F;&#x2F;valine.js.org</span><br><span class="line">valine:</span><br><span class="line">  enable: true</span><br><span class="line">  appid:  # your leancloud application appid</span><br><span class="line">  appkey: # your leancloud application appkey</span><br><span class="line">  notify: true # mail notifier , https:&#x2F;&#x2F;github.com&#x2F;xCss&#x2F;Valine&#x2F;wiki</span><br><span class="line">  verify: true # Verification code</span><br><span class="line">  placeholder: 留言 # comment box placeholder</span><br><span class="line">  avatar: mm # gravatar style</span><br><span class="line">  guest_info: nick,mail,link # custom comment header</span><br><span class="line">  pageSize: 10 # pagination size</span><br></pre></td></tr></table></figure></li>
<li><p>配置博客置顶</p>
<p>为了防止每次更新、安装都要修改代码，现在可以直接从仓库里安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure>
<p>然后在需要置顶的文章的<code>Front-matter</code>中加上<code>top: true</code>即可。</p>
</li>
<li><p>显示文章摘要</p>
</li>
</ol>
<ul>
<li><p>在文章中使用<code>&lt; !--more--&gt;</code>手动进行截断<br>这种方法可以根据文章的内容，自己在合适的位置添加<code>&lt; !--more--&gt;</code>标签，使用灵活，也是Hexo推荐的方法。</p>
</li>
<li><p>在文章中的<code>front-matter</code>中添加<code>description</code>，并提供文章摘录<br>这种方式只会在首页列表中显示文章的摘要内容，进入文章详情后不会再显示。</p>
</li>
<li><p>自动形成摘要，在主题配置文件中添加,默认截取的长度为<code>150</code>字符，可以根据需要自行设定</p>
<p>vi ./theme/next/_config.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auto_excerpt:</span><br><span class="line">  enable: true</span><br><span class="line">  length: 150</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="10">
<li>添加搜索功能</li>
</ol>
<ul>
<li><p>安装 hexo-generator-searchdb 插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure></li>
<li><p>vi ./_config.xml2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">    path: search.xml</span><br><span class="line">    field: post</span><br><span class="line">    format: html</span><br><span class="line">    limit: 10000</span><br></pre></td></tr></table></figure></li>
<li><p>vi ./theme/next/_config.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="11">
<li><p>在侧边栏显示地球统计</p>
<p>将<strong>Globe Widget Installation</strong>拷贝的代码，添加到 <strong>./theme/next/_custom/sidebar.swig</strong> 中即可。</p>
<p>最终显示结果，请看本人博客主页。</p>
</li>
</ol>
<h3 id="三、-生成和发布"><a href="#三、-生成和发布" class="headerlink" title="三、 生成和发布"></a>三、 生成和发布</h3>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean # 清除之前生成的静态页面</span><br><span class="line">hexo generate # 生成静态页面，生成的内容在public文件夹下</span><br><span class="line">hexo server # 启动本地服务，进行文章预览调试。hexo</span><br><span class="line">hexo deploy # 部署到github</span><br></pre></td></tr></table></figure>
<h4 id="四、-部署在github上"><a href="#四、-部署在github上" class="headerlink" title="四、 部署在github上"></a>四、 部署在github上</h4><ul>
<li><p>安装部署插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo --save</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li>
<li><p>配置git账户信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;your name&quot;</span><br><span class="line">git config --global user.email &quot;email@email.com&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>修改hexo配置文件</p>
<p>vi ./_config.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo:</span><br><span class="line">      github: git@github.com:javyxu&#x2F;javyxu.github.io.git,master</span><br></pre></td></tr></table></figure>
<h3 id="五、如何备份已发布的博客"><a href="#五、如何备份已发布的博客" class="headerlink" title="五、如何备份已发布的博客"></a>五、如何备份已发布的博客</h3></li>
</ul>
<p>最终设计结果，请看<a href="https://javyxu.cn/Rests/hexo_blog_install_config/">本人博客</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo、个人博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>在Fusion下设置固定IP</title>
    <url>/rests/setting_fusion_fixed_ip/</url>
    <content><![CDATA[<p>最近在Mac上用Fusion跑Linux，主要是用来做server端的开发，但是在开发过程中发现，虚拟机只要重新启动，IP地址便会跟着发生变化，这很是让人烦恼。</p>
<p>后来想着如何能让虚机IP固定下来呢，Google良久，终于有可固定的解决方式，下面请看详细解决步骤。</p>
<p>我本人的环境是，<code>macOS</code>版本是<code>10.14.1</code>，<code>VMware Fusion</code>的版本是<code>Professional Version 11.0.0 (10120384)</code>。</p>
<h3 id="1-查询虚拟机的MAC地址"><a href="#1-查询虚拟机的MAC地址" class="headerlink" title="1. 查询虚拟机的MAC地址"></a>1. 查询虚拟机的MAC地址</h3><p>话不多说，直接上图</p>
<p>设置-网络适配器</p>
<p><img src="Setting_Fusion_Fixed_IP/1.png"></p>
<p>设置-网络是配置-MAC地址</p>
<p><img src="Setting_Fusion_Fixed_IP/2.png"></p>
<h3 id="2-修改dhcpd-conf"><a href="#2-修改dhcpd-conf" class="headerlink" title="2. 修改dhcpd.conf"></a>2. 修改dhcpd.conf</h3><a id="more"></a>
<p>dhcpd.conf位于目录/Library/Preferences/VMware Fusion/vmnet8。</p>
<p>用你最喜欢的文本编辑器打开/Library/Preferences/VMware Fusion/vmnet8/dhcpd.conf，我这里用vim，需要用管理员权限<code>sudo</code>,如下所示：<br><code>sudo vim /Library/Preferences/VMware\ Fusion/vmnet8/dhcpd.conf</code><br>看到的内容大概是这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Configuration file for ISC 2.0 vmnet-dhcpd operating on vmnet8.</span><br><span class="line">#</span><br><span class="line"># This file was automatically generated by the VMware configuration program.</span><br><span class="line"># See Instructions below if you want to modify it.</span><br><span class="line">#</span><br><span class="line"># We set domain-name-servers to make some DHCP clients happy</span><br><span class="line"># (dhclient as configured in SuSE, TurboLinux, etc.).</span><br><span class="line"># We also supply a domain name to make pump (Red Hat 6.x) happy.</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###### VMNET DHCP Configuration. Start of &quot;DO NOT MODIFY SECTION&quot; #####</span><br><span class="line"># Modification Instructions: This section of the configuration file contains</span><br><span class="line"># information generated by the configuration program. Do not modify this</span><br><span class="line"># section.</span><br><span class="line"># You are free to modify everything else. Also, this section must start</span><br><span class="line"># on a new line</span><br><span class="line"># This file will get backed up with a different name in the same directory</span><br><span class="line"># if this section is edited and you try to configure DHCP again.</span><br><span class="line"></span><br><span class="line"># Written at: 11&#x2F;05&#x2F;2018 15:38:24</span><br><span class="line">allow unknown-clients;</span><br><span class="line">default-lease-time 1800;                # default is 30 minutes</span><br><span class="line">max-lease-time 7200;                    # default is 2 hours</span><br><span class="line"></span><br><span class="line">subnet 172.16.151.0 netmask 255.255.255.0 &#123;</span><br><span class="line">       range 172.16.151.128 172.16.151.254;</span><br><span class="line">       option broadcast-address 172.16.151.255;</span><br><span class="line">       option domain-name-servers 172.16.151.2;</span><br><span class="line">       option domain-name localdomain;</span><br><span class="line">       default-lease-time 1800;                # default is 30 minutes</span><br><span class="line">       max-lease-time 7200;                    # default is 2 hours</span><br><span class="line">       option netbios-name-servers 172.16.151.2;</span><br><span class="line">       option routers 172.16.151.2;</span><br><span class="line">&#125;</span><br><span class="line">host vmnet8 &#123;</span><br><span class="line">       hardware ethernet 00:50:56:C0:00:08;</span><br><span class="line">       fixed-address 172.16.151.1;</span><br><span class="line">       option domain-name-servers 0.0.0.0;</span><br><span class="line">       option domain-name &quot;&quot;;</span><br><span class="line">       option routers 0.0.0.0;</span><br><span class="line">&#125;</span><br><span class="line">####### VMNET DHCP Configuration. End of &quot;DO NOT MODIFY SECTION&quot; #######</span><br><span class="line"></span><br><span class="line">host Ubuntu &#123;</span><br><span class="line">       hardware ethernet 00:0C:29:F1:67:98;</span><br><span class="line">       fixed-address 172.16.151.188;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>** 有三行内容值得注意：**</p>
<ul>
<li>第1行，<code>Ubuntu</code> 是虚拟机的名字，看下图，注意要拼写要完全一致。</li>
</ul>
<p><img src="Setting_Fusion_Fixed_IP/3.png"></p>
<p><img src="Setting_Fusion_Fixed_IP/4.png"></p>
<ul>
<li><p>第2行，<code>00:0C:29:F1:67:98</code>是上一步获取的MAC地址。</p>
</li>
<li><p>第3行，192.168.110.130是要设置的固定IP地址，注意要在虚拟机的IP网段，一般情况下就用上次虚拟机运行时的动态IP就可以了。</p>
</li>
</ul>
<h3 id="3-重启VMWare-Fusion"><a href="#3-重启VMWare-Fusion" class="headerlink" title="3. 重启VMWare Fusion"></a>3. 重启VMWare Fusion</h3><p>必须重启VMWare Fusion才能使上边的设置生效。</p>
<h3 id="4-启动虚拟机"><a href="#4-启动虚拟机" class="headerlink" title="4. 启动虚拟机"></a>4. 启动虚拟机</h3><p>此时在启动虚拟机，你会发现虚拟机的地址不会再变来变去了，永远是你在步骤2设置的固定IP。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>macOS、Fusion</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown Syntax</title>
    <url>/rests/markdown_synatx/</url>
    <content><![CDATA[<h3 id="Heading"><a href="#Heading" class="headerlink" title="Heading"></a>Heading</h3><p><code># h1</code></p>
<h1 id="h1"><a href="#h1" class="headerlink" title="h1"></a>h1</h1><p><code>## h2</code></p>
<h2 id="h2"><a href="#h2" class="headerlink" title="h2"></a>h2</h2><p><code>### h3</code></p>
<h3 id="h3"><a href="#h3" class="headerlink" title="h3"></a>h3</h3><p><code>#### h4</code></p>
<h4 id="h4"><a href="#h4" class="headerlink" title="h4"></a>h4</h4><p><code>#### h5</code></p>
<h4 id="h5"><a href="#h5" class="headerlink" title="h5"></a>h5</h4><p><code>##### h6</code></p>
<h5 id="h6"><a href="#h6" class="headerlink" title="h6"></a>h6</h5><h3 id="Comments"><a href="#Comments" class="headerlink" title="Comments"></a>Comments</h3><p><code>&lt;!-- This is a comment! --&gt;</code></p>
<h3 id="Horizontal-Rules"><a href="#Horizontal-Rules" class="headerlink" title="Horizontal Rules"></a>Horizontal Rules</h3><h2 id=""><a href="#" class="headerlink" title="---"></a><code>---</code></h2><p><code>***</code></p>
<hr>
<h3 id="Emphasis"><a href="#Emphasis" class="headerlink" title="Emphasis"></a>Emphasis</h3><p><code>**This is Bold Text!**</code><br><strong>This is Bold Text!</strong></p>
<p><code>__This is Bold Text!__</code><br><strong>This is Bold Text!</strong></p>
<p><code>*This is Italic  Text!*</code><br><em>This is Italic  Text!</em></p>
<p><code>_This is Italic Text!_</code><br><em>This is Italic Text!</em></p>
<p><code>~~This is StrikeThrough Text!~~</code><br><del>This is StrikeThrough Text!</del></p>
<h3 id="Bolck-Quotes"><a href="#Bolck-Quotes" class="headerlink" title="Bolck Quotes"></a>Bolck Quotes</h3><p><code>&gt; This is BlockQuotes</code></p>
<p><code>&gt;&gt; This is test</code></p>
<p><code>&gt;&gt;&gt; This is Notes!</code></p>
<blockquote>
<p>This is BlockQuotes</p>
<blockquote>
<p>This is test</p>
<blockquote>
<p>This is Notes!</p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><a id="more"></a>
<h4 id="Unordered"><a href="#Unordered" class="headerlink" title="Unordered"></a>Unordered</h4><p><code>* + -</code>: 可以实现无序排列</p>
<p><code>[ ] [x]</code>: 表示复选框， <code>[ ]</code>表示未选中， <code>[x]</code>表示选中</p>
<p>Sample：</p>
<ul>
<li>Language<ul>
<li>C Family<ul>
<li><input disabled="" type="checkbox"> C</li>
<li><input checked="" disabled="" type="checkbox"> C++</li>
</ul>
</li>
<li>Python</li>
<li>Java</li>
</ul>
</li>
<li>System<ul>
<li>Linux<ul>
<li>CentOS</li>
<li>Redhat</li>
</ul>
</li>
<li>MacOS</li>
<li>Windows</li>
</ul>
</li>
</ul>
<h4 id="Ordered"><a href="#Ordered" class="headerlink" title="Ordered"></a>Ordered</h4><p><code>1. 2. 3. 4. ...</code>:数字之后加入. 便可以表示序列`</p>
<p>Sample：</p>
<ol>
<li>test01</li>
<li>test02</li>
<li>test03</li>
<li>test04</li>
</ol>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><h4 id="Inline-Code"><a href="#Inline-Code" class="headerlink" title="Inline Code"></a>Inline Code</h4><p><code>In this Example `&lt;Section&gt;  &lt;/Section&gt;` Should be Wrapped with **Code**</code></p>
<p>In this Example <code>&lt;Section&gt;  &lt;/Section&gt;</code> Should be Wrapped with <strong>Code</strong></p>
<h4 id="Indented-Code"><a href="#Indented-Code" class="headerlink" title="Indented Code"></a>Indented Code</h4><p>None</p>
<h4 id="block-code-“fences”"><a href="#block-code-“fences”" class="headerlink" title="block code “fences”"></a>block code “fences”</h4><p><code>```markup Sample text here...```</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sample text here...</span><br></pre></td></tr></table></figure>
<h4 id="Syntax-Highlighting"><a href="#Syntax-Highlighting" class="headerlink" title="Syntax Highlighting"></a>Syntax Highlighting</h4><p><code>```python .... ```</code> 此处的Python可以换为其他的语言，js、c…</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@requires_authorization</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">FuncName</span>(<span class="params">param1=<span class="string">&#x27;&#x27;</span>, param2=<span class="number">0</span></span>):</span></span><br><span class="line">  <span class="string">&#x27;&#x27;&#x27;A docstring&#x27;&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">if</span> param1 &gt; param2: <span class="comment"># intersting</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;Greater&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> (param2 - param1 + <span class="number">1</span>) <span class="keyword">or</span> <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;docstring for .&quot;&quot;&quot;</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, arg</span>):</span></span><br><span class="line">    <span class="built_in">super</span>(, self).__init__()</span><br><span class="line">    self.arg = arg</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>message = <span class="string">&#x27;&#x27;&#x27;interpreter</span></span><br><span class="line"><span class="string"><span class="meta">... </span>prompt&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="Tables"><a href="#Tables" class="headerlink" title="Tables"></a>Tables</h3><pre><code>| Option | Description |
| ------ | ----------- |
| data   | path to data files to supply the data that will be passed into templates. |
| engine | engine to be used for processing templates. Handlebars is the default. |
| ext    | extension to be used for dest files. |```

|Colum | Colum | Colum
|-----:|:-----:|------
|row   | row   | row
|row2  | row2  | row2

#### Aligned text

`-----:` Right Aligned

`:-----` Left Aligned

`:----:` Center Aligned

### Links
#### Basic Links
`[Assemble](http://assemble.io)`

[Assemble](http://assemble.io)
#### Add a Title
`[Upstage](https://github.com/upstage/ &quot;Visit Upstage!&quot;)`

[Upstage](https://github.com/upstage/ &quot;Visit Upstage!&quot;)
#### Named Anchors
##### Table of Comments
 * [chaptor 1]

### Images
`![minion](http://octodex.github.com/images/minion.png)`
![minion](http://octodex.github.com/images/minion.png)
`![alt text](http://octodex.github.com/images/stormtroopocat.jpg &quot;The Stormtroopocat&quot;)`
![alt text](http://octodex.github.com/images/stormtroopocat.jpg &quot;The Stormtroopocat&quot;)
`![alt text][id]
[id]:http://octodex.github.com/images/dojocat.jpg  &quot;The Dojocat&quot;`
![alt text][id]
[id]:http://octodex.github.com/images/dojocat.jpg  &quot;The Dojocat&quot;

### Footnote
`This is a Footnote[^footnote]`
This is a Footnote[^footnote]

`[^footnote]: This is **Footnote** *Content*.`
[^footnote]: This is **Footnote** *Content*.

### Reference
[GRAV](https://learn.getgrav.org/content/markdown)
</code></pre>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown编辑器语法——设置字体、字号和颜色</title>
    <url>/rests/markdown_font/</url>
    <content><![CDATA[<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>Markdown是一种可以使用普通文本编辑器编写的标记语言，类似于HTML的标记语法，可以在普通文本内具有一定的格式。但是他本身不支持修改字体、字号和颜色，所以在Markdown中要写实现字体颜色、字号的设置，需要使用内嵌的HTML。实现如下所示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;宋体&quot;</span>&gt;</span>宋体<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;黑体&quot;</span> <span class="attr">color</span>=<span class="string">red</span>&gt;</span>红色黑体<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;黑体&quot;</span> <span class="attr">color</span>=<span class="string">red</span> <span class="attr">size</span>=<span class="string">7</span>&gt;</span>7号红色黑体<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><font size=5><strong>显示结果：</strong></font><br><br><font face="宋体">宋体</font><br><br><font face="黑体" color=red>红色黑体</font><br><br><font face="黑体" color=red size=7>7号红色黑体</font><br></p>
<h3 id="颜色表"><a href="#颜色表" class="headerlink" title="颜色表"></a>颜色表</h3><a id="more"></a>
<p>| 颜色名 | 十六进制颜色值 | RGB值 | 颜色  |<br>|:——|:———— |:—–|<br>| liceBlue | #F0F8FF | rgb(240, 248, 255) <td bgcolor=liceBlue></td>|<br>| AntiqueWhite | #FAEBD7    | rgb(250, 235, 215) <td bgcolor=AntiqueWhite></td>|<br>| Aqua | #00FFFF | rgb(0, 255, 255) <td bgcolor=Aqua></td>|<br>| Aquamarine |    #7FFFD4 |    rgb(127, 255, 212) <td bgcolor=Aquamarine></td>|<br>| Azure |    #F0FFFF |    rgb(240, 255, 255) <td bgcolor=Azure></td>|<br>| Beige |    #F5F5DC |    rgb(245, 245, 220) <td bgcolor=Beige></td>|<br>| Bisque |    #FFE4C4 |    rgb(255, 228, 196) <td bgcolor=Bisque></td>|<br>| Black |    #000000 |    rgb(0, 0, 0) <td bgcolor=Black></td>|<br>| BlanchedAlmond |    #FFEBCD |    rgb(255, 235, 205) <td bgcolor=BlanchedAlmond></td>|<br>| Blue |    #0000FF |    rgb(0, 0, 255) <td bgcolor=Blue></td>|<br>| BlueViolet |    #8A2BE2 |    rgb(138, 43, 226) <td bgcolor=BlueViolet></td>|<br>| Brown |    #A52A2A |    rgb(165, 42, 42) <td bgcolor=Brown></td>|<br>| BurlyWood |    #DEB887 |    rgb(222, 184, 135) <td bgcolor=BurlyWood></td>|<br>| CadetBlue |    #5F9EA0 |    rgb(95, 158, 160) <td bgcolor=CadetBlue></td>|<br>| Chartreuse |    #7FFF00 |    rgb(127, 255, 0) <td bgcolor=Chartreuse></td>|<br>| Chocolate |    #D2691E |    rgb(210, 105, 30) <td bgcolor=Chocolate></td>|<br>| Coral |    #FF7F50 |    rgb(255, 127, 80) <td bgcolor=Coral></td>|<br>| CornflowerBlue |    #6495ED |    rgb(100, 149, 237) <td bgcolor=CornflowerBlue></td>|<br>| Cornsilk |    #FFF8DC |    rgb(255, 248, 220) <td bgcolor=Cornsilk></td>|<br>| Crimson |    #DC143C |    rgb(220, 20, 60) <td bgcolor=Crimson></td>|<br>| Cyan |    #00FFFF |    rgb(0, 255, 255) <td bgcolor=Cyan></td>|<br>| DarkBlue |    #00008B |    rgb(0, 0, 139) <td bgcolor=DarkBlue></td>|<br>| DarkCyan |    #008B8B |    rgb(0, 139, 139) <td bgcolor=DarkCyan></td>|<br>| DarkGoldenRod |    #B8860B |    rgb(184, 134, 11) <td bgcolor=DarkGoldenRod></td>|<br>| DarkGray |    #A9A9A9 |    rgb(169, 169, 169) <td bgcolor=DarkGray></td>|<br>| DarkGreen |    #006400 |    rgb(0, 100, 0) <td bgcolor=DarkGreen></td>|<br>| DarkKhaki |    #BDB76B |    rgb(189, 183, 107) <td bgcolor=DarkKhaki></td>|<br>| DarkMagenta |    #8B008B |    rgb(139, 0, 139) <td bgcolor=DarkMagenta></td>|<br>| DarkOliveGreen |    #556B2F |    rgb(85, 107, 47) <td bgcolor=DarkOliveGreen></td>|<br>| Darkorange |    #FF8C00 |    rgb(255, 140, 0) <td bgcolor=Darkorange></td>|<br>| DarkOrchid |    #9932CC |    rgb(153, 50, 204) <td bgcolor=DarkOrchid></td>|<br>| DarkRed |    #8B0000 |    rgb(139, 0, 0) <td bgcolor=DarkRed></td>|<br>| DarkSalmon |    #E9967A |    rgb(233, 150, 122) <td bgcolor=DarkSalmon></td>|<br>| DarkSeaGreen |    #8FBC8F |    rgb(143, 188, 143) <td bgcolor=DarkSeaGreen></td>|<br>| DarkSlateBlue |    #483D8B |    rgb(72, 61, 139) <td bgcolor=DarkSlateBlue></td>|<br>| DarkSlateGray |    #2F4F4F |    rgb(47, 79, 79) <td bgcolor=DarkSlateGray></td>|<br>| DarkTurquoise |    #00CED1 |    rgb(0, 206, 209) <td bgcolor=DarkTurquoise></td>|<br>| DarkViolet |    #9400D3 |    rgb(148, 0, 211) <td bgcolor=DarkViolet></td>|<br>| DeepPink |    #FF1493 |    rgb(255, 20, 147) <td bgcolor=DeepPink></td>|<br>| DeepSkyBlue |    #00BFFF |    rgb(0, 191, 255) <td bgcolor=DeepSkyBlue></td>|<br>| DimGray |    #696969 |    rgb(105, 105, 105) <td bgcolor=DimGray></td>|<br>| DodgerBlue |    #1E90FF |    rgb(30, 144, 255) <td bgcolor=DodgerBlue></td>|<br>| Feldspar |    #D19275 |    rgb(209, 146, 117) <td bgcolor=Feldspar></td>|<br>| FireBrick |    #B22222 |    rgb(178, 34, 34) <td bgcolor=FireBrick></td>|<br>| FloralWhite |    #FFFAF0 |    rgb(255, 250, 240) <td bgcolor=FloralWhite></td>|<br>| ForestGreen |    #228B22 |    rgb(34, 139, 34) <td bgcolor=ForestGreen></td>|<br>| Fuchsia |    #FF00FF |    rgb(255, 0, 255) <td bgcolor=Fuchsia></td>|<br>| Gainsboro |    #DCDCDC |    rgb(220, 220, 220) <td bgcolor=Gainsboro></td>|<br>| GhostWhite |    #F8F8FF |    rgb(248, 248, 255) <td bgcolor=GhostWhite></td>|<br>| Gold |    #FFD700 |    rgb(255, 215, 0) <td bgcolor=Gold></td>|<br>| GoldenRod |    #DAA520 |    rgb(218, 165, 32) <td bgcolor=GoldenRod></td>|<br>| Gray |    #808080 |    rgb(128, 128, 128) <td bgcolor=Gray></td>|<br>| Green |    #008000 |    rgb(0, 128, 0) <td bgcolor=Green></td>|<br>| GreenYellow |    #ADFF2F |    rgb(173, 255, 47) <td bgcolor=GreenYellow></td>|<br>| HoneyDew |    #F0FFF0 |    rgb(240, 255, 240) <td bgcolor=HoneyDew></td>|<br>| HotPink |    #FF69B4 |    rgb(255, 105, 180) <td bgcolor=HotPink></td>|<br>| IndianRed |    #CD5C5C |    rgb(205, 92, 92) <td bgcolor=IndianRed></td>|<br>| Indigo |    #4B0082 |    rgb(75, 0, 130) <td bgcolor=Indigo></td>|<br>| Ivory |    #FFFFF0 |    rgb(255, 255, 240) <td bgcolor=Ivory></td>|<br>| Khaki |    #F0E68C |    rgb(240, 230, 140) <td bgcolor=Khaki></td>|<br>| Lavender |    #E6E6FA |    rgb(230, 230, 250) <td bgcolor=Lavender></td>|<br>| LavenderBlush |    #FFF0F5 |    rgb(255, 240, 245) <td bgcolor=LavenderBlush></td>|<br>| LawnGreen |    #7CFC00 |    rgb(124, 252, 0) <td bgcolor=LawnGreen></td>|<br>| LemonChiffon |    #FFFACD |    rgb(255, 250, 205) <td bgcolor=LemonChiffon></td>|<br>| LightBlue |    #ADD8E6 |    rgb(173, 216, 230) <td bgcolor=LightBlue></td>|<br>| LightCoral |    #F08080 |    rgb(240, 128, 128) <td bgcolor=LightCoral></td>|<br>| LightCyan |    #E0FFFF |    rgb(224, 255, 255) <td bgcolor=LightCyan></td>|<br>| LightGoldenRodYellow |    #FAFAD2 |    rgb(250, 250, 210) <td bgcolor=LightGoldenRodYellow></td>|<br>| LightGrey |    #D3D3D3 |    rgb(211, 211, 211) <td bgcolor=LightGrey></td>|<br>| LightGreen |    #90EE90 |    rgb(144, 238, 144) <td bgcolor=LightGreen></td>|<br>| LightPink |    #FFB6C1 |    rgb(255, 182, 193) <td bgcolor=LightPink></td>|<br>| LightSalmon |    #FFA07A |    rgb(255, 160, 122) <td bgcolor=LightSalmon></td>|<br>| LightSeaGreen |    #20B2AA |    rgb(32, 178, 170) <td bgcolor=LightSeaGreen></td>|<br>| LightSkyBlue |    #87CEFA |    rgb(135, 206, 250) <td bgcolor=LightSkyBlue></td>|<br>| LightSlateBlue |    #8470FF |    rgb(132, 112, 255) <td bgcolor=LightSlateBlue></td>|<br>| LightSlateGray |    #778899 |    rgb(119, 136, 153) <td bgcolor=LightSlateGray></td>|<br>| LightSteelBlue |    #B0C4DE |    rgb(176, 196, 222) <td bgcolor=LightSteelBlue></td>|<br>| LightYellow |    #FFFFE0 |    rgb(255, 255, 224) <td bgcolor=LightYellow></td>|<br>| Lime |    #00FF00 |    rgb(0, 255, 0) <td bgcolor=Lime></td>|<br>| LimeGreen |    #32CD32 |    rgb(50, 205, 50) <td bgcolor=LimeGreen></td>|<br>| Linen |    #FAF0E6 |    rgb(250, 240, 230) <td bgcolor=Linen></td>|<br>| Magenta |    #FF00FF |    rgb(255, 0, 255) <td bgcolor=Magenta></td>|<br>| Maroon |    #800000 |    rgb(128, 0, 0) <td bgcolor=Maroon></td>|<br>| MediumAquaMarine |    #66CDAA |    rgb(102, 205, 170) <td bgcolor=MediumAquaMarine></td>|<br>| MediumBlue |    #0000CD |    rgb(0, 0, 205) <td bgcolor=MediumBlue></td>|<br>| MediumOrchid |    #BA55D3 |    rgb(186, 85, 211) <td bgcolor=MediumOrchid></td>|<br>| MediumPurple |    #9370D8 |    rgb(147, 112, 216) <td bgcolor=MediumPurple></td>|<br>| MediumSeaGreen |    #3CB371 |    rgb(60, 179, 113) <td bgcolor=MediumSeaGreen></td>|<br>| MediumSlateBlue |    #7B68EE |    rgb(123, 104, 238) <td bgcolor=AntiqueWhite></td>|<br>| MediumSpringGreen |    #00FA9A |    rgb(0, 250, 154) <td bgcolor=MediumSpringGreen></td>|<br>| MediumTurquoise |    #48D1CC |    rgb(72, 209, 204) <td bgcolor=MediumTurquoise></td>|<br>| MediumVioletRed |    #C71585 |    rgb(199, 21, 133) <td bgcolor=MediumVioletRed></td>|<br>| MidnightBlue |    #191970 |    rgb(25, 25, 112) <td bgcolor=AntiqueWhite></td>|<br>| MintCream |    #F5FFFA |    rgb(245, 255, 250) <td bgcolor=MintCream></td>|<br>| MistyRose |    #FFE4E1 |    rgb(255, 228, 225) <td bgcolor=MistyRose></td>|<br>| Moccasin |    #FFE4B5 |    rgb(255, 228, 181) <td bgcolor=Moccasin></td>|<br>| NavajoWhite |    #FFDEAD |    rgb(255, 222, 173) <td bgcolor=NavajoWhite></td>|<br>| Navy |    #000080 |    rgb(0, 0, 128) <td bgcolor=Navy></td>|<br>| OldLace |    #FDF5E6 |    rgb(253, 245, 230) <td bgcolor=OldLace></td>|<br>| Olive |    #808000 |    rgb(128, 128, 0) <td bgcolor=Olive></td>|<br>| OliveDrab |    #6B8E23 |    rgb(107, 142, 35) <td bgcolor=OliveDrab></td>|<br>| Orange |    #FFA500 |    rgb(255, 165, 0) <td bgcolor=Orange></td>|<br>| OrangeRed |    #FF4500 |    rgb(255, 69, 0) <td bgcolor=OrangeRed></td>|<br>| Orchid |    #DA70D6 |    rgb(218, 112, 214) <td bgcolor=Orchid></td>|<br>| PaleGoldenRod |    #EEE8AA |    rgb(238, 232, 170) <td bgcolor=PaleGoldenRod></td>|<br>| PaleGreen |    #98FB98 |    rgb(152, 251, 152) <td bgcolor=PaleGreen></td>|<br>| PaleTurquoise |    #AFEEEE |    rgb(175, 238, 238) <td bgcolor=PaleTurquoise></td>|<br>| PaleVioletRed |    #D87093 |    rgb(216, 112, 147) <td bgcolor=PaleVioletRed></td>|<br>| PapayaWhip |    #FFEFD5 |    rgb(255, 239, 213) <td bgcolor=PapayaWhip></td>|<br>| PeachPuff |    #FFDAB9 |    rgb(255, 218, 185) <td bgcolor=PeachPuff></td>|<br>| Peru |    #CD853F |    rgb(205, 133, 63) <td bgcolor=Peru></td>|<br>| Pink |    #FFC0CB |    rgb(255, 192, 203) <td bgcolor=Pink></td>|<br>| Plum |    #DDA0DD |    rgb(221, 160, 221) <td bgcolor=Plum></td>|<br>| PowderBlue |    #B0E0E6 |    rgb(176, 224, 230) <td bgcolor=PowderBlue></td>|<br>| Purple |    #800080 |    rgb(128, 0, 128) <td bgcolor=Purple></td>|<br>| Red |    #FF0000 |    rgb(255, 0, 0) <td bgcolor=Red></td>|<br>| RosyBrown |    #BC8F8F |    rgb(188, 143, 143) <td bgcolor=RosyBrown></td>|<br>| RoyalBlue |    #4169E1 |    rgb(65, 105, 225) <td bgcolor=RoyalBlue></td>|<br>| SaddleBrown |    #8B4513 |    rgb(139, 69, 19) <td bgcolor=SaddleBrown></td>|<br>| Salmon |    #FA8072 |    rgb(250, 128, 114) <td bgcolor=Salmon></td>|<br>| SandyBrown |    #F4A460 |    rgb(244, 164, 96) <td bgcolor=SandyBrown></td>|<br>| SeaGreen |    #2E8B57 |    rgb(46, 139, 87) <td bgcolor=SeaGreen></td>|<br>| SeaShell |    #FFF5EE |    rgb(255, 245, 238) <td bgcolor=SeaShell></td>|<br>| Sienna |    #A0522D |    rgb(160, 82, 45) <td bgcolor=Sienna></td>|<br>| Silver |    #C0C0C0 |    rgb(192, 192, 192) <td bgcolor=Silver></td>|<br>| SkyBlue |    #87CEEB |    rgb(135, 206, 235) <td bgcolor=SkyBlue></td>|<br>| SlateBlue |    #6A5ACD |    rgb(106, 90, 205) <td bgcolor=SlateBlue></td>|<br>| SlateGray |    #708090 |    rgb(112, 128, 144) <td bgcolor=SlateGray></td>|<br>| Snow |    #FFFAFA |    rgb(255, 250, 250) <td bgcolor=Snow></td>|<br>| SpringGreen |    #00FF7F |    rgb(0, 255, 127) <td bgcolor=SpringGreen></td>|<br>| SteelBlue |    #4682B4 |    rgb(70, 130, 180) <td bgcolor=SteelBlue></td>|<br>| Tan |    #D2B48C |    rgb(210, 180, 140) <td bgcolor=Tan></td>|<br>| Teal |    #008080 |    rgb(0, 128, 128) <td bgcolor=Teal></td>|<br>| Thistle |    #D8BFD8 |    rgb(216, 191, 216) <td bgcolor=Thistle></td>|<br>| Tomato |    #FF6347 |    rgb(255, 99, 71) <td bgcolor=Tomato></td>|<br>| Turquoise |    #40E0D0 |    rgb(64, 224, 208) <td bgcolor=Turquoise></td>|<br>| Violet |    #EE82EE |    rgb(238, 130, 238) <td bgcolor=Violet></td>|<br>| VioletRed |    #D02090 |    rgb(208, 32, 144) <td bgcolor=VioletRed></td>|<br>| Wheat |    #F5DEB3 |    rgb(245, 222, 179) <td bgcolor=Wheat></td>|<br>| White |    #FFFFFF |    rgb(255, 255, 255) <td bgcolor=White></td>|<br>| WhiteSmoke |    #F5F5F5 |    rgb(245, 245, 245) <td bgcolor=WhiteSmoke></td>|<br>| Yellow |    #FFFF00 |    rgb(255, 255, 0) <td bgcolor=Yellow></td>|<br>| YellowGreen |    #9ACD32 |    rgb(154, 205, 50) <td bgcolor=YellowGreen></td>|</p>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Python下执行虚拟环境</title>
    <url>/python/python_virtual_env/</url>
    <content><![CDATA[<h2 id="Python下执行虚拟环境"><a href="#Python下执行虚拟环境" class="headerlink" title="Python下执行虚拟环境"></a>Python下执行虚拟环境</h2><p>虚拟环境是Python解释器的一个私有副本，在这个环境中你可以安装私有包，而且不会影响系统中安装的全局Python解释器。以此来解决Python版本和包与系统预装的发生的冲突，从而为每个项目单独创建虚拟环境，可保证应用只能访问虚拟环境中的包，从而是全局解释器干净整洁。</p>
<h4 id="1-在Python3中创建虚拟环境"><a href="#1-在Python3中创建虚拟环境" class="headerlink" title="1. 在Python3中创建虚拟环境"></a>1. 在Python3中创建虚拟环境</h4><p>在Python3中，虚拟环境由Python标准库中的venv包原生支持。</p>
<p>在Ubuntu系统下，安装python3-venv包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install python3-venv</span><br></pre></td></tr></table></figure>
<p>在CentOS系统下，安装python3-venv包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install python3-venv</span><br></pre></td></tr></table></figure>
<p>创建虚拟环境命令格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 -m venv virtual-env-name</span><br></pre></td></tr></table></figure>
<p>基本用法：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">venv [-h] [--system-site-packages] [--symlinks | --copies] [--clear]</span><br><span class="line">     [--upgrade] [--without-pip]</span><br><span class="line">     ENV_DIR [ENV_DIR ...]</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ENV_DIR</td>
<td>创建虚拟环境目录名称</td>
</tr>
<tr>
<td>-h, –help</td>
<td>显示帮助文档并退出</td>
</tr>
<tr>
<td>–system-site-packages</td>
<td>给虚拟环境访问系统站点包目录</td>
</tr>
<tr>
<td>–symlinks</td>
<td>当符号链接不是平台的默认设置时，尝试使用符号链接而不是副本</td>
</tr>
<tr>
<td>–copies</td>
<td>尝试使用副本而不是符号链接，即使符号链接是平台的默认设置</td>
</tr>
<tr>
<td>–clear</td>
<td>在创建环境之前，删除环境目录中已经存在的内容</td>
</tr>
<tr>
<td>–upgrade</td>
<td>升级环境目录以使用这个版本的Python，假设Python已经被就地升级</td>
</tr>
<tr>
<td>–without-pip</td>
<td>跳过在虚拟环境中安装或升级pip (pip默认是引导的)</td>
</tr>
</tbody></table>
<h3 id="2-在Python2中创建虚拟环境"><a href="#2-在Python2中创建虚拟环境" class="headerlink" title="2. 在Python2中创建虚拟环境"></a>2. 在Python2中创建虚拟环境</h3><p>Python2中没有venv包，所以借助第三方工具<code>virtualenv</code>创建虚拟环境。</p>
<p>在Ubuntu系统下，安装virtualenvv包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install virtualenv</span><br></pre></td></tr></table></figure>
<p>在Ubuntu系统下，安装virtualenvv包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install virtualenv</span><br></pre></td></tr></table></figure>
<p>创建虚拟环境命令格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">virtualenv -p python virtual-env-name</span><br></pre></td></tr></table></figure>
<h3 id="3-使用虚拟环境"><a href="#3-使用虚拟环境" class="headerlink" title="3. 使用虚拟环境"></a>3. 使用虚拟环境</h3><p>在Linux或者MacOS下激活虚拟环境：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source virtual-env-name&#x2F;bin&#x2F;activate</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">. .&#x2F;virtual-env-name&#x2F;bin&#x2F;activate</span><br></pre></td></tr></table></figure>
<p>退出虚拟环境：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure>
<h3 id="4-使用pip安装Python包"><a href="#4-使用pip安装Python包" class="headerlink" title="4. 使用pip安装Python包"></a>4. 使用pip安装Python包</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># install package</span><br><span class="line">pip install [package_name]</span><br><span class="line"></span><br><span class="line"># list packages</span><br><span class="line">pip freeze</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>BigData</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
